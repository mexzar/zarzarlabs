<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CONQUERERS</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap');
* { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

body {
  background: linear-gradient(180deg, #0a0a1a 0%, #1a1a2e 40%, #16213e 100%);
  color: #e0e0e0;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  overflow-x: hidden;
}

h1 {
  font-family: 'MedievalSharp', cursive, serif;
  font-size: 2.8rem;
  margin: 10px 0 2px;
  letter-spacing: 5px;
  color: #f0c040;
  text-shadow: 0 0 30px rgba(240,192,64,0.5), 0 2px 4px rgba(0,0,0,0.6);
}

#subtitle { font-size: 0.85rem; color: #8888aa; margin-bottom: 6px; letter-spacing: 2px; }

#hud {
  display: flex; gap: 10px; margin-bottom: 4px; font-size: 0.9rem;
  flex-wrap: wrap; justify-content: center;
}
#hud span {
  background: linear-gradient(180deg, #1a2744 0%, #0f1b30 100%);
  padding: 4px 12px; border-radius: 6px; border: 1px solid #2a3a5a;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}
#hud .label { color: #778; font-size: 0.8rem; }
#hud .val { font-weight: bold; }
#army-str .val { color: #4fc3f7; }
#forts-left .val { color: #ff8a65; }
#gold-num .val { color: #ffd54f; }
#kills-num .val { color: #ef9a9a; }

#message {
  height: 22px; font-size: 0.9rem; color: #ce93d8; margin-bottom: 2px;
  text-align: center; text-shadow: 0 0 10px rgba(206,147,216,0.3);
}

canvas {
  border: 2px solid #2a3a5a; border-radius: 8px; cursor: pointer;
  box-shadow: 0 4px 30px rgba(0,0,0,0.5);
  max-width: 98vw;
}

#controls {
  margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap; justify-content: center;
}
#controls button {
  background: linear-gradient(180deg, #1e2d4a 0%, #121e33 100%);
  color: #ccd; border: 1px solid #3a4a6a; padding: 5px 14px; border-radius: 6px;
  cursor: pointer; font-size: 0.82rem; transition: all 0.2s;
}
#controls button:hover { background: linear-gradient(180deg, #2a3d5a 0%, #1a2a44 100%); }

#shop {
  margin-top: 6px; display: flex; gap: 6px; flex-wrap: wrap; justify-content: center;
}
#shop button {
  background: linear-gradient(180deg, #1a2a1e 0%, #0e1a10 100%);
  color: #81c784; border: 1px solid #2e5a32; padding: 4px 10px; border-radius: 6px;
  cursor: pointer; font-size: 0.78rem; transition: all 0.2s;
}
#shop button:hover { background: linear-gradient(180deg, #2a3a2e 0%, #1a2a1e 100%); }
#shop button:disabled { opacity: 0.35; cursor: default; }

#legend {
  margin-top: 8px; font-size: 0.72rem; color: #556; text-align: center;
  max-width: 1100px; line-height: 1.7;
}
#legend b { color: #889; }

#overlay {
  display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.82);
  justify-content: center; align-items: center; flex-direction: column;
  z-index: 10; backdrop-filter: blur(4px);
}
#overlay.show { display: flex; }
#overlay h2 {
  font-family: 'MedievalSharp', cursive, serif; font-size: 3rem;
  margin-bottom: 10px; text-shadow: 0 0 40px currentColor;
}
#overlay p { font-size: 1rem; margin-bottom: 16px; color: #bbc; text-align: center; white-space: pre-line; }
#overlay button {
  background: linear-gradient(180deg, #f0c040 0%, #c89020 100%);
  color: #1a1a2e; border: none; padding: 10px 28px; border-radius: 8px;
  font-size: 1rem; cursor: pointer; font-weight: bold;
  box-shadow: 0 4px 20px rgba(240,192,64,0.4); transition: transform 0.15s;
}
#overlay button:hover { transform: scale(1.05); }
</style>
</head>
<body>

<h1>CONQUERERS</h1>
<p id="subtitle">BUILD YOUR KINGDOM & CONQUER THE REALM</p>

<div id="hud">
  <span id="player-name"><span class="val" id="nameVal" style="color:#f0c040;"></span></span>
  <span id="army-str"><span class="label">Power </span><span class="val" id="armyVal">10</span></span>
  <span id="forts-left"><span class="label">Castles Left </span><span class="val" id="castlesVal">0</span></span>
  <span id="gold-num"><span class="label">Gold </span><span class="val" id="goldVal">0</span></span>
  <span id="resource-wood"><span class="label">Wood </span><span class="val" id="woodVal" style="color:#8d6e63">0</span></span>
  <span id="resource-stone"><span class="label">Stone </span><span class="val" id="stoneVal" style="color:#90a4ae">0</span></span>
  <span id="resource-iron"><span class="label">Iron </span><span class="val" id="ironVal" style="color:#78909c">0</span></span>
  <span id="resource-crops"><span class="label">Crops </span><span class="val" id="cropsVal" style="color:#66bb6a">0</span></span>
  <span id="resource-meat"><span class="label">Meat </span><span class="val" id="meatVal" style="color:#ef5350">0</span></span>
  <span id="pop-num"><span class="label">Pop </span><span class="val" id="popVal" style="color:#ce93d8">0</span></span>
  <span id="kills-num"><span class="label">Kills </span><span class="val" id="killsVal">0</span></span>
  <span id="morale-num"><span class="label">Morale </span><span class="val" id="moraleVal">0</span></span>
  <span id="eng-num"><span class="label">Smiths </span><span class="val" id="engVal" style="color:#ff9800">0</span></span>
  <span id="income-num"><span class="label">Income </span><span class="val" id="incomeVal" style="color:#ffd54f">none</span></span>
</div>

<div id="message">&nbsp;</div>

<canvas id="game"></canvas>

<div id="controls">
  <button onclick="newGame()">Restart Game</button>
  <button onclick="showSaveLoadUI()">Save/Load</button>
  <button onclick="tryBuildCastle()" id="buildCastleBtn">Build Castle</button>
  <button onclick="toggleBuildMenu()">Build (B)</button>
  <button onclick="harvest()">Harvest (H)</button>
  <button onclick="showSettlementInfo()">Settlement</button>
  <button onclick="showResearchMenu()">Research</button>
</div>

<div id="shop">
  <button onclick="shopBuy('militia')">Militia x3 (10g)</button>
  <button onclick="shopBuy('longbowmen')">Longbowmen x2 (25g)</button>
  <button onclick="shopBuy('crossbowmen')">Crossbowmen x1 (30g)</button>
  <button onclick="shopBuy('menatarms')">Men-at-Arms x1 (40g)</button>
  <button onclick="shopBuy('pikemen')">Pikemen x1 (35g)</button>
  <button onclick="shopBuy('knights')">Knights x1 (50g)</button>
  <button onclick="shopBuy('catapults')">Catapults x1 (50g)</button>
  <button onclick="shopBuy('healers')">Healers x1 (45g)</button>
  <button onclick="shopBuy('firelancers')">Fire Lancers x1 (50g)</button>
  <button onclick="shopBuy('assassins')">Assassins x1 (55g)</button>
  <button onclick="shopBuy('cannons')">Cannons x1 (55g)</button>
  <button onclick="shopHealAll()">Heal All (20g)</button>
  <button onclick="shopScout()">Scout Map (15g)</button>
</div>
<div id="blacksmith-shop" style="margin-top:4px; display:flex; gap:6px; flex-wrap:wrap; justify-content:center;">
  <button onclick="engineerBuy('armorPiercing')" style="background:linear-gradient(180deg,#2a1a1a 0%,#1a0e0e 100%); color:#ff8a65; border:1px solid #5a2e2e; padding:4px 10px; border-radius:6px; cursor:pointer; font-size:0.78rem;">Sharpened Blades Lv0 (30g)</button>
  <button onclick="engineerBuy('extendedMag')" style="background:linear-gradient(180deg,#2a1a1a 0%,#1a0e0e 100%); color:#ff8a65; border:1px solid #5a2e2e; padding:4px 10px; border-radius:6px; cursor:pointer; font-size:0.78rem;">Longer Bows Lv0 (40g)</button>
  <button onclick="engineerBuy('reinforced')" style="background:linear-gradient(180deg,#2a1a1a 0%,#1a0e0e 100%); color:#ff8a65; border:1px solid #5a2e2e; padding:4px 10px; border-radius:6px; cursor:pointer; font-size:0.78rem;">Hardened Armor Lv0 (25g)</button>
  <button onclick="engineerBuy('explosiveRounds')" style="background:linear-gradient(180deg,#2a1a1a 0%,#1a0e0e 100%); color:#ff8a65; border:1px solid #5a2e2e; padding:4px 10px; border-radius:6px; cursor:pointer; font-size:0.78rem;">Siege Expertise Lv0 (50g)</button>
</div>

<div id="legend">
  <b>Arrow keys / WASD / Click</b> to move |
  <b>Units:</b>
  <span style="color:#78909c">Militia</span> -
  <span style="color:#26a69a">Longbowmen</span> -
  <span style="color:#7e57c2">Crossbowmen</span> -
  <span style="color:#5c6bc0">Men-at-Arms</span> -
  <span style="color:#ef6c00">Pikemen</span> -
  <span style="color:#546e7a">Knights</span> -
  <span style="color:#e64a19">Catapults</span> -
  <span style="color:#66bb6a">Healers</span> -
  <span style="color:#ff7043">Fire Lancers</span> -
  <span style="color:#ab47bc">Assassins</span> -
  <span style="color:#42a5f5">Cannons</span>
</div>

<div id="overlay">
  <h2 id="overlayTitle"></h2>
  <p id="overlayMsg"></p>
  <input id="overlayInput" type="text" maxlength="16" placeholder="Enter your name..."
    style="display:none; background:#1a1a2e; color:#f0c040; border:2px solid #f0c040; padding:8px 16px;
    border-radius:8px; font-size:1.1rem; text-align:center; margin-bottom:12px; outline:none;
    font-family:'MedievalSharp',cursive,serif; letter-spacing:2px; width:220px;">
  <button id="overlayBtn" onclick="overlayAction()">Continue</button>
</div>

<script>
// ===============================================
//  CONSTANTS
// ===============================================
const TILE_W = 64;
const TILE_H = 32;
const TILE = 44;
const CHUNK_SIZE = 16;
const MAX_CHUNKS = 16;
const PANEL_H = 54;
const W = 1100;
const H = 750;
const WALL_HEIGHT = 18;
const MINIMAP_SIZE = 150;

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = W;
canvas.height = H;

// Camera state (grid coords, follows player smoothly)
let camX = 50, camY = 50;
const CAM_SPEED = 0.12;

// Minimap offscreen canvas
const minimapCanvas = document.createElement('canvas');
minimapCanvas.width = MINIMAP_SIZE;
minimapCanvas.height = MINIMAP_SIZE;
const mmCtx = minimapCanvas.getContext('2d');
let minimapDirty = true;

// ===============================================
//  ISOMETRIC TRANSFORMS (camera-relative)
// ===============================================
function toIso(gx, gy) {
  const relX = gx - camX;
  const relY = gy - camY;
  return {
    x: (relX - relY) * (TILE_W / 2) + W / 2,
    y: (relX + relY) * (TILE_H / 2) + (H - PANEL_H) / 2
  };
}
function fromIso(sx, sy) {
  const rx = sx - W / 2;
  const ry = sy - (H - PANEL_H) / 2;
  const relX = (rx / (TILE_W / 2) + ry / (TILE_H / 2)) / 2;
  const relY = (ry / (TILE_H / 2) - rx / (TILE_W / 2)) / 2;
  return { x: Math.round(relX + camX), y: Math.round(relY + camY) };
}

function updateCamera() {
  camX += (player.x - camX) * CAM_SPEED;
  camY += (player.y - camY) * CAM_SPEED;
  // No COLS/ROWS clamp - infinite map
}

// Get visible tile range for viewport culling (no COLS/ROWS bounds)
function getVisibleRange() {
  const margin = 3;
  const halfW = Math.ceil(W / TILE_W) + margin;
  const halfH = Math.ceil((H - PANEL_H) / TILE_H) + margin;
  return {
    minX: Math.floor(camX - halfW),
    maxX: Math.ceil(camX + halfW),
    minY: Math.floor(camY - halfH),
    maxY: Math.ceil(camY + halfH)
  };
}

// ===============================================
//  TROOP TYPE DEFINITIONS (player army)
// ===============================================
const TROOP_TYPES = {
  militia:     { name:'Militia',       str:3,   color:'#78909c', dark:'#37474f', cost:10, qty:3, desc:'Basic infantry, swords' },
  longbowmen:  { name:'Longbowmen',    str:2.5, color:'#26a69a', dark:'#00695c', cost:25, qty:2, desc:'Ranged pre-combat damage' },
  crossbowmen: { name:'Crossbowmen',   str:4.5, color:'#7e57c2', dark:'#4527a0', cost:30, qty:1, desc:'Splash/area suppression' },
  menatarms:   { name:'Men-at-Arms',   str:5,   color:'#5c6bc0', dark:'#283593', cost:40, qty:1, desc:'Heavy melee fighters' },
  pikemen:     { name:'Pikemen',       str:4,   color:'#ef6c00', dark:'#bf360c', cost:35, qty:1, desc:'+60% vs heavy enemies' },
  knights:     { name:'Knights',       str:10,  color:'#546e7a', dark:'#263238', cost:50, qty:1, desc:'Heavy cavalry, +5 armor' },
  catapults:   { name:'Catapults',     str:12,  color:'#e64a19', dark:'#bf360c', cost:50, qty:1, desc:'Siege, massive AOE +castle bonus' },
  healers:     { name:'Healers',       str:2,   color:'#66bb6a', dark:'#2e7d32', cost:45, qty:1, desc:'Heal allies in battle' },
  firelancers: { name:'Fire Lancers',  str:6,   color:'#ff7043', dark:'#d84315', cost:50, qty:1, desc:'Short range massive AOE (Greek fire)' },
  assassins:   { name:'Assassins',     str:5,   color:'#ab47bc', dark:'#6a1b9a', cost:55, qty:1, desc:'Fast stealth attacker' },
  cannons:     { name:'Cannons',       str:9,   color:'#42a5f5', dark:'#1565c0', cost:55, qty:1, desc:'STRONGEST ranged siege weapon' },
};
const TROOP_ORDER = ['militia','longbowmen','crossbowmen','menatarms','pikemen','knights','catapults','healers','firelancers','assassins','cannons'];

// ===============================================
//  ENEMY TYPE DEFINITIONS
// ===============================================
const ENEMY_TYPES = {
  bandit:       { name:'Bandit',        color:'#8d6e63', dark:'#4e342e', speed:2, detectRange:7, strMul:0.6,  goldMul:0.25, yields:'militia',    heavy:false },
  raider:       { name:'Raider',        color:'#455a64', dark:'#263238', speed:2, detectRange:8, strMul:1.2,  goldMul:0.4,  yields:'militia',    heavy:false },
  enemy_archer: { name:'Enemy Archer',  color:'#00897b', dark:'#004d40', speed:1, detectRange:9, strMul:0.9,  goldMul:0.4,  ranged:true, yields:'longbowmen', heavy:false },
  war_elephant: { name:'War Elephant',  color:'#607d8b', dark:'#37474f', speed:1, detectRange:5, strMul:2.0,  goldMul:0.6,  yields:'menatarms', heavy:true },
  dragon_rider: { name:'Dragon Rider',  color:'#42a5f5', dark:'#1565c0', speed:3, detectRange:10,strMul:1.8,  goldMul:0.5,  charge:true, yields:'pikemen', heavy:true },
  dark_mage:    { name:'Dark Mage',     color:'#ab47bc', dark:'#6a1b9a', speed:1, detectRange:6, strMul:0.8,  goldMul:0.5,  yields:'assassins', heavy:false },
  troll:        { name:'Troll',         color:'#76ff03', dark:'#33691e', speed:2, detectRange:5, strMul:1.5,  goldMul:0.35, yields:'menatarms', heavy:true },
};

// ===============================================
//  BATTLE STATS (tactical battle system)
// ===============================================
const BATTLE_STATS = {
  militia:     { hp:8,  atk:3,  range:3, moveRange:3, aoe:0, name:'Militia',      moveSpeed:0.03, attackRate:45 },
  longbowmen:  { hp:5,  atk:5,  range:6, moveRange:2, aoe:0, name:'Longbowman',   moveSpeed:0.02, attackRate:80 },
  crossbowmen: { hp:10, atk:4,  range:3, moveRange:2, aoe:1, name:'Crossbowman',  moveSpeed:0.02, attackRate:20 },
  menatarms:   { hp:12, atk:5,  range:3, moveRange:2, aoe:0, name:'Man-at-Arms',  moveSpeed:0.02, attackRate:35 },
  pikemen:     { hp:8,  atk:6,  range:4, moveRange:2, aoe:0, name:'Pikeman',      moveSpeed:0.02, attackRate:60 },
  knights:     { hp:25, atk:8,  range:3, moveRange:2, aoe:0, name:'Knight',       moveSpeed:0.015,attackRate:50 },
  catapults:   { hp:6,  atk:12, range:5, moveRange:3, aoe:2, name:'Catapult',     moveSpeed:0.035,attackRate:70 },
  healers:     { hp:10, atk:1,  range:2, moveRange:3, aoe:0, name:'Healer',       moveSpeed:0.03, attackRate:50 },
  firelancers: { hp:7,  atk:7,  range:2, moveRange:2, aoe:2, name:'Fire Lancer',  moveSpeed:0.02, attackRate:30 },
  assassins:   { hp:6,  atk:8,  range:3, moveRange:4, aoe:0, name:'Assassin',     moveSpeed:0.04, attackRate:40 },
  cannons:     { hp:18, atk:7,  range:4, moveRange:4, aoe:0, name:'Cannon',       moveSpeed:0.04, attackRate:50 },
};

// ===============================================
//  ENEMY BATTLE STATS
// ===============================================
const ENEMY_BATTLE_STATS = {
  bandit:       { hp:6,  atk:2, range:2, moveRange:3, aoe:0, heavy:false, moveSpeed:0.03, attackRate:45 },
  raider:       { hp:10, atk:4, range:3, moveRange:3, aoe:0, heavy:false, moveSpeed:0.025,attackRate:40 },
  enemy_archer: { hp:5,  atk:4, range:6, moveRange:2, aoe:0, heavy:false, moveSpeed:0.02, attackRate:70 },
  war_elephant: { hp:30, atk:6, range:3, moveRange:2, aoe:1, heavy:true,  moveSpeed:0.015,attackRate:45 },
  dragon_rider: { hp:20, atk:7, range:4, moveRange:4, aoe:0, heavy:true,  moveSpeed:0.04, attackRate:50 },
  dark_mage:    { hp:8,  atk:2, range:3, moveRange:2, aoe:0, heavy:false, moveSpeed:0.015,attackRate:60 },
  troll:        { hp:18, atk:6, range:1, moveRange:3, aoe:0, heavy:true,  moveSpeed:0.025,attackRate:40 },
};

// ===============================================
//  UPGRADE DEFINITIONS (blacksmith upgrades)
// ===============================================
const UPGRADE_DEFS = {
  armorPiercing:   { name: 'Sharpened Blades', maxLvl: 3, costs: [30, 60, 100], desc: '+1 ATK all' },
  extendedMag:     { name: 'Longer Bows',      maxLvl: 2, costs: [40, 80],      desc: '+1 Range all' },
  reinforced:      { name: 'Hardened Armor',    maxLvl: 3, costs: [25, 50, 85],  desc: '+3 HP all' },
  explosiveRounds: { name: 'Siege Expertise',   maxLvl: 2, costs: [50, 90],      desc: '+1 AOE catapult/crossbow' },
};

// ===============================================
//  FORT (CASTLE) UPGRADE DEFINITIONS
// ===============================================
const FORT_UPGRADE_DEFS = {
  walls:   [{cost:80, def:2, name:'Palisade'},{cost:160, def:5, name:'Stone Ramparts'},{cost:300, def:10, name:'Fortified Keep'}],
  turrets: [{cost:100, dmg:3, name:'Arrow Tower'},{cost:200, dmg:7, name:'Ballista Tower'},{cost:350, dmg:12, name:'Cannon Tower'}],
  mines:   [{cost:120, income:5, name:'Tax Collector'},{cost:250, income:12, name:'Trade Post'},{cost:400, income:20, name:'Royal Treasury'}],
};

// ===============================================
//  BUILDING DEFINITIONS (settlement buildings, 3 upgrade levels)
// ===============================================
const BUILDING_DEFS = {
  house: {
    name: 'House', category: 'infrastructure', workers: 0, requiresAdj: null,
    levels: [
      { cost: { wood: 10, stone: 5 }, buildTime: 3, popCap: 4 },
      { cost: { wood: 15, stone: 10 }, buildTime: 5, popCap: 6 },
      { cost: { wood: 25, stone: 15, iron: 5 }, buildTime: 7, popCap: 8 },
    ]
  },
  farm: {
    name: 'Farm', category: 'production', workers: 2, requiresAdj: null,
    levels: [
      { cost: { wood: 8, stone: 2 }, buildTime: 4, production: { crops: 3 } },
      { cost: { wood: 12, stone: 5 }, buildTime: 6, production: { crops: 5 } },
      { cost: { wood: 20, stone: 8, iron: 3 }, buildTime: 8, production: { crops: 8 } },
    ]
  },
  lumbermill: {
    name: 'Lumbermill', category: 'production', workers: 2, requiresAdj: 'tree',
    levels: [
      { cost: { wood: 5, stone: 8 }, buildTime: 5, production: { wood: 3 } },
      { cost: { wood: 10, stone: 12 }, buildTime: 7, production: { wood: 5 } },
      { cost: { wood: 15, stone: 18, iron: 5 }, buildTime: 9, production: { wood: 8 } },
    ]
  },
  quarry: {
    name: 'Quarry', category: 'production', workers: 3, requiresAdj: 'wall',
    levels: [
      { cost: { wood: 10, iron: 2 }, buildTime: 6, production: { stone: 3 } },
      { cost: { wood: 15, iron: 5 }, buildTime: 8, production: { stone: 5 } },
      { cost: { wood: 25, iron: 10 }, buildTime: 10, production: { stone: 8 } },
    ]
  },
  mine: {
    name: 'Mine', category: 'production', workers: 3, requiresAdj: 'wall',
    levels: [
      { cost: { wood: 12, stone: 10 }, buildTime: 8, production: { iron: 2 } },
      { cost: { wood: 20, stone: 15 }, buildTime: 10, production: { iron: 4 } },
      { cost: { wood: 30, stone: 20, gold: 5 }, buildTime: 12, production: { iron: 6 } },
    ]
  },
  huntingLodge: {
    name: 'Hunting Lodge', category: 'production', workers: 2, requiresAdj: 'tree',
    levels: [
      { cost: { wood: 12, stone: 3 }, buildTime: 4, production: { meat: 2 } },
      { cost: { wood: 18, stone: 6 }, buildTime: 6, production: { meat: 4 } },
      { cost: { wood: 25, stone: 10, iron: 3 }, buildTime: 8, production: { meat: 6 } },
    ]
  },
  watchtower: {
    name: 'Watchtower', category: 'infrastructure', workers: 1, requiresAdj: null,
    levels: [
      { cost: { wood: 15, stone: 10 }, buildTime: 5, visionRange: 4 },
      { cost: { wood: 20, stone: 15, iron: 5 }, buildTime: 7, visionRange: 6 },
      { cost: { wood: 30, stone: 20, iron: 10 }, buildTime: 9, visionRange: 8 },
    ]
  },
  market: {
    name: 'Market', category: 'economy', workers: 2, requiresAdj: null,
    levels: [
      { cost: { wood: 15, stone: 10, gold: 10 }, buildTime: 6, production: { gold: 2 }, tradeRatio: 4 },
      { cost: { wood: 25, stone: 15, gold: 20 }, buildTime: 8, production: { gold: 4 }, tradeRatio: 3 },
      { cost: { wood: 40, stone: 25, gold: 35 }, buildTime: 10, production: { gold: 6 }, tradeRatio: 2 },
    ]
  },
  warehouse: {
    name: 'Warehouse', category: 'infrastructure', workers: 0, requiresAdj: null,
    levels: [
      { cost: { wood: 20, stone: 15 }, buildTime: 5, storageCap: 50 },
      { cost: { wood: 30, stone: 20, iron: 5 }, buildTime: 7, storageCap: 100 },
      { cost: { wood: 45, stone: 30, iron: 10 }, buildTime: 9, storageCap: 200 },
    ]
  },
  hospital: {
    name: 'Hospital', category: 'infrastructure', workers: 2, requiresAdj: null,
    levels: [
      { cost: { wood: 15, stone: 10, crops: 5 }, buildTime: 6, healRate: 2 },
      { cost: { wood: 25, stone: 15, crops: 10 }, buildTime: 8, healRate: 4 },
      { cost: { wood: 40, stone: 25, crops: 15, iron: 5 }, buildTime: 10, healRate: 8 },
    ]
  },
  academy: {
    name: 'Academy', category: 'infrastructure', workers: 3, requiresAdj: null,
    levels: [
      { cost: { wood: 20, stone: 20, gold: 15 }, buildTime: 10, researchSpeed: 1 },
      { cost: { wood: 35, stone: 30, gold: 25 }, buildTime: 12, researchSpeed: 1.5 },
      { cost: { wood: 50, stone: 40, gold: 40, iron: 10 }, buildTime: 14, researchSpeed: 2 },
    ]
  },
  temple: {
    name: 'Temple', category: 'infrastructure', workers: 1, requiresAdj: null,
    levels: [
      { cost: { stone: 25, gold: 10 }, buildTime: 8, moraleBonus: 1 },
      { cost: { stone: 35, gold: 20 }, buildTime: 10, moraleBonus: 2 },
      { cost: { stone: 50, gold: 35, iron: 5 }, buildTime: 12, moraleBonus: 3 },
    ]
  },
  port: {
    name: 'Port', category: 'production', workers: 2, requiresAdj: 'water',
    levels: [
      { cost: { wood: 20, stone: 8 }, buildTime: 6, production: { meat: 3 } },
      { cost: { wood: 30, stone: 15, iron: 5 }, buildTime: 8, production: { meat: 5 } },
      { cost: { wood: 45, stone: 25, iron: 10 }, buildTime: 10, production: { meat: 8 } },
    ]
  },
  blacksmith: {
    name: 'Blacksmith', category: 'production', workers: 2, requiresAdj: null,
    levels: [
      { cost: { wood: 15, stone: 10, iron: 5 }, buildTime: 6, toolBonus: 1 },
      { cost: { wood: 25, stone: 18, iron: 12 }, buildTime: 8, toolBonus: 2 },
      { cost: { wood: 40, stone: 28, iron: 20 }, buildTime: 10, toolBonus: 3 },
    ]
  },
};

// ===============================================
//  RESOURCE DEFINITIONS
// ===============================================
const RESOURCES = ['wood', 'stone', 'iron', 'gold', 'meat', 'crops'];
const RESOURCE_DEFS = {
  wood:  { name: 'Wood',  color: '#8d6e63', icon: 'W' },
  stone: { name: 'Stone', color: '#90a4ae', icon: 'S' },
  iron:  { name: 'Iron',  color: '#78909c', icon: 'I' },
  gold:  { name: 'Gold',  color: '#ffd54f', icon: 'G' },
  meat:  { name: 'Meat',  color: '#ef5350', icon: 'M' },
  crops: { name: 'Crops', color: '#66bb6a', icon: 'C' },
};

// ===============================================
//  TECH TREE
// ===============================================
const TECH_TREE = {
  improvedTools:   { name: 'Improved Tools',   cost: { gold: 20, iron: 10 },  time: 15, effect: 'production_boost', value: 0.25, requires: [] },
  stoneMasonry:    { name: 'Stone Masonry',     cost: { gold: 15, stone: 15 }, time: 12, effect: 'wall_hp_boost', value: 2, requires: [] },
  ironWorking:     { name: 'Iron Working',      cost: { gold: 25, iron: 15 },  time: 20, effect: 'mine_boost', value: 0.5, requires: [] },
  advancedFarming: { name: 'Advanced Farming',  cost: { gold: 20, crops: 10 }, time: 15, effect: 'farm_boost', value: 2, requires: ['improvedTools'] },
  economics:       { name: 'Economics',         cost: { gold: 35 },            time: 20, effect: 'market_boost', value: 1, requires: [] },
  medicine:        { name: 'Medicine',          cost: { gold: 30, crops: 15 }, time: 18, effect: 'heal_boost', value: 2, requires: ['advancedFarming'] },
};

// ===============================================
//  GAME STATE
// ===============================================
let player, enemies, forts, allies, chests, walls, gold, scouted, kills, mercCamps;
let playerName = '';
let particles = [], floatingTexts = [], ambientParticles = [];
let turnCount = 0, animFrame = 0, shake = 0, tensionTimer = 0;
let morale = 0;
let upgrades = { armorPiercing: 0, extendedMag: 0, reinforced: 0, explosiveRounds: 0 };
let followerTrail = [];
let overworldEngineers = [];
let recruitedEngineers = 0, engineerATKBonus = 0, engineerTimer = 0;
let playerForts = [];
let territoryMap = {};  // sparse: "x,y" -> 'player'|'enemy'
let pendingAttacks = [];
let goldPerTurn = 0;
let fortMenuOpen = false, fortMenuIndex = -1;

// Merged settlement state as globals
let resources = { wood: 30, stone: 20, iron: 0, gold: 0, meat: 5, crops: 10 };
let storageCap = { wood: 100, stone: 100, iron: 50, gold: 200, meat: 50, crops: 80 };
let population = 4, popCap = 4, idleWorkers = 4;
let buildings = [], nextBuildingId = 1;
let researched = {}, currentResearch = null;
let notifications = [];
let buildMode = false, buildSelected = null, buildGhost = null;
let chunks = {};  // "cx,cy" -> { generated, cx, cy }

// Map data - 2D arrays lazily filled [y][x]
let grassMap = [], treeMap = [], waterMap = [], pathMap = [], fogMap = [];

// ===============================================
//  SMOOTH ANIMATION STATE
// ===============================================
const MOVE_SPEED = 0.18;
let moveQueue = [], isAnimating = false;
let playerVisual = { x: 1, y: 1 };

// ===============================================
//  GAME MODE & TACTICAL BATTLE STATE
// ===============================================
let gameMode = 'overworld'; // 'overworld' | 'deploy' | 'battle' | 'battle_result'

const BCOLS = 12, BROWS = 8;
let battle = null;
let battleParticles = [], battleFloatingTexts = [], battleProjectiles = [];
let deploySelectedType = null;
let followerVisuals = [];

// ===============================================
//  BATTLE ISOMETRIC TRANSFORMS
// ===============================================
const BATTLE_ISO_X = W / 2;
const BATTLE_ISO_Y = 100;

function toBattleIso(gx, gy) {
  return {
    x: (gx - gy) * (TILE_W / 2) + BATTLE_ISO_X,
    y: (gx + gy) * (TILE_H / 2) + BATTLE_ISO_Y
  };
}
function fromBattleIso(sx, sy) {
  const rx = sx - BATTLE_ISO_X;
  const ry = sy - BATTLE_ISO_Y;
  const gx = (rx / (TILE_W / 2) + ry / (TILE_H / 2)) / 2;
  const gy = (ry / (TILE_H / 2) - rx / (TILE_W / 2)) / 2;
  return { x: Math.round(gx), y: Math.round(gy) };
}

// ===============================================
//  END OF DECLARATIONS (part 1)
//  Functions begin in part 2...
// ===============================================
// ===============================================
//  PART 2: CORE GAME FUNCTIONS
// ===============================================

// -----------------------------------------------
//  UTILITY HELPERS
// -----------------------------------------------
function k(x, y) { return x + ',' + y; }
function randInt(a, b) { return a + Math.floor(Math.random() * (b - a + 1)); }
function lerp(a, b, t) { return a + (b - a) * t; }
function dist(a, b) { return Math.abs(a.x - b.x) + Math.abs(a.y - b.y); }

function freeSpot() {
  // Find free spot near player in loaded chunks
  for (let i = 0; i < 500; i++) {
    const x = player.x + randInt(-20, 20), y = player.y + randInt(-20, 20);
    if (x < 0 || y < 0) continue;
    if (walls.has(k(x, y))) continue;
    if (waterMap[y] && waterMap[y][x]) continue;
    if (player && x === player.x && y === player.y) continue;
    if (enemies.some(e => e.x === x && e.y === y)) continue;
    if (forts.some(f => f.x === x && f.y === y)) continue;
    if (playerForts.some(f => f.gx === x && f.gy === y)) continue;
    if (allies.some(a => a.x === x && a.y === y)) continue;
    if (chests.some(c => c.x === x && c.y === y)) continue;
    return { x, y };
  }
  return { x: player.x + 5, y: player.y + 5 };
}

function freeSpotNear(nearX, nearY, radius) {
  for (let i = 0; i < 200; i++) {
    const x = nearX + randInt(-radius, radius), y = nearY + randInt(-radius, radius);
    if (x < 0 || y < 0) continue;
    if (walls.has(k(x, y))) continue;
    if (waterMap[y] && waterMap[y][x]) continue;
    if (player && x === player.x && y === player.y) continue;
    if (enemies.some(e => e.x === x && e.y === y)) continue;
    if (forts.some(f => f.x === x && f.y === y)) continue;
    if (playerForts.some(f => f.gx === x && f.gy === y)) continue;
    return { x, y };
  }
  return null;
}

function revealAround(cx, cy, r) {
  for (let dy = -r; dy <= r; dy++) {
    for (let dx = -r; dx <= r; dx++) {
      if (dx * dx + dy * dy > r * r) continue;
      const nx = cx + dx, ny = cy + dy;
      if (nx >= 0 && ny >= 0 && fogMap[ny] && fogMap[ny][nx] !== undefined) {
        fogMap[ny][nx] = 2;
      }
    }
  }
  minimapDirty = true;
}

function dimFog() {
  // Only dim tiles in loaded chunks around player
  const range = 30;
  for (let dy = -range; dy <= range; dy++) {
    for (let dx = -range; dx <= range; dx++) {
      const x = player.x + dx, y = player.y + dy;
      if (x >= 0 && y >= 0 && fogMap[y] && fogMap[y][x] === 2) fogMap[y][x] = 1;
    }
  }
  revealAround(player.x, player.y, 5);
  for (const pf of playerForts) revealAround(pf.gx, pf.gy, 3 + (pf.walls || 0));
  // Watchtowers reveal
  for (const bld of buildings) {
    if (bld.type === 'watchtower' && bld.built) {
      const def = BUILDING_DEFS.watchtower.levels[bld.level];
      revealAround(bld.gx, bld.gy, def.visionRange || 4);
    }
  }
}

function msg(t) { document.getElementById('message').textContent = t; }

// -----------------------------------------------
//  ARMY HELPERS
// -----------------------------------------------
function newArmy() {
  const a = {};
  for (const t of TROOP_ORDER) a[t] = [];
  return a;
}

function armyCount(army, type) {
  const v = army[type];
  if (Array.isArray(v)) return v.length;
  return v || 0;
}

function armyTotal(army) {
  let n = 0;
  for (const t of TROOP_ORDER) n += armyCount(army, t);
  return n;
}

function armyPower(army) {
  let p = 0;
  for (const t of TROOP_ORDER) p += armyCount(army, t) * TROOP_TYPES[t].str;
  return Math.ceil(p);
}

function armyBonus(army) {
  return armyCount(army, 'knights') * 5;
}

function effectivePower(army, enemyStr, enemyType) {
  let p = armyPower(army);
  p += armyBonus(army);
  // Pikemen bonus vs heavy enemies
  if (enemyType && ENEMY_TYPES[enemyType] && ENEMY_TYPES[enemyType].heavy) {
    p += armyCount(army, 'pikemen') * TROOP_TYPES['pikemen'].str * 0.6;
  }
  // Morale bonus
  if (morale > 0) p = Math.ceil(p * (1 + morale * 0.05));
  // Engineer ATK bonus
  p += engineerATKBonus;
  return Math.ceil(p);
}

function archerPreDamage(army) {
  // Longbowmen and catapults deal pre-combat ranged damage
  let dmg = 0;
  dmg += armyCount(army, 'longbowmen') * 3;
  dmg += armyCount(army, 'catapults') * 5;
  return dmg;
}

function loseTroops(army, losses) {
  let remaining = losses;
  // Lose weakest first
  for (let i = TROOP_ORDER.length - 1; i >= 0 && remaining > 0; i--) {
    const t = TROOP_ORDER[i];
    if (t === 'knights') continue; // knights last
    if (Array.isArray(army[t])) {
      while (army[t].length > 0 && remaining > 0) {
        army[t].pop();
        remaining--;
      }
    }
  }
  // Knights last
  if (remaining > 0 && Array.isArray(army['knights'])) {
    while (army['knights'].length > 0 && remaining > 0) {
      army['knights'].pop();
      remaining--;
    }
  }
}

function addTroops(army, type, count) {
  if (!army[type]) army[type] = [];
  if (!Array.isArray(army[type])) army[type] = [];
  for (let i = 0; i < count; i++) {
    const bs = BATTLE_STATS[type];
    army[type].push({
      hp: bs ? bs.hp : 8,
      maxHp: bs ? bs.hp : 8,
      type: type
    });
  }
}

function armySummary(army) {
  const parts = [];
  for (const t of TROOP_ORDER) {
    const c = armyCount(army, t);
    if (c > 0) parts.push(c + ' ' + TROOP_TYPES[t].name);
  }
  return parts.join(', ') || 'None';
}

// -----------------------------------------------
//  CHUNK NOISE AND CHUNK SYSTEM
// -----------------------------------------------
function noise(x, y) {
  let n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
  return n - Math.floor(n);
}

function getChunkKey(cx, cy) { return cx + ',' + cy; }

function ensureChunk(cx, cy) {
  const ckey = getChunkKey(cx, cy);
  if (chunks[ckey]) return;
  const baseX = cx * CHUNK_SIZE;
  const baseY = cy * CHUNK_SIZE;
  for (let y = baseY; y < baseY + CHUNK_SIZE; y++) {
    if (!grassMap[y]) grassMap[y] = [];
    if (!treeMap[y]) treeMap[y] = [];
    if (!waterMap[y]) waterMap[y] = [];
    if (!pathMap[y]) pathMap[y] = [];
    if (!fogMap[y]) fogMap[y] = [];
    for (let x = baseX; x < baseX + CHUNK_SIZE; x++) {
      const seed = noise(x, y);
      grassMap[y][x] = seed;
      treeMap[y][x] = seed > 0.55 && seed < 0.8;
      waterMap[y][x] = seed > 0.93;
      fogMap[y][x] = 0;
      pathMap[y][x] = false;
      if (seed > 0.88 && seed <= 0.93) walls.add(k(x, y));
    }
  }
  // Spawn enemies and castles in new chunks (not near home)
  const home = playerForts.find(f => f.isHome);
  const homeDist = home ? Math.abs(baseX + 8 - home.gx) + Math.abs(baseY + 8 - home.gy) : 999;
  if (homeDist > 20) {
    const regionDiff = 1 + Math.floor(homeDist / 15);
    // Enemy castle in ~30% of distant chunks
    if (noise(cx * 100, cy * 100) < 0.3) {
      const fx = baseX + 4 + Math.floor(noise(cx * 7, cy * 13) * 8);
      const fy = baseY + 4 + Math.floor(noise(cx * 13, cy * 7) * 8);
      if (!walls.has(k(fx, fy)) && !(waterMap[fy] && waterMap[fy][fx])) {
        forts.push({ x: fx, y: fy, str: 15 + regionDiff * 8 + Math.floor(noise(fx, fy) * regionDiff * 4), garrisoned: false });
        for (let dy2 = -1; dy2 <= 1; dy2++) {
          for (let dx2 = -1; dx2 <= 1; dx2++) {
            walls.delete(k(fx + dx2, fy + dy2));
            if (treeMap[fy + dy2]) treeMap[fy + dy2][fx + dx2] = false;
          }
        }
      }
    }
    // 3-6 enemies per chunk
    const eCount = 3 + Math.floor(noise(cx * 31, cy * 37) * 4);
    for (let i = 0; i < eCount; i++) {
      const ex = baseX + Math.floor(noise(cx * 51 + i, cy * 61 + i) * CHUNK_SIZE);
      const ey = baseY + Math.floor(noise(cx * 71 + i, cy * 81 + i) * CHUNK_SIZE);
      if (walls.has(k(ex, ey)) || (waterMap[ey] && waterMap[ey][ex])) continue;
      const type = pickEnemyType(regionDiff);
      const def = ENEMY_TYPES[type];
      enemies.push({ x: ex, y: ey, str: Math.ceil((4 + Math.floor(noise(ex, ey) * regionDiff * 4)) * def.strMul), type, patrol: 0, charged: false, arrowCooldown: 0, vx: ex, vy: ey });
    }
    // Chests
    if (noise(cx * 41, cy * 43) < 0.5) {
      const chx = baseX + Math.floor(noise(cx * 91, cy * 93) * CHUNK_SIZE);
      const chy = baseY + Math.floor(noise(cx * 97, cy * 99) * CHUNK_SIZE);
      if (!walls.has(k(chx, chy))) chests.push({ x: chx, y: chy, gold: 10 + Math.floor(noise(chx, chy) * 16) });
    }
    // Allies
    if (noise(cx * 53, cy * 57) < 0.25) {
      const ax = baseX + Math.floor(noise(cx * 61, cy * 67) * CHUNK_SIZE);
      const ay = baseY + Math.floor(noise(cx * 73, cy * 79) * CHUNK_SIZE);
      if (!walls.has(k(ax, ay))) {
        const pool = ['militia', 'militia', 'longbowmen', 'crossbowmen', 'menatarms', 'pikemen', 'healers', 'knights', 'firelancers', 'catapults', 'assassins'];
        const aType = pool[Math.floor(noise(ax, ay) * pool.length)];
        const count = aType === 'militia' ? 2 + Math.floor(noise(ax + 1, ay) * 4) : 1 + Math.floor(noise(ax, ay + 1) * 2);
        allies.push({ x: ax, y: ay, troopType: aType, count });
      }
    }
    // Mercenary camps
    if (noise(cx * 83, cy * 87) < 0.2) {
      const mx2 = baseX + Math.floor(noise(cx * 101, cy * 103) * CHUNK_SIZE);
      const my2 = baseY + Math.floor(noise(cx * 107, cy * 109) * CHUNK_SIZE);
      if (!walls.has(k(mx2, my2))) {
        const pool = ['militia', 'healers', 'firelancers', 'longbowmen', 'assassins', 'menatarms', 'pikemen', 'knights'];
        const mType = pool[Math.floor(noise(mx2, my2) * pool.length)];
        const mCount = 1 + Math.floor(noise(mx2 + 1, my2) * 2);
        const mCost = Math.ceil(TROOP_TYPES[mType].cost * mCount * 0.7);
        mercCamps.push({ x: mx2, y: my2, troopType: mType, count: mCount, cost: mCost });
      }
    }
    // Overworld engineers (smiths)
    if (noise(cx * 113, cy * 117) < 0.15) {
      const sx2 = baseX + Math.floor(noise(cx * 121, cy * 127) * CHUNK_SIZE);
      const sy2 = baseY + Math.floor(noise(cx * 131, cy * 137) * CHUNK_SIZE);
      if (!walls.has(k(sx2, sy2))) overworldEngineers.push({ x: sx2, y: sy2 });
    }
  }
  chunks[ckey] = { generated: true, cx, cy };
}

function expandMapIfNeeded(px, py) {
  const cx = Math.floor(px / CHUNK_SIZE);
  const cy = Math.floor(py / CHUNK_SIZE);
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      const ncx = cx + dx, ncy = cy + dy;
      if (ncx >= 0 && ncy >= 0 && ncx < MAX_CHUNKS && ncy < MAX_CHUNKS) {
        ensureChunk(ncx, ncy);
      }
    }
  }
}

// -----------------------------------------------
//  ENEMY TYPE PICKER
// -----------------------------------------------
function pickEnemyType(diff) {
  const d = diff || getDifficulty();
  const pool = ['bandit', 'bandit'];
  if (d >= 2) pool.push('raider', 'enemy_archer');
  if (d >= 3) pool.push('raider', 'war_elephant', 'dark_mage');
  if (d >= 4) pool.push('dragon_rider', 'war_elephant', 'enemy_archer');
  if (d >= 5) pool.push('dragon_rider', 'dragon_rider', 'war_elephant');
  return pool[randInt(0, pool.length - 1)];
}

// -----------------------------------------------
//  GAME INIT
// -----------------------------------------------
function newGame() {
  gold = 0; kills = 0; morale = 0;
  upgrades = { armorPiercing: 0, extendedMag: 0, reinforced: 0, explosiveRounds: 0 };
  recruitedEngineers = 0; engineerATKBonus = 0; engineerTimer = 0;
  playerForts = []; pendingAttacks = []; goldPerTurn = 0;
  fortMenuOpen = false; fortMenuIndex = -1;
  // Settlers state init
  resources = { wood: 30, stone: 20, iron: 0, gold: 0, meat: 5, crops: 10 };
  storageCap = { wood: 100, stone: 100, iron: 50, gold: 200, meat: 50, crops: 80 };
  population = 4; popCap = 4; idleWorkers = 4;
  buildings = []; nextBuildingId = 1;
  researched = {}; currentResearch = null;
  notifications = [];
  buildMode = false; buildSelected = null; buildGhost = null;
  chunks = {};

  const army = newArmy();
  addTroops(army, 'militia', 5);
  addTroops(army, 'menatarms', 3);
  if (!playerName) {
    showOverlay('CONQUERERS', 'Enter your name, Lord.', 'Start Game', () => {
      initWorld(army);
    }, true);
  } else {
    initWorld(army);
  }
}

function getDifficulty() { return Math.max(1, playerForts.length); }

function getRegionalDifficulty(gx, gy) {
  const home = playerForts.find(f => f.isHome);
  if (!home) return getDifficulty();
  const d = Math.abs(gx - home.gx) + Math.abs(gy - home.gy);
  return getDifficulty() + Math.floor(d / 15);
}

function initWorld(startArmy, isLoad) {
  // Center of map at chunk 8,8 = tile 128,128
  const startX = 128, startY = 128;
  player = { x: startX, y: startY, army: {}, lastDx: 1, lastDy: 0 };
  for (const t of TROOP_ORDER) player.army[t] = Array.isArray(startArmy[t]) ? startArmy[t].slice() : [];

  if (!isLoad) {
    enemies = []; forts = []; allies = []; chests = []; mercCamps = []; overworldEngineers = [];
    walls = new Set();
    grassMap = []; treeMap = []; waterMap = []; pathMap = []; fogMap = [];
    territoryMap = {};
  }
  scouted = false;
  particles = []; floatingTexts = [];
  if (!isLoad) turnCount = 0;

  ambientParticles = [];
  tensionTimer = 0;
  followerTrail = [];
  moveQueue = [];
  isAnimating = false;
  playerVisual = { x: player.x, y: player.y };
  followerVisuals = [];

  // Seed ambient particles
  for (let i = 0; i < 30; i++) {
    ambientParticles.push({
      x: Math.random() * W, y: Math.random() * (H - PANEL_H),
      vx: (Math.random() - 0.5) * 0.3, vy: -0.1 - Math.random() * 0.2,
      size: 1 + Math.random() * 1.5, alpha: 0.2 + Math.random() * 0.3,
      life: 200 + randInt(0, 200), maxLife: 400,
    });
  }

  if (!isLoad) {
    // Generate initial chunks around player
    expandMapIfNeeded(player.x, player.y);
    // Clear area around spawn
    for (let dy = -3; dy <= 3; dy++) {
      for (let dx = -3; dx <= 3; dx++) {
        const nx = startX + dx, ny = startY + dy;
        walls.delete(k(nx, ny));
        if (treeMap[ny]) treeMap[ny][nx] = false;
        if (waterMap[ny]) waterMap[ny][nx] = false;
        // Remove any enemies/forts from spawn area
        enemies = enemies.filter(e => !(e.x === nx && e.y === ny));
        forts = forts.filter(f => !(f.x === nx && f.y === ny));
      }
    }
    // Create home castle
    const garrison = newArmy();
    addTroops(garrison, 'militia', 3);
    playerForts.push({ gx: startX, gy: startY, garrison, walls: 0, turrets: 0, mines: 0, isHome: true });

    // Place starting buildings (1 house, 1 farm)
    buildings.push({ id: nextBuildingId++, type: 'house', gx: startX - 1, gy: startY - 1, level: 0, workers: 0, built: true, buildProgress: 0, buildTarget: 0, upgrading: false, hp: 10, maxHp: 10 });
    buildings.push({ id: nextBuildingId++, type: 'farm', gx: startX + 1, gy: startY - 1, level: 0, workers: 0, built: true, buildProgress: 0, buildTarget: 0, upgrading: false, hp: 10, maxHp: 10 });
    // Clear trees from building spots
    if (treeMap[startY - 1]) { treeMap[startY - 1][startX - 1] = false; treeMap[startY - 1][startX + 1] = false; }

    recalcTerritory();
  } else if (playerForts.length > 0) {
    const home = playerForts.find(f => f.isHome) || playerForts[0];
    if (home) { player.x = home.gx; player.y = home.gy; playerVisual = { x: home.gx, y: home.gy }; }
  }

  camX = player.x; camY = player.y;
  revealAround(player.x, player.y, 5);
  for (const pf of playerForts) revealAround(pf.gx, pf.gy, 3 + (pf.walls || 0));

  initEnemyVisuals();
  minimapDirty = true;
  gameMode = 'overworld';
  applyBuildingEffects();
  updateHUD();
  msg('Build your kingdom and conquer the realm!');
  draw();
}

function initEnemyVisuals() {
  for (const e of enemies) { e.vx = e.x; e.vy = e.y; }
}

// -----------------------------------------------
//  TERRITORY CALCULATION (sparse territoryMap)
// -----------------------------------------------
function recalcTerritory() {
  territoryMap = {};
  // BFS from player castles
  for (const pf of playerForts) {
    const maxR = 3 + (pf.walls || 0);
    const queue = [{ x: pf.gx, y: pf.gy, d: 0 }];
    const visited = new Set();
    visited.add(k(pf.gx, pf.gy));
    territoryMap[k(pf.gx, pf.gy)] = 'player';
    while (queue.length) {
      const c = queue.shift();
      if (c.d >= maxR) continue;
      for (const [dx, dy] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {
        const nx = c.x + dx, ny = c.y + dy;
        if (nx < 0 || ny < 0) continue;
        const nk = k(nx, ny);
        if (visited.has(nk)) continue;
        if (walls.has(nk) && !playerForts.some(f => f.gx === nx && f.gy === ny)) continue;
        if (waterMap[ny] && waterMap[ny][nx]) continue;
        visited.add(nk);
        territoryMap[nk] = 'player';
        queue.push({ x: nx, y: ny, d: c.d + 1 });
      }
    }
  }
  // BFS from enemy castles
  for (const ef of forts) {
    const maxR = 3;
    const queue = [{ x: ef.x, y: ef.y, d: 0 }];
    const visited = new Set();
    visited.add(k(ef.x, ef.y));
    if (!territoryMap[k(ef.x, ef.y)]) territoryMap[k(ef.x, ef.y)] = 'enemy';
    while (queue.length) {
      const c = queue.shift();
      if (c.d >= maxR) continue;
      for (const [dx, dy] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {
        const nx = c.x + dx, ny = c.y + dy;
        if (nx < 0 || ny < 0) continue;
        const nk = k(nx, ny);
        if (visited.has(nk)) continue;
        if (walls.has(nk)) continue;
        if (waterMap[ny] && waterMap[ny][nx]) continue;
        if (territoryMap[nk] === 'player') continue;
        visited.add(nk);
        territoryMap[nk] = 'enemy';
        queue.push({ x: nx, y: ny, d: c.d + 1 });
      }
    }
  }
  // Recalculate gold income from mines
  goldPerTurn = 0;
  for (const pf of playerForts) {
    if (pf.mines > 0) goldPerTurn += FORT_UPGRADE_DEFS.mines[pf.mines - 1].income;
  }
  minimapDirty = true;
}

// -----------------------------------------------
//  PARTICLE AND FLOATING TEXT SPAWN HELPERS
// -----------------------------------------------
function spawnParticles(x, y, color, count, speed) {
  for (let i = 0; i < count; i++) {
    particles.push({
      gx: x, gy: y,
      ox: (Math.random() - 0.5) * 10, oy: (Math.random() - 0.5) * 10,
      vx: (Math.random() - 0.5) * speed, vy: (Math.random() - 0.5) * speed - 1,
      life: 30 + randInt(0, 20), maxLife: 50, color, size: 2 + Math.random() * 3,
    });
  }
}

function spawnFloatingText(x, y, text, color) {
  floatingTexts.push({ gx: x, gy: y, oy: -20, text, color, life: 60 });
}

function notify(text, color) {
  notifications.push({ text, color: color || '#ccc', time: 120 });
  if (notifications.length > 5) notifications.shift();
}

// -----------------------------------------------
//  BUILDING EFFECT HELPERS (merged from settlers)
// -----------------------------------------------
function applyBuildingEffects() {
  let newPopCap = 4; // base from home castle
  let newStorageCap = { wood: 100, stone: 100, iron: 50, gold: 200, meat: 50, crops: 80 };
  let moraleBon = 0;
  for (const bld of buildings) {
    if (!bld.built) continue;
    const def = BUILDING_DEFS[bld.type];
    if (!def) continue;
    const lvl = def.levels[bld.level];
    if (lvl.popCap) newPopCap += lvl.popCap;
    if (lvl.storageCap) {
      for (const r of RESOURCES) newStorageCap[r] = (newStorageCap[r] || 0) + lvl.storageCap;
    }
    if (lvl.moraleBonus) moraleBon += lvl.moraleBonus;
  }
  popCap = newPopCap;
  storageCap = newStorageCap;
  // Cap resources to storage
  for (const r of RESOURCES) {
    if (resources[r] > storageCap[r]) resources[r] = storageCap[r];
  }
}

function getToolBonus() {
  let bonus = 0;
  for (const bld of buildings) {
    if (bld.type === 'blacksmith' && bld.built) {
      bonus += BUILDING_DEFS.blacksmith.levels[bld.level].toolBonus;
    }
  }
  return bonus;
}

function calcFoodProduction() {
  let food = 0;
  for (const bld of buildings) {
    if (!bld.built || bld.workers === 0) continue;
    const def = BUILDING_DEFS[bld.type];
    if (!def) continue;
    const lvl = def.levels[bld.level];
    if (lvl.production) {
      if (lvl.production.crops) food += lvl.production.crops;
      if (lvl.production.meat) food += lvl.production.meat;
    }
  }
  return food;
}
// ===============================================
//  PART 3: GAMEPLAY SYSTEMS
// ===============================================

// -----------------------------------------------
//  MAIN MOVEMENT FUNCTION (merged with settlers ticks)
// -----------------------------------------------
function tryMove(dx, dy) {
  if (gameMode !== 'overworld') return;
  if (isAnimating) return;

  const nx = player.x + dx;
  const ny = player.y + dy;

  // No COLS/ROWS bounds; just check non-negative
  if (nx < 0 || ny < 0) return;

  // Expand map / generate new chunks around destination
  expandMapIfNeeded(nx, ny);

  // Water check
  if (waterMap[ny] && waterMap[ny][nx]) { msg('Cannot cross water'); return; }
  // Wall check
  if (walls.has(k(nx, ny))) {
    // Check if it is an enemy castle wall
    if (!forts.some(f => f.x === nx && f.y === ny) && !playerForts.some(f => f.gx === nx && f.gy === ny)) {
      msg('A wall blocks the way');
      return;
    }
  }

  // ---- INTERACTIONS AT DESTINATION ----

  // Build mode: place building
  if (buildMode && buildSelected) {
    if (canBuild(buildSelected, nx, ny)) {
      placeBuilding(buildSelected, nx, ny);
      buildMode = false;
      buildSelected = null;
      msg('');
    } else {
      msg('Cannot build here');
    }
    return;
  }

  // --- Enemy encounter ---
  const eIdx = enemies.findIndex(e => e.x === nx && e.y === ny);
  if (eIdx !== -1) {
    enterBattle(enemies, eIdx, false);
    return;
  }

  // --- Enemy castle encounter ---
  const fIdx = forts.findIndex(f => f.x === nx && f.y === ny);
  if (fIdx !== -1) {
    enterBattle(forts, fIdx, true);
    return;
  }

  // --- Player castle ---
  const pfIdx = playerForts.findIndex(f => f.gx === nx && f.gy === ny);
  if (pfIdx !== -1) {
    showCastleMenu(pfIdx);
    // still move onto it
  }

  // --- Building click ---
  const bldIdx = buildings.findIndex(b => b.gx === nx && b.gy === ny);
  if (bldIdx !== -1) {
    showBuildingInfo(buildings[bldIdx].id);
  }

  // Update follower trail
  followerTrail.unshift({ x: player.x, y: player.y });
  if (followerTrail.length > 20) followerTrail.pop();

  // Move player
  player.lastDx = dx;
  player.lastDy = dy;
  player.x = nx;
  player.y = ny;

  // Smooth animation
  moveQueue.push({ x: nx, y: ny });

  turnCount++;

  // --- Ally pickup ---
  const aIdx = allies.findIndex(a => a.x === nx && a.y === ny);
  if (aIdx !== -1) {
    const ally = allies[aIdx];
    addTroops(player.army, ally.troopType, ally.count);
    spawnParticles(nx, ny, TROOP_TYPES[ally.troopType] ? TROOP_TYPES[ally.troopType].color : '#4fc3f7', 12, 3);
    spawnFloatingText(nx, ny, '+' + ally.count + ' ' + (TROOP_TYPES[ally.troopType] ? TROOP_TYPES[ally.troopType].name : ally.troopType), '#4fc3f7');
    msg('Recruited ' + ally.count + ' ' + (TROOP_TYPES[ally.troopType] ? TROOP_TYPES[ally.troopType].name : ally.troopType) + '!');
    allies.splice(aIdx, 1);
  }

  // --- Chest pickup ---
  const cIdx = chests.findIndex(c => c.x === nx && c.y === ny);
  if (cIdx !== -1) {
    const chest = chests[cIdx];
    gold += chest.gold;
    spawnParticles(nx, ny, '#ffd54f', 15, 4);
    spawnFloatingText(nx, ny, '+' + chest.gold + ' Gold', '#ffd54f');
    msg('Found a chest! +' + chest.gold + ' gold');
    chests.splice(cIdx, 1);
  }

  // --- Mercenary camp ---
  const mIdx = mercCamps.findIndex(m => m.x === nx && m.y === ny);
  if (mIdx !== -1) {
    const camp = mercCamps[mIdx];
    if (gold >= camp.cost) {
      showOverlay('MERCENARY CAMP', camp.count + ' ' + TROOP_TYPES[camp.troopType].name + ' for hire.\nCost: ' + camp.cost + ' gold\nYour gold: ' + gold, 'Hire', () => {
        if (gold >= camp.cost) {
          gold -= camp.cost;
          addTroops(player.army, camp.troopType, camp.count);
          spawnParticles(nx, ny, TROOP_TYPES[camp.troopType].color, 12, 3);
          spawnFloatingText(nx, ny, '+' + camp.count + ' ' + TROOP_TYPES[camp.troopType].name, '#ffd54f');
          msg('Hired ' + camp.count + ' ' + TROOP_TYPES[camp.troopType].name + '!');
          mercCamps.splice(mIdx, 1);
          updateHUD();
          draw();
        }
      });
    } else {
      msg('Not enough gold to hire mercenaries (' + camp.cost + 'g needed)');
    }
  }

  // --- Overworld smith pickup ---
  const sIdx = overworldEngineers.findIndex(s => s.x === nx && s.y === ny);
  if (sIdx !== -1) {
    recruitedEngineers++;
    engineerATKBonus += 2;
    spawnParticles(nx, ny, '#ff9800', 15, 4);
    spawnFloatingText(nx, ny, 'Smith Recruited!', '#ff9800');
    msg('Recruited a smith! +2 ATK bonus (total: ' + engineerATKBonus + ')');
    overworldEngineers.splice(sIdx, 1);
  }

  // ---- PER-TURN TICKS (settlers-merged) ----
  resourceTick();
  advanceConstruction();
  advanceResearch();
  if (turnCount % 5 === 0) populationGrowth();

  // ---- Gold mine income from castles ----
  if (goldPerTurn > 0 && turnCount % 3 === 0) {
    gold += goldPerTurn;
    spawnFloatingText(player.x, player.y, '+' + goldPerTurn + 'g', '#ffd54f');
  }

  // ---- Tension timer: spawns harder enemies near player ----
  tensionTimer++;
  if (tensionTimer >= 30) {
    tensionTimer = 0;
    const diff = getDifficulty();
    const type = pickEnemyType(diff);
    const def = ENEMY_TYPES[type];
    const spot = freeSpotNear(player.x, player.y, 12);
    if (spot) {
      const str = Math.ceil((6 + diff * 3) * def.strMul);
      enemies.push({ x: spot.x, y: spot.y, str, type, patrol: 0, charged: false, arrowCooldown: 0, vx: spot.x, vy: spot.y });
    }
  }

  // ---- Castle garrison decay / raider/bandit attacks ----
  for (const pf of playerForts) {
    if (turnCount % 20 === 0 && armyTotal(pf.garrison) > 0) {
      // Small garrison attrition from bandits
      const lost = Math.random() < 0.3 ? 1 : 0;
      if (lost > 0) loseTroops(pf.garrison, lost);
    }
  }

  // ---- Enemy reinforcements ----
  if (turnCount % 25 === 0) {
    for (const e of enemies) {
      if (e.str < 50) e.str += randInt(1, 3);
    }
    for (const f of forts) {
      if (f.str < 80) f.str += randInt(2, 5);
    }
  }

  // ---- Chest respawning ----
  if (turnCount % 40 === 0) {
    const spot = freeSpot();
    if (spot) {
      chests.push({ x: spot.x, y: spot.y, gold: 8 + randInt(0, 12 + getDifficulty() * 2) });
    }
  }

  // ---- Dark mage spawns trolls ----
  if (turnCount % 9 === 0) {
    for (const e of enemies) {
      if (e.type === 'dark_mage') {
        const spot = freeSpotNear(e.x, e.y, 3);
        if (spot) {
          const trollDef = ENEMY_TYPES['troll'];
          enemies.push({ x: spot.x, y: spot.y, str: Math.ceil(8 * trollDef.strMul), type: 'troll', patrol: 0, charged: false, arrowCooldown: 0, vx: spot.x, vy: spot.y });
        }
      }
    }
  }

  // ---- Enemy attacks on player castles ----
  checkEnemyAttacks();

  // ---- Fog, HUD, draw ----
  dimFog();
  updateHUD();
  draw();

  // ---- Victory milestone check ----
  if (forts.length === 0 && playerForts.length >= 5) {
    showOverlay('KINGDOM ESTABLISHED!', 'You have conquered all enemy castles and hold ' + playerForts.length + ' castles!\nYour kingdom thrives. You may continue expanding or declare victory.', 'Continue', () => {});
  }
}

// -----------------------------------------------
//  CHECK ENEMY ATTACKS ON PLAYER CASTLES
// -----------------------------------------------
function checkEnemyAttacks() {
  for (let fi = playerForts.length - 1; fi >= 0; fi--) {
    const pf = playerForts[fi];
    for (let ei = enemies.length - 1; ei >= 0; ei--) {
      const e = enemies[ei];
      const d = Math.abs(e.x - pf.gx) + Math.abs(e.y - pf.gy);
      if (d <= 2 && Math.random() < 0.15) {
        // Enemy attacks this castle
        const garrisonPwr = effectivePower(pf.garrison, e.str, e.type);
        const wallDef = pf.walls > 0 ? FORT_UPGRADE_DEFS.walls[pf.walls - 1].def : 0;
        const turretDmg = pf.turrets > 0 ? FORT_UPGRADE_DEFS.turrets[pf.turrets - 1].dmg : 0;
        const totalDef = garrisonPwr + wallDef + turretDmg;

        if (totalDef >= e.str) {
          // Defend success
          const losses = Math.max(1, Math.floor(e.str / (totalDef + 1) * armyTotal(pf.garrison)));
          loseTroops(pf.garrison, losses);
          notify('Castle defended! Lost ' + losses + ' troops', '#66bb6a');
          spawnParticles(pf.gx, pf.gy, '#66bb6a', 12, 3);
          enemies.splice(ei, 1);
          kills++;
        } else {
          // Choose: auto-defend or abandon
          if (player.x === pf.gx && player.y === pf.gy) {
            defendFort(fi, ei);
          } else if (armyTotal(pf.garrison) > 0) {
            // Auto-defend attempt
            const losses = Math.ceil(armyTotal(pf.garrison) * 0.6);
            loseTroops(pf.garrison, losses);
            const eDmg = Math.max(1, Math.floor(totalDef * 0.5));
            e.str -= eDmg;
            if (e.str <= 0) {
              enemies.splice(ei, 1);
              kills++;
              notify('Castle garrison fought off an attacker!', '#66bb6a');
            } else {
              notify('Castle under siege! Garrison weakened.', '#ff9800');
            }
          } else {
            abandonFort(fi, ei);
          }
        }
        break;
      }
    }
  }
}

// -----------------------------------------------
//  DEFEND CASTLE (player present)
// -----------------------------------------------
function defendFort(fortIdx, enemyIdx) {
  const pf = playerForts[fortIdx];
  const e = enemies[enemyIdx];
  const wallDef = pf.walls > 0 ? FORT_UPGRADE_DEFS.walls[pf.walls - 1].def : 0;
  const turretDmg = pf.turrets > 0 ? FORT_UPGRADE_DEFS.turrets[pf.turrets - 1].dmg : 0;

  // Combine player army + garrison for defense
  const combinedArmy = newArmy();
  for (const t of TROOP_ORDER) {
    if (Array.isArray(player.army[t])) {
      for (const u of player.army[t]) combinedArmy[t].push({ ...u });
    }
    if (Array.isArray(pf.garrison[t])) {
      for (const u of pf.garrison[t]) combinedArmy[t].push({ ...u });
    }
  }

  const totalPwr = effectivePower(combinedArmy, e.str, e.type) + wallDef + turretDmg;
  if (totalPwr >= e.str) {
    const losses = Math.max(1, Math.floor(e.str / (totalPwr + 1) * armyTotal(combinedArmy) * 0.3));
    loseTroops(player.army, Math.ceil(losses * 0.5));
    loseTroops(pf.garrison, Math.floor(losses * 0.5));
    enemies.splice(enemyIdx, 1);
    kills++;
    msg('Castle defended! Lost ' + losses + ' troops');
    spawnParticles(pf.gx, pf.gy, '#66bb6a', 15, 4);
    spawnFloatingText(pf.gx, pf.gy, 'Castle Defended!', '#66bb6a');
    notify('Castle successfully defended!', '#66bb6a');
  } else {
    const losses = Math.ceil(armyTotal(combinedArmy) * 0.5);
    loseTroops(player.army, Math.ceil(losses * 0.6));
    loseTroops(pf.garrison, Math.floor(losses * 0.4));
    e.str -= Math.floor(totalPwr * 0.4);
    if (e.str <= 0) {
      enemies.splice(enemyIdx, 1);
      kills++;
      notify('Attackers repelled, but heavy losses!', '#ff9800');
    } else {
      notify('Castle walls breached! Garrison damaged.', '#ef5350');
    }
  }
  updateHUD();
  draw();
}

// -----------------------------------------------
//  ABANDON CASTLE
// -----------------------------------------------
function abandonFort(fortIdx, enemyIdx) {
  const pf = playerForts[fortIdx];
  notify('Castle Abandoned at (' + pf.gx + ',' + pf.gy + ')!', '#ef5350');
  spawnParticles(pf.gx, pf.gy, '#ef5350', 20, 5);
  spawnFloatingText(pf.gx, pf.gy, 'Castle Abandoned!', '#ef5350');
  // Convert back to enemy castle
  forts.push({ x: pf.gx, y: pf.gy, str: enemies[enemyIdx].str, garrisoned: false });
  playerForts.splice(fortIdx, 1);
  enemies.splice(enemyIdx, 1);
  recalcTerritory();
  applyBuildingEffects();
  updateHUD();
  draw();
}

// enterBattle, combat, combatFort - defined in Part 5 (Battle System)

// -----------------------------------------------
//  SHOP FUNCTIONS
// -----------------------------------------------
function shopCost(type) {
  return TROOP_TYPES[type] ? TROOP_TYPES[type].cost : 10;
}

function shopBuy(type) {
  if (gameMode !== 'overworld') return;
  const def = TROOP_TYPES[type];
  if (!def) return;
  const cost = def.cost;
  const qty = def.qty || 1;
  if (gold < cost) { msg('Not enough gold (' + cost + 'g needed)'); return; }
  gold -= cost;
  addTroops(player.army, type, qty);
  spawnParticles(player.x, player.y, def.color, 10, 3);
  spawnFloatingText(player.x, player.y, '+' + qty + ' ' + def.name, def.color);
  msg('Recruited ' + qty + ' ' + def.name + '!');
  updateHUD();
  draw();
}

function shopScout() {
  if (gameMode !== 'overworld') return;
  if (gold < 15) { msg('Not enough gold (15g needed)'); return; }
  gold -= 15;
  scouted = true;
  revealAround(player.x, player.y, 15);
  spawnParticles(player.x, player.y, '#4fc3f7', 20, 5);
  msg('Scout reveals the area!');
  updateHUD();
  draw();
}

function healCost() { return 20; }

function shopHealAll() {
  if (gameMode !== 'overworld') return;
  const cost = healCost();
  if (gold < cost) { msg('Not enough gold (' + cost + 'g needed)'); return; }
  let healed = 0;
  for (const t of TROOP_ORDER) {
    if (Array.isArray(player.army[t])) {
      for (const u of player.army[t]) {
        if (u.hp < u.maxHp) { u.hp = u.maxHp; healed++; }
      }
    }
  }
  if (healed === 0) { msg('All troops already at full health'); return; }
  gold -= cost;
  spawnParticles(player.x, player.y, '#66bb6a', 15, 3);
  spawnFloatingText(player.x, player.y, 'Healed ' + healed + ' troops', '#66bb6a');
  msg('Healed ' + healed + ' troops!');
  updateHUD();
  draw();
}

function engineerBuy(upgradeKey) {
  if (gameMode !== 'overworld') return;
  const def = UPGRADE_DEFS[upgradeKey];
  if (!def) return;
  const lvl = upgrades[upgradeKey] || 0;
  if (lvl >= def.maxLvl) { msg(def.name + ' already max level'); return; }
  const cost = def.costs[lvl];
  if (gold < cost) { msg('Not enough gold (' + cost + 'g needed)'); return; }
  gold -= cost;
  upgrades[upgradeKey] = lvl + 1;
  spawnParticles(player.x, player.y, '#ff9800', 12, 3);
  spawnFloatingText(player.x, player.y, def.name + ' Lv' + (lvl + 1), '#ff9800');
  msg(def.name + ' upgraded to level ' + (lvl + 1) + '!');
  // Update blacksmith shop button text
  updateBlacksmithButtons();
  updateHUD();
  draw();
}

function updateBlacksmithButtons() {
  const shop = document.getElementById('blacksmith-shop');
  if (!shop) return;
  const btns = shop.querySelectorAll('button');
  const keys = ['armorPiercing', 'extendedMag', 'reinforced', 'explosiveRounds'];
  for (let i = 0; i < btns.length && i < keys.length; i++) {
    const key = keys[i];
    const def = UPGRADE_DEFS[key];
    const lvl = upgrades[key] || 0;
    if (lvl >= def.maxLvl) {
      btns[i].textContent = def.name + ' MAX';
      btns[i].disabled = true;
    } else {
      btns[i].textContent = def.name + ' Lv' + lvl + ' (' + def.costs[lvl] + 'g)';
    }
  }
}

// -----------------------------------------------
//  WIN / LOSE
// -----------------------------------------------
function checkGameWin() {
  if (playerForts.length >= 5 && forts.length === 0) {
    showOverlay('KINGDOM ESTABLISHED!',
      'All enemy castles conquered!\nYou hold ' + playerForts.length + ' castles.\nArmy Power: ' + armyPower(player.army) +
      '\nGold: ' + gold + '\nKills: ' + kills +
      '\n\nYour kingdom stretches across the realm.\nYou may continue expanding (sandbox) or declare victory.',
      'Declare Victory', () => {
        showOverlay('VICTORY!', 'Lord ' + (playerName || 'Unknown') + ' has united the realm!\n\nFinal Stats:\nCastles: ' + playerForts.length + '\nArmy: ' + armyPower(player.army) + '\nGold: ' + gold + '\nKills: ' + kills + '\nTurns: ' + turnCount, 'New Game', () => { newGame(); });
      });
  }
}

function gameOver() {
  showOverlay('DEFEAT', 'Lord ' + (playerName || 'Unknown') + ' has fallen!\n\nYour army was destroyed.\nKills: ' + kills + '\nTurns survived: ' + turnCount + '\nCastles held: ' + playerForts.length, 'Try Again', () => { newGame(); });
}

// -----------------------------------------------
//  OVERLAY FUNCTIONS
// -----------------------------------------------
let overlayCallback = null;

function showOverlay(title, message, btnText, callback, showInput) {
  document.getElementById('overlayTitle').textContent = title;
  document.getElementById('overlayTitle').style.color = '#f0c040';
  document.getElementById('overlayMsg').textContent = message;
  document.getElementById('overlayBtn').textContent = btnText || 'Continue';
  document.getElementById('overlayBtn').style.display = '';
  document.getElementById('overlayMsg').innerHTML = '';
  document.getElementById('overlayMsg').textContent = message;
  const input = document.getElementById('overlayInput');
  if (showInput) {
    input.style.display = '';
    input.value = playerName || '';
    input.focus();
  } else {
    input.style.display = 'none';
  }
  overlayCallback = callback;
  document.getElementById('overlay').classList.add('show');
}

function overlayAction() {
  const input = document.getElementById('overlayInput');
  if (input.style.display !== 'none') {
    playerName = input.value.trim() || 'Lord';
    input.style.display = 'none';
  }
  document.getElementById('overlay').classList.remove('show');
  document.getElementById('overlayMsg').innerHTML = '';
  document.getElementById('overlayBtn').style.display = '';
  if (overlayCallback) {
    const cb = overlayCallback;
    overlayCallback = null;
    cb();
  }
}

// -----------------------------------------------
//  CASTLE MENU (was showFortMenu)
// -----------------------------------------------
function showCastleMenu(idx) {
  if (idx < 0 || idx >= playerForts.length) return;
  fortMenuOpen = true;
  fortMenuIndex = idx;
  const pf = playerForts[idx];
  const isHome = pf.isHome;
  const title = isHome ? 'HOME CASTLE' : 'CASTLE #' + (idx + 1);

  let html = '<div style="text-align:center;font-family:sans-serif;max-width:450px">';
  html += '<h3 style="color:#f0c040;margin:0 0 8px">' + title + '</h3>';
  html += '<p style="color:#aaa;font-size:11px">Location: (' + pf.gx + ', ' + pf.gy + ')</p>';

  // Garrison info
  html += '<p style="color:#ccc;font-size:11px;margin:4px 0"><b>Garrison:</b> ' + armySummary(pf.garrison) + '</p>';
  html += '<p style="color:#aaa;font-size:10px">Garrison Power: ' + armyPower(pf.garrison) + '</p>';

  // Garrison transfer
  html += '<div style="margin:6px 0">';
  html += '<p style="color:#4fc3f7;font-size:11px;margin:2px 0">Transfer troops:</p>';
  for (const t of TROOP_ORDER) {
    const playerCount = armyCount(player.army, t);
    const garrisonCount = armyCount(pf.garrison, t);
    if (playerCount > 0 || garrisonCount > 0) {
      html += '<div style="font-size:10px;margin:2px 0;color:#ccc">';
      html += TROOP_TYPES[t].name + ': You=' + playerCount + ' Castle=' + garrisonCount + ' ';
      if (playerCount > 0) html += '<button onclick="garrisonTransfer(' + idx + ',\'' + t + '\',\'in\',1)" style="font-size:9px;padding:1px 4px">+1 In</button> ';
      if (garrisonCount > 0) html += '<button onclick="garrisonTransfer(' + idx + ',\'' + t + '\',\'out\',1)" style="font-size:9px;padding:1px 4px">+1 Out</button>';
      html += '</div>';
    }
  }
  html += '</div>';

  // Castle upgrades
  html += '<div style="margin:6px 0">';
  html += '<p style="color:#ff9800;font-size:11px;margin:2px 0">Upgrades:</p>';

  // Walls
  const wallLvl = pf.walls || 0;
  if (wallLvl < FORT_UPGRADE_DEFS.walls.length) {
    const wu = FORT_UPGRADE_DEFS.walls[wallLvl];
    html += '<button onclick="castleUpgrade(' + idx + ',\'walls\')" style="font-size:10px;padding:2px 6px;margin:2px">' + wu.name + ' (' + wu.cost + 'g) +' + wu.def + ' DEF</button> ';
  } else {
    html += '<span style="font-size:10px;color:#4caf50">Walls: MAX</span> ';
  }

  // Turrets
  const turretLvl = pf.turrets || 0;
  if (turretLvl < FORT_UPGRADE_DEFS.turrets.length) {
    const tu = FORT_UPGRADE_DEFS.turrets[turretLvl];
    html += '<button onclick="castleUpgrade(' + idx + ',\'turrets\')" style="font-size:10px;padding:2px 6px;margin:2px">' + tu.name + ' (' + tu.cost + 'g) +' + tu.dmg + ' DMG</button> ';
  } else {
    html += '<span style="font-size:10px;color:#4caf50">Turrets: MAX</span> ';
  }

  // Mines
  const mineLvl = pf.mines || 0;
  if (mineLvl < FORT_UPGRADE_DEFS.mines.length) {
    const mu = FORT_UPGRADE_DEFS.mines[mineLvl];
    html += '<button onclick="castleUpgrade(' + idx + ',\'mines\')" style="font-size:10px;padding:2px 6px;margin:2px">' + mu.name + ' (' + mu.cost + 'g) +' + mu.income + 'g/turn</button>';
  } else {
    html += '<span style="font-size:10px;color:#4caf50">Income: MAX</span>';
  }
  html += '</div>';

  // Current upgrades summary
  html += '<p style="font-size:9px;color:#778;margin:4px 0">';
  if (wallLvl > 0) html += 'Wall: ' + FORT_UPGRADE_DEFS.walls[wallLvl - 1].name + ' ';
  if (turretLvl > 0) html += 'Turret: ' + FORT_UPGRADE_DEFS.turrets[turretLvl - 1].name + ' ';
  if (mineLvl > 0) html += 'Income: ' + FORT_UPGRADE_DEFS.mines[mineLvl - 1].name;
  html += '</p>';

  html += '<button onclick="closeCastleMenu()" style="margin-top:6px;padding:4px 16px">Close</button>';
  html += '</div>';

  document.getElementById('overlayTitle').textContent = '';
  document.getElementById('overlayMsg').innerHTML = html;
  document.getElementById('overlayBtn').style.display = 'none';
  document.getElementById('overlayInput').style.display = 'none';
  document.getElementById('overlay').classList.add('show');
  overlayCallback = () => { document.getElementById('overlayBtn').style.display = ''; document.getElementById('overlayMsg').innerHTML = ''; fortMenuOpen = false; fortMenuIndex = -1; };
}

// -----------------------------------------------
//  TRY BUILD CASTLE (was tryBuildFort)
// -----------------------------------------------
function tryBuildCastle() {
  if (gameMode !== 'overworld') return;
  const px = player.x, py = player.y;

  // Check not on water or wall
  if (waterMap[py] && waterMap[py][px]) { msg('Cannot build a castle on water'); return; }
  // Check not on existing castle
  if (playerForts.some(f => f.gx === px && f.gy === py)) { msg('Already a castle here'); return; }
  if (forts.some(f => f.x === px && f.y === py)) { msg('Enemy castle here'); return; }

  // Cost: 100 gold + resources
  const goldCost = 100;
  const woodCost = 30;
  const stoneCost = 20;
  if (gold < goldCost) { msg('Need ' + goldCost + ' gold to build a castle'); return; }
  if ((resources.wood || 0) < woodCost) { msg('Need ' + woodCost + ' wood to build a castle'); return; }
  if ((resources.stone || 0) < stoneCost) { msg('Need ' + stoneCost + ' stone to build a castle'); return; }

  gold -= goldCost;
  resources.wood -= woodCost;
  resources.stone -= stoneCost;

  const garrison = newArmy();
  playerForts.push({ gx: px, gy: py, garrison, walls: 0, turrets: 0, mines: 0, isHome: false });

  // Clear trees around
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      if (treeMap[py + dy]) treeMap[py + dy][px + dx] = false;
      walls.delete(k(px + dx, py + dy));
    }
  }

  spawnParticles(px, py, '#f0c040', 20, 5);
  spawnFloatingText(px, py, 'Castle Built!', '#f0c040');
  msg('Castle built! Garrison troops and upgrade it.');
  notify('New castle built at (' + px + ',' + py + ')', '#f0c040');
  recalcTerritory();
  applyBuildingEffects();
  updateHUD();
  draw();
}

// -----------------------------------------------
//  CLOSE CASTLE MENU
// -----------------------------------------------
function closeCastleMenu() {
  fortMenuOpen = false;
  fortMenuIndex = -1;
  document.getElementById('overlay').classList.remove('show');
  document.getElementById('overlayBtn').style.display = '';
  document.getElementById('overlayMsg').innerHTML = '';
  updateHUD();
  draw();
}

// -----------------------------------------------
//  CASTLE UPGRADE (was fortUpgrade)
// -----------------------------------------------
function castleUpgrade(fortIdx, upgradeType) {
  if (fortIdx < 0 || fortIdx >= playerForts.length) return;
  const pf = playerForts[fortIdx];
  const lvl = pf[upgradeType] || 0;
  const defs = FORT_UPGRADE_DEFS[upgradeType];
  if (!defs || lvl >= defs.length) { msg('Already max level'); return; }
  const upgrade = defs[lvl];
  if (gold < upgrade.cost) { msg('Not enough gold (' + upgrade.cost + 'g needed)'); return; }
  gold -= upgrade.cost;
  pf[upgradeType] = lvl + 1;
  spawnParticles(pf.gx, pf.gy, '#ff9800', 12, 3);
  spawnFloatingText(pf.gx, pf.gy, upgrade.name + '!', '#ff9800');
  msg('Upgraded to ' + upgrade.name + '!');
  notify(upgrade.name + ' built!', '#ff9800');
  recalcTerritory();
  // Refresh menu
  showCastleMenu(fortIdx);
  updateHUD();
}

// -----------------------------------------------
//  GARRISON TRANSFER
// -----------------------------------------------
function garrisonTransfer(fortIdx, troopType, direction, count) {
  if (fortIdx < 0 || fortIdx >= playerForts.length) return;
  const pf = playerForts[fortIdx];
  if (direction === 'in') {
    // Player -> Castle garrison
    const available = armyCount(player.army, troopType);
    const toTransfer = Math.min(available, count);
    if (toTransfer <= 0) { msg('No ' + TROOP_TYPES[troopType].name + ' to transfer'); return; }
    // Move units
    for (let i = 0; i < toTransfer; i++) {
      if (Array.isArray(player.army[troopType]) && player.army[troopType].length > 0) {
        const unit = player.army[troopType].pop();
        if (!Array.isArray(pf.garrison[troopType])) pf.garrison[troopType] = [];
        pf.garrison[troopType].push(unit);
      }
    }
    msg('Garrisoned ' + toTransfer + ' ' + TROOP_TYPES[troopType].name);
  } else {
    // Castle garrison -> Player
    const available = armyCount(pf.garrison, troopType);
    const toTransfer = Math.min(available, count);
    if (toTransfer <= 0) { msg('No ' + TROOP_TYPES[troopType].name + ' in garrison'); return; }
    for (let i = 0; i < toTransfer; i++) {
      if (Array.isArray(pf.garrison[troopType]) && pf.garrison[troopType].length > 0) {
        const unit = pf.garrison[troopType].pop();
        if (!Array.isArray(player.army[troopType])) player.army[troopType] = [];
        player.army[troopType].push(unit);
      }
    }
    msg('Withdrew ' + toTransfer + ' ' + TROOP_TYPES[troopType].name);
  }
  // Refresh menu
  showCastleMenu(fortIdx);
  updateHUD();
}

// -----------------------------------------------
//  RESOURCE TICK (merged from settResourceTick)
// -----------------------------------------------
function resourceTick() {
  const toolBonus = getToolBonus();
  for (const bld of buildings) {
    if (!bld.built || bld.workers === 0) continue;
    const def = BUILDING_DEFS[bld.type];
    if (!def) continue;
    const lvl = def.levels[bld.level];
    if (lvl.production) {
      for (const [res, amt] of Object.entries(lvl.production)) {
        if (res === 'gold') continue; // gold handled separately by market
        const bonus = researched.improvedTools ? 0.25 : 0;
        const produced = Math.ceil(amt * (1 + bonus + toolBonus * 0.1));
        resources[res] = Math.min(storageCap[res], (resources[res] || 0) + produced);
      }
    }
    if (lvl.healRate && bld.type === 'hospital') {
      // Heal population morale
      if (morale < 10) morale = Math.min(10, morale + 1);
    }
  }
  // Food consumption: 1 crop or meat per 4 population
  const foodNeeded = Math.ceil(population / 4);
  let foodEaten = 0;
  if (resources.crops >= foodNeeded) {
    resources.crops -= foodNeeded;
    foodEaten = foodNeeded;
  } else if (resources.meat >= foodNeeded) {
    resources.meat -= foodNeeded;
    foodEaten = foodNeeded;
  } else {
    const fromCrops = Math.min(resources.crops, foodNeeded);
    resources.crops -= fromCrops;
    const remaining = foodNeeded - fromCrops;
    const fromMeat = Math.min(resources.meat, remaining);
    resources.meat -= fromMeat;
    foodEaten = fromCrops + fromMeat;
    if (foodEaten < foodNeeded) {
      notify('Your people are starving!', '#ef5350');
    }
  }
  // Market gold production
  for (const bld of buildings) {
    if (bld.type === 'market' && bld.built && bld.workers > 0) {
      const lvl = BUILDING_DEFS.market.levels[bld.level];
      if (lvl.production && lvl.production.gold) {
        gold += lvl.production.gold;
      }
    }
  }
}

// -----------------------------------------------
//  ADVANCE CONSTRUCTION (merged from settAdvanceConstruction)
// -----------------------------------------------
function advanceConstruction() {
  for (const bld of buildings) {
    if (bld.built && !bld.upgrading) continue;
    bld.buildProgress++;
    if (bld.buildProgress >= bld.buildTarget) {
      if (bld.upgrading) {
        bld.level++;
        bld.upgrading = false;
      }
      bld.built = true;
      bld.buildProgress = 0;
      bld.buildTarget = 0;
      notify(BUILDING_DEFS[bld.type].name + ' completed!', '#4caf50');
      applyBuildingEffects();
    }
  }
}

// -----------------------------------------------
//  ADVANCE RESEARCH (merged from settAdvanceResearch)
// -----------------------------------------------
function advanceResearch() {
  if (!currentResearch) return;
  let speed = 0.5; // base
  for (const bld of buildings) {
    if (bld.type === 'academy' && bld.built) {
      speed += BUILDING_DEFS.academy.levels[bld.level].researchSpeed;
    }
  }
  currentResearch.progress += speed;
  if (currentResearch.progress >= currentResearch.target) {
    researched[currentResearch.key] = true;
    notify('Research complete: ' + TECH_TREE[currentResearch.key].name, '#4fc3f7');
    currentResearch = null;
  }
}

// -----------------------------------------------
//  POPULATION GROWTH
// -----------------------------------------------
function populationGrowth() {
  if (population >= popCap) return;
  const food = calcFoodProduction();
  const foodNeeded = Math.ceil(population / 4);
  if (food > foodNeeded) {
    population = Math.min(popCap, population + 1);
    idleWorkers++;
    notify('+1 population (' + population + '/' + popCap + ')', '#66bb6a');
  }
}

// -----------------------------------------------
//  HARVEST (adjacent trees/rocks)
// -----------------------------------------------
function harvest() {
  if (gameMode !== 'overworld') return;
  const dirs = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
  let harvested = false;
  const toolBonus = getToolBonus();
  for (const [dx, dy] of dirs) {
    const hx = player.x + dx, hy = player.y + dy;
    if (hx < 0 || hy < 0) continue;
    if (treeMap[hy] && treeMap[hy][hx]) {
      const amt = 2 + toolBonus;
      resources.wood = Math.min(storageCap.wood, resources.wood + amt);
      treeMap[hy][hx] = false;
      spawnParticles(hx, hy, '#8d6e63', 8, 3);
      spawnFloatingText(hx, hy, '+' + amt + ' Wood', '#8d6e63');
      harvested = true;
      break;
    }
    if (walls.has(k(hx, hy)) && !(waterMap[hy] && waterMap[hy][hx]) && !playerForts.some(f => f.gx === hx && f.gy === hy) && !forts.some(f => f.x === hx && f.y === hy)) {
      const amt = 2 + toolBonus;
      resources.stone = Math.min(storageCap.stone, resources.stone + amt);
      if (Math.random() < 0.2) {
        resources.iron = Math.min(storageCap.iron, resources.iron + 1);
        spawnFloatingText(hx, hy, '+1 Iron!', '#78909c');
      }
      walls.delete(k(hx, hy));
      spawnParticles(hx, hy, '#90a4ae', 8, 3);
      spawnFloatingText(hx, hy, '+' + amt + ' Stone', '#90a4ae');
      harvested = true;
      break;
    }
  }
  if (!harvested) msg('Nothing to harvest nearby');
  else { updateHUD(); draw(); }
}

// -----------------------------------------------
//  BUILD MENU FUNCTIONS
// -----------------------------------------------
function toggleBuildMenu() {
  if (gameMode !== 'overworld') return;
  if (buildMode) { buildMode = false; buildSelected = null; msg(''); return; }
  // Show build overlay
  let html = '<div style="text-align:center;font-family:sans-serif;max-width:500px">';
  html += '<h3 style="color:#f0c040;margin:0 0 8px">BUILD</h3>';
  html += '<div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center">';
  for (const [type, def] of Object.entries(BUILDING_DEFS)) {
    const lvl = def.levels[0];
    const costStr = Object.entries(lvl.cost).map(([r,a]) => a + ' ' + RESOURCE_DEFS[r].icon).join(', ');
    const canAfford = Object.entries(lvl.cost).every(([r,a]) => {
      if (r === 'gold') return gold >= a;
      return (resources[r] || 0) >= a;
    });
    html += '<button onclick="selectBuild(\'' + type + '\')" style="padding:4px 8px;font-size:11px;opacity:' + (canAfford ? '1' : '0.4') + '">';
    html += def.name + '<br><span style="font-size:9px;color:#aaa">' + costStr + '</span>';
    if (def.requiresAdj) html += '<br><span style="font-size:8px;color:#ff9800">Needs adj. ' + def.requiresAdj + '</span>';
    html += '</button>';
  }
  html += '</div>';
  html += '<button onclick="document.getElementById(\'overlay\').classList.remove(\'show\');buildMode=false;buildSelected=null" style="margin-top:8px;padding:4px 16px">Close</button>';
  html += '</div>';
  document.getElementById('overlayTitle').textContent = '';
  document.getElementById('overlayMsg').innerHTML = html;
  document.getElementById('overlayBtn').style.display = 'none';
  document.getElementById('overlayInput').style.display = 'none';
  document.getElementById('overlay').classList.add('show');
  overlayCallback = () => { document.getElementById('overlayBtn').style.display = ''; document.getElementById('overlayMsg').innerHTML = ''; };
}

function selectBuild(type) {
  document.getElementById('overlay').classList.remove('show');
  document.getElementById('overlayBtn').style.display = '';
  document.getElementById('overlayMsg').innerHTML = '';
  buildMode = true;
  buildSelected = type;
  msg('Click to place ' + BUILDING_DEFS[type].name + ' (ESC to cancel)');
}

function canBuild(type, gx, gy) {
  if (gx < 0 || gy < 0) return false;
  if (walls.has(k(gx, gy))) return false;
  if (waterMap[gy] && waterMap[gy][gx]) return false;
  if (buildings.some(b => b.gx === gx && b.gy === gy)) return false;
  if (playerForts.some(f => f.gx === gx && f.gy === gy)) return false;
  if (forts.some(f => f.x === gx && f.y === gy)) return false;
  if (territoryMap[k(gx, gy)] !== 'player') return false;
  const def = BUILDING_DEFS[type];
  if (!def) return false;
  const lvl = def.levels[0];
  if (!Object.entries(lvl.cost).every(([r, a]) => {
    if (r === 'gold') return gold >= a;
    return (resources[r] || 0) >= a;
  })) return false;
  // Check adjacency requirements
  if (def.requiresAdj) {
    const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
    let found = false;
    for (const [dx2, dy2] of dirs) {
      const ax = gx + dx2, ay = gy + dy2;
      if (ax < 0 || ay < 0) continue;
      if (def.requiresAdj === 'tree' && treeMap[ay] && treeMap[ay][ax]) found = true;
      if (def.requiresAdj === 'wall' && walls.has(k(ax, ay))) found = true;
      if (def.requiresAdj === 'water' && waterMap[ay] && waterMap[ay][ax]) found = true;
    }
    if (!found) return false;
  }
  return true;
}

function placeBuilding(type, gx, gy) {
  const def = BUILDING_DEFS[type];
  const lvl = def.levels[0];
  for (const [r, a] of Object.entries(lvl.cost)) {
    if (r === 'gold') gold -= a;
    else resources[r] -= a;
  }
  buildings.push({
    id: nextBuildingId++, type, gx, gy, level: 0,
    workers: 0, built: false, buildProgress: 0, buildTarget: lvl.buildTime,
    upgrading: false, hp: 10, maxHp: 10
  });
  if (treeMap[gy]) treeMap[gy][gx] = false;
  walls.delete(k(gx, gy));
  spawnParticles(gx, gy, '#ffd54f', 10, 3);
  spawnFloatingText(gx, gy, 'Building ' + def.name, '#ffd54f');
  notify('Building ' + def.name + '...', '#ffd54f');
  applyBuildingEffects();
  recalcTerritory();
}

function canUpgrade(buildingId) {
  const bld = buildings.find(b => b.id === buildingId);
  if (!bld || !bld.built || bld.upgrading) return false;
  const def = BUILDING_DEFS[bld.type];
  if (bld.level >= def.levels.length - 1) return false;
  const nextLvl = def.levels[bld.level + 1];
  return Object.entries(nextLvl.cost).every(([r, a]) => {
    if (r === 'gold') return gold >= a;
    return (resources[r] || 0) >= a;
  });
}

function upgradeBuilding(buildingId) {
  const bld = buildings.find(b => b.id === buildingId);
  if (!canUpgrade(buildingId)) return;
  const def = BUILDING_DEFS[bld.type];
  const nextLvl = def.levels[bld.level + 1];
  for (const [r, a] of Object.entries(nextLvl.cost)) {
    if (r === 'gold') gold -= a;
    else resources[r] -= a;
  }
  bld.upgrading = true;
  bld.buildProgress = 0;
  bld.buildTarget = nextLvl.buildTime;
  notify('Upgrading ' + def.name + '...', '#4fc3f7');
}

function demolish(buildingId) {
  const idx = buildings.findIndex(b => b.id === buildingId);
  if (idx === -1) return;
  const bld = buildings[idx];
  const def = BUILDING_DEFS[bld.type];
  const lvl = def.levels[bld.level];
  // Refund 50%
  for (const [r, a] of Object.entries(lvl.cost)) {
    if (r === 'gold') {
      gold += Math.floor(a * 0.5);
    } else {
      resources[r] = Math.min(storageCap[r], (resources[r] || 0) + Math.floor(a * 0.5));
    }
  }
  // Return workers
  idleWorkers += bld.workers;
  buildings.splice(idx, 1);
  applyBuildingEffects();
  recalcTerritory();
  notify(def.name + ' demolished', '#ff9800');
}

function assignWorker(buildingId) {
  const bld = buildings.find(b => b.id === buildingId);
  if (!bld || !bld.built) return;
  const def = BUILDING_DEFS[bld.type];
  if (bld.workers >= def.workers) return;
  if (idleWorkers <= 0) return;
  bld.workers++;
  idleWorkers--;
}

function unassignWorker(buildingId) {
  const bld = buildings.find(b => b.id === buildingId);
  if (!bld || bld.workers <= 0) return;
  bld.workers--;
  idleWorkers++;
}

function recalcWorkers() {
  let totalAssigned = 0;
  for (const bld of buildings) totalAssigned += bld.workers;
  idleWorkers = Math.max(0, population - totalAssigned);
}

// -----------------------------------------------
//  BUILDING INFO OVERLAY
// -----------------------------------------------
function showBuildingInfo(buildingId) {
  const bld = buildings.find(b => b.id === buildingId);
  if (!bld) return;
  const def = BUILDING_DEFS[bld.type];
  const lvl = def.levels[bld.level];
  let html = '<div style="text-align:center;font-family:sans-serif;max-width:350px">';
  html += '<h3 style="color:#f0c040;margin:0 0 6px">' + def.name + ' (Lv ' + (bld.level + 1) + ')</h3>';
  if (!bld.built) {
    const status = bld.upgrading ? 'Upgrading' : 'Under construction';
    html += '<p style="color:#ffa726;font-size:11px">' + status + ': ' + bld.buildProgress + '/' + bld.buildTarget + '</p>';
  } else {
    if (lvl.production) {
      html += '<p style="color:#aaa;font-size:11px">Produces: ' + Object.entries(lvl.production).map(([r,a]) => a + ' ' + (RESOURCE_DEFS[r] ? RESOURCE_DEFS[r].name : r)).join(', ') + '/turn</p>';
    }
    if (lvl.popCap) {
      html += '<p style="color:#aaa;font-size:11px">Population capacity: +' + lvl.popCap + '</p>';
    }
    if (lvl.storageCap) {
      html += '<p style="color:#aaa;font-size:11px">Storage: +' + lvl.storageCap + ' all resources</p>';
    }
    if (lvl.visionRange) {
      html += '<p style="color:#aaa;font-size:11px">Vision range: ' + lvl.visionRange + '</p>';
    }
    if (lvl.healRate) {
      html += '<p style="color:#aaa;font-size:11px">Heal rate: ' + lvl.healRate + '/turn</p>';
    }
    if (lvl.researchSpeed) {
      html += '<p style="color:#aaa;font-size:11px">Research speed: +' + lvl.researchSpeed + '</p>';
    }
    if (lvl.moraleBonus) {
      html += '<p style="color:#aaa;font-size:11px">Morale bonus: +' + lvl.moraleBonus + '</p>';
    }
    if (lvl.toolBonus) {
      html += '<p style="color:#aaa;font-size:11px">Tool bonus: +' + lvl.toolBonus + '</p>';
    }
    if (lvl.tradeRatio) {
      html += '<p style="color:#aaa;font-size:11px">Trade ratio: ' + lvl.tradeRatio + ':1</p>';
    }
    if (def.workers > 0) {
      html += '<p style="color:#aaa;font-size:11px">Workers: ' + bld.workers + '/' + def.workers + ' (Idle: ' + idleWorkers + ')</p>';
      html += '<button onclick="assignWorker(' + bld.id + ');showBuildingInfo(' + bld.id + ')" style="font-size:10px;padding:2px 6px">+Worker</button> ';
      html += '<button onclick="unassignWorker(' + bld.id + ');showBuildingInfo(' + bld.id + ')" style="font-size:10px;padding:2px 6px">-Worker</button>';
    }
    if (canUpgrade(buildingId)) {
      const nextLvl = def.levels[bld.level + 1];
      const costStr = Object.entries(nextLvl.cost).map(([r,a]) => a + ' ' + (RESOURCE_DEFS[r] ? RESOURCE_DEFS[r].icon : r)).join(', ');
      html += '<br><button onclick="upgradeBuilding(' + bld.id + ');showBuildingInfo(' + bld.id + ')" style="font-size:10px;padding:3px 8px;margin-top:4px">Upgrade (' + costStr + ')</button>';
    } else if (bld.level < def.levels.length - 1) {
      const nextLvl = def.levels[bld.level + 1];
      const costStr = Object.entries(nextLvl.cost).map(([r,a]) => a + ' ' + (RESOURCE_DEFS[r] ? RESOURCE_DEFS[r].icon : r)).join(', ');
      html += '<br><span style="font-size:10px;color:#777;margin-top:4px">Next: ' + costStr + '</span>';
    } else {
      html += '<br><span style="font-size:10px;color:#4caf50;margin-top:4px">MAX LEVEL</span>';
    }
    html += '<br><button onclick="demolish(' + bld.id + ');document.getElementById(\'overlay\').classList.remove(\'show\')" style="font-size:10px;padding:2px 6px;margin-top:4px;color:#f44336">Demolish</button>';
  }
  html += '<br><button onclick="document.getElementById(\'overlay\').classList.remove(\'show\')" style="margin-top:6px;padding:4px 16px">Close</button>';
  html += '</div>';
  document.getElementById('overlayTitle').textContent = '';
  document.getElementById('overlayMsg').innerHTML = html;
  document.getElementById('overlayBtn').style.display = 'none';
  document.getElementById('overlayInput').style.display = 'none';
  document.getElementById('overlay').classList.add('show');
  overlayCallback = () => { document.getElementById('overlayBtn').style.display = ''; document.getElementById('overlayMsg').innerHTML = ''; };
}

// -----------------------------------------------
//  TRADE FUNCTIONS (market-based)
// -----------------------------------------------
function showTradeMenu() {
  if (gameMode !== 'overworld') return;
  // Find best market trade ratio
  let bestRatio = 5; // default without market
  for (const bld of buildings) {
    if (bld.type === 'market' && bld.built && bld.workers > 0) {
      const lvl = BUILDING_DEFS.market.levels[bld.level];
      if (lvl.tradeRatio && lvl.tradeRatio < bestRatio) bestRatio = lvl.tradeRatio;
    }
  }
  const hasMarket = buildings.some(b => b.type === 'market' && b.built && b.workers > 0);
  if (!hasMarket) { msg('Build and staff a Market to trade resources'); return; }

  let html = '<div style="text-align:center;font-family:sans-serif;max-width:450px">';
  html += '<h3 style="color:#f0c040;margin:0 0 8px">TRADE</h3>';
  html += '<p style="color:#aaa;font-size:10px">Trade ratio: ' + bestRatio + ':1 (sell ' + bestRatio + ' to get 1)</p>';
  html += '<div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center;margin-top:6px">';

  const tradeable = ['wood', 'stone', 'iron', 'crops', 'meat'];
  for (const from of tradeable) {
    for (const to of tradeable) {
      if (from === to) continue;
      const canTrade = (resources[from] || 0) >= bestRatio;
      html += '<button onclick="executeTrade(\'' + from + '\',\'' + to + '\',' + bestRatio + ')" style="font-size:9px;padding:2px 6px;opacity:' + (canTrade ? '1' : '0.3') + '">';
      html += bestRatio + ' ' + RESOURCE_DEFS[from].icon + ' -> 1 ' + RESOURCE_DEFS[to].icon;
      html += '</button>';
    }
  }
  // Sell resources for gold
  for (const from of tradeable) {
    const canSell = (resources[from] || 0) >= bestRatio;
    html += '<button onclick="executeTradeSellGold(\'' + from + '\',' + bestRatio + ')" style="font-size:9px;padding:2px 6px;opacity:' + (canSell ? '1' : '0.3') + ';color:#ffd54f">';
    html += bestRatio + ' ' + RESOURCE_DEFS[from].icon + ' -> 1 G';
    html += '</button>';
  }

  html += '</div>';
  html += '<button onclick="document.getElementById(\'overlay\').classList.remove(\'show\')" style="margin-top:8px;padding:4px 16px">Close</button>';
  html += '</div>';
  document.getElementById('overlayTitle').textContent = '';
  document.getElementById('overlayMsg').innerHTML = html;
  document.getElementById('overlayBtn').style.display = 'none';
  document.getElementById('overlayInput').style.display = 'none';
  document.getElementById('overlay').classList.add('show');
  overlayCallback = () => { document.getElementById('overlayBtn').style.display = ''; document.getElementById('overlayMsg').innerHTML = ''; };
}

function executeTrade(from, to, ratio) {
  if ((resources[from] || 0) < ratio) { msg('Not enough ' + RESOURCE_DEFS[from].name); return; }
  resources[from] -= ratio;
  resources[to] = Math.min(storageCap[to], (resources[to] || 0) + 1);
  spawnFloatingText(player.x, player.y, '-' + ratio + ' ' + RESOURCE_DEFS[from].icon + ' +1 ' + RESOURCE_DEFS[to].icon, '#ffd54f');
  showTradeMenu(); // Refresh
  updateHUD();
}

function executeTradeSellGold(from, ratio) {
  if ((resources[from] || 0) < ratio) { msg('Not enough ' + RESOURCE_DEFS[from].name); return; }
  resources[from] -= ratio;
  gold += 1;
  spawnFloatingText(player.x, player.y, '-' + ratio + ' ' + RESOURCE_DEFS[from].icon + ' +1 G', '#ffd54f');
  showTradeMenu(); // Refresh
  updateHUD();
}

// -----------------------------------------------
//  RESEARCH MENU
// -----------------------------------------------
function showResearchMenu() {
  if (gameMode !== 'overworld') return;
  let html = '<div style="text-align:center;font-family:sans-serif;max-width:400px">';
  html += '<h3 style="color:#4fc3f7;margin:0 0 8px">RESEARCH</h3>';

  // Check for academy
  const hasAcademy = buildings.some(b => b.type === 'academy' && b.built);
  if (!hasAcademy) {
    html += '<p style="color:#ff9800;font-size:11px">Build an Academy to research technologies!</p>';
  }

  if (currentResearch) {
    const tech = TECH_TREE[currentResearch.key];
    const pct = Math.floor((currentResearch.progress / currentResearch.target) * 100);
    html += '<p style="color:#ffa726;font-size:11px">Researching: ' + tech.name + ' (' + Math.floor(currentResearch.progress) + '/' + currentResearch.target + ') ' + pct + '%</p>';
  }

  for (const [key, tech] of Object.entries(TECH_TREE)) {
    if (researched[key]) {
      html += '<div style="margin:3px 0;font-size:11px;color:#4caf50">&#10003; ' + tech.name + ' - ' + tech.effect + '</div>';
      continue;
    }
    const reqs = tech.requires || [];
    const reqsMet = reqs.every(r => researched[r]);
    const costStr = Object.entries(tech.cost).map(([r,a]) => a + ' ' + (RESOURCE_DEFS[r] ? RESOURCE_DEFS[r].icon : r)).join(', ');
    const canAfford = Object.entries(tech.cost).every(([r,a]) => {
      if (r === 'gold') return gold >= a;
      return (resources[r] || 0) >= a;
    });
    const canStart = reqsMet && canAfford && !currentResearch && hasAcademy;
    html += '<div style="margin:3px 0;font-size:11px;opacity:' + (canStart ? '1' : '0.5') + '">';
    html += tech.name + ' (' + costStr + ', ' + tech.time + ' turns)';
    if (canStart) html += ' <button onclick="startResearch(\'' + key + '\');showResearchMenu()" style="font-size:9px;padding:1px 6px">Start</button>';
    if (!reqsMet && reqs.length > 0) html += ' <span style="color:#f44336;font-size:9px">Requires: ' + reqs.map(r => TECH_TREE[r].name).join(', ') + '</span>';
    html += '</div>';
  }
  html += '<button onclick="document.getElementById(\'overlay\').classList.remove(\'show\')" style="margin-top:8px;padding:4px 16px">Close</button>';
  html += '</div>';
  document.getElementById('overlayTitle').textContent = '';
  document.getElementById('overlayMsg').innerHTML = html;
  document.getElementById('overlayBtn').style.display = 'none';
  document.getElementById('overlayInput').style.display = 'none';
  document.getElementById('overlay').classList.add('show');
  overlayCallback = () => { document.getElementById('overlayBtn').style.display = ''; document.getElementById('overlayMsg').innerHTML = ''; };
}

function startResearch(techKey) {
  const tech = TECH_TREE[techKey];
  if (!tech || researched[techKey] || currentResearch) return;
  const reqs = tech.requires || [];
  if (!reqs.every(r => researched[r])) return;
  const hasAcademy = buildings.some(b => b.type === 'academy' && b.built);
  if (!hasAcademy) return;
  // Check and deduct cost
  for (const [r, a] of Object.entries(tech.cost)) {
    if (r === 'gold') {
      if (gold < a) return;
    } else {
      if ((resources[r] || 0) < a) return;
    }
  }
  for (const [r, a] of Object.entries(tech.cost)) {
    if (r === 'gold') gold -= a;
    else resources[r] -= a;
  }
  currentResearch = { key: techKey, progress: 0, target: tech.time };
  notify('Researching ' + tech.name + '...', '#4fc3f7');
}

// -----------------------------------------------
//  SETTLEMENT INFO OVERLAY
// -----------------------------------------------
function showSettlementInfo() {
  if (gameMode !== 'overworld') return;
  const food = calcFoodProduction();
  const foodNeeded = Math.ceil(population / 4);
  let html = '<div style="text-align:center;font-family:sans-serif;max-width:400px">';
  html += '<h3 style="color:#f0c040;margin:0 0 8px">KINGDOM OF ' + (playerName || 'Unknown').toUpperCase() + '</h3>';
  html += '<div style="font-size:11px;color:#ccc;text-align:left;padding:0 20px">';
  html += '<p>Population: ' + population + '/' + popCap + ' (Idle: ' + idleWorkers + ')</p>';
  html += '<p>Food: ' + food + '/turn (Need: ' + foodNeeded + ')</p>';
  html += '<p>Castles: ' + playerForts.length + ' | Buildings: ' + buildings.filter(b => b.built).length + '</p>';
  html += '<p>Army Power: ' + armyPower(player.army) + '</p>';
  html += '<p>Army: ' + armySummary(player.army) + '</p>';
  html += '<p>Gold Income: +' + goldPerTurn + '/turn</p>';
  html += '<p>Turn: ' + turnCount + ' | Kills: ' + kills + '</p>';
  for (const r of RESOURCES) {
    html += '<p style="color:' + RESOURCE_DEFS[r].color + '">' + RESOURCE_DEFS[r].name + ': ' + (resources[r] || 0) + '/' + storageCap[r] + '</p>';
  }
  // Research status
  if (currentResearch) {
    const tech = TECH_TREE[currentResearch.key];
    html += '<p style="color:#4fc3f7">Researching: ' + tech.name + ' (' + Math.floor(currentResearch.progress) + '/' + currentResearch.target + ')</p>';
  }
  // Building list
  if (buildings.length > 0) {
    html += '<p style="margin-top:6px;color:#ff9800"><b>Buildings:</b></p>';
    for (const bld of buildings) {
      const def = BUILDING_DEFS[bld.type];
      const status = bld.built ? (bld.upgrading ? 'Upgrading' : 'Active') : 'Building';
      html += '<p style="font-size:10px;color:#aaa">' + def.name + ' Lv' + (bld.level + 1) + ' [' + status + '] W:' + bld.workers + '/' + def.workers + '</p>';
    }
  }
  // Researched techs
  const researchedKeys = Object.keys(researched).filter(k => researched[k]);
  if (researchedKeys.length > 0) {
    html += '<p style="margin-top:6px;color:#4fc3f7"><b>Technologies:</b></p>';
    for (const rk of researchedKeys) {
      html += '<p style="font-size:10px;color:#4caf50">' + TECH_TREE[rk].name + '</p>';
    }
  }
  html += '</div>';
  html += '<div style="margin-top:6px;display:flex;gap:4px;justify-content:center">';
  html += '<button onclick="showTradeMenu()" style="padding:4px 12px;font-size:11px">Trade</button>';
  html += '<button onclick="document.getElementById(\'overlay\').classList.remove(\'show\')" style="padding:4px 16px">Close</button>';
  html += '</div>';
  html += '</div>';
  document.getElementById('overlayTitle').textContent = '';
  document.getElementById('overlayMsg').innerHTML = html;
  document.getElementById('overlayBtn').style.display = 'none';
  document.getElementById('overlayInput').style.display = 'none';
  document.getElementById('overlay').classList.add('show');
  overlayCallback = () => { document.getElementById('overlayBtn').style.display = ''; document.getElementById('overlayMsg').innerHTML = ''; };
}

// -----------------------------------------------
//  ENEMY AI STUBS (overworld enemies don't actively move)
// -----------------------------------------------
function moveEnemies() {
  // Enemies do not actively move on the overworld.
  // Their positions are static; tension timer spawns new threats.
}

function enemyArcherAttacks() {
  // Enemy archers do not attack on overworld; handled in tactical battle.
}

// -----------------------------------------------
//  SAVE / LOAD SYSTEM
// -----------------------------------------------
const SAVE_KEY = 'conquerers_saves';
const MAX_SLOTS = 5;

function getSaves() {
  try { return JSON.parse(localStorage.getItem(SAVE_KEY)) || {}; }
  catch { return {}; }
}

function saveGame(slot) {
  if (!player) return;
  const saves = getSaves();
  saves['slot' + slot] = {
    playerName,
    gold,
    kills,
    morale,
    turnCount,
    scouted,
    playerX: player.x,
    playerY: player.y,
    army: {},
    upgrades: { ...upgrades },
    recruitedEngineers,
    engineerATKBonus,
    playerForts: playerForts.map(f => ({
      gx: f.gx, gy: f.gy,
      garrison: (() => { const g = {}; for (const t of TROOP_ORDER) g[t] = Array.isArray(f.garrison[t]) ? f.garrison[t].map(u => ({ ...u })) : []; return g; })(),
      walls: f.walls, turrets: f.turrets, mines: f.mines, isHome: f.isHome
    })),
    goldPerTurn,
    enemies: enemies.map(e => ({ x: e.x, y: e.y, str: e.str, type: e.type, patrol: e.patrol, charged: e.charged })),
    forts: forts.map(f => ({ x: f.x, y: f.y, str: f.str, garrisoned: f.garrisoned || false })),
    allies: allies.slice(),
    chests: chests.slice(),
    mercCamps: mercCamps.slice(),
    overworldEngineers: overworldEngineers.slice(),
    walls: [...walls],
    // Settlers merged state
    resources: { ...resources },
    storageCap: { ...storageCap },
    population,
    popCap,
    idleWorkers,
    buildings: buildings.map(b => ({ ...b })),
    nextBuildingId,
    researched: { ...researched },
    currentResearch: currentResearch ? { ...currentResearch } : null,
    // Chunk data
    chunkKeys: Object.keys(chunks),
    grassMap: (() => {
      const out = {};
      for (const ck of Object.keys(chunks)) {
        const [cx, cy] = ck.split(',').map(Number);
        const baseX = cx * CHUNK_SIZE, baseY = cy * CHUNK_SIZE;
        for (let y = baseY; y < baseY + CHUNK_SIZE; y++) {
          for (let x = baseX; x < baseX + CHUNK_SIZE; x++) {
            if (grassMap[y] && grassMap[y][x] !== undefined) {
              if (!out[y]) out[y] = {};
              out[y][x] = grassMap[y][x];
            }
          }
        }
      }
      return out;
    })(),
    treeMap: (() => {
      const out = {};
      for (const ck of Object.keys(chunks)) {
        const [cx, cy] = ck.split(',').map(Number);
        const baseX = cx * CHUNK_SIZE, baseY = cy * CHUNK_SIZE;
        for (let y = baseY; y < baseY + CHUNK_SIZE; y++) {
          for (let x = baseX; x < baseX + CHUNK_SIZE; x++) {
            if (treeMap[y] && treeMap[y][x] !== undefined) {
              if (!out[y]) out[y] = {};
              out[y][x] = treeMap[y][x];
            }
          }
        }
      }
      return out;
    })(),
    waterMap: (() => {
      const out = {};
      for (const ck of Object.keys(chunks)) {
        const [cx, cy] = ck.split(',').map(Number);
        const baseX = cx * CHUNK_SIZE, baseY = cy * CHUNK_SIZE;
        for (let y = baseY; y < baseY + CHUNK_SIZE; y++) {
          for (let x = baseX; x < baseX + CHUNK_SIZE; x++) {
            if (waterMap[y] && waterMap[y][x] !== undefined) {
              if (!out[y]) out[y] = {};
              out[y][x] = waterMap[y][x];
            }
          }
        }
      }
      return out;
    })(),
    pathMap: (() => {
      const out = {};
      for (const ck of Object.keys(chunks)) {
        const [cx, cy] = ck.split(',').map(Number);
        const baseX = cx * CHUNK_SIZE, baseY = cy * CHUNK_SIZE;
        for (let y = baseY; y < baseY + CHUNK_SIZE; y++) {
          for (let x = baseX; x < baseX + CHUNK_SIZE; x++) {
            if (pathMap[y] && pathMap[y][x]) {
              if (!out[y]) out[y] = {};
              out[y][x] = pathMap[y][x];
            }
          }
        }
      }
      return out;
    })(),
    fogMap: (() => {
      const out = {};
      for (const ck of Object.keys(chunks)) {
        const [cx, cy] = ck.split(',').map(Number);
        const baseX = cx * CHUNK_SIZE, baseY = cy * CHUNK_SIZE;
        for (let y = baseY; y < baseY + CHUNK_SIZE; y++) {
          for (let x = baseX; x < baseX + CHUNK_SIZE; x++) {
            if (fogMap[y] && fogMap[y][x] !== undefined) {
              if (!out[y]) out[y] = {};
              out[y][x] = fogMap[y][x];
            }
          }
        }
      }
      return out;
    })(),
    timestamp: Date.now(),
  };
  // Save player army as arrays of unit objects
  for (const t of TROOP_ORDER) {
    saves['slot' + slot].army[t] = Array.isArray(player.army[t]) ? player.army[t].map(u => ({ ...u })) : [];
  }
  try {
    localStorage.setItem(SAVE_KEY, JSON.stringify(saves));
    msg('Game saved to slot ' + slot + '!');
    notify('Game saved!', '#4caf50');
  } catch (e) {
    msg('Save failed: storage full');
    notify('Save failed!', '#ef5350');
  }
}

function loadGame(slot) {
  const saves = getSaves();
  const data = saves['slot' + slot];
  if (!data) { msg('No save in slot ' + slot); return; }

  playerName = data.playerName || 'Lord';
  gold = data.gold || 0;
  kills = data.kills || 0;
  morale = data.morale || 0;
  turnCount = data.turnCount || 0;
  scouted = data.scouted || false;
  upgrades = data.upgrades || { armorPiercing: 0, extendedMag: 0, reinforced: 0, explosiveRounds: 0 };
  recruitedEngineers = data.recruitedEngineers || 0;
  engineerATKBonus = data.engineerATKBonus || 0;
  goldPerTurn = data.goldPerTurn || 0;

  // Restore walls
  walls = new Set(data.walls || []);

  // Restore map data from saved sparse objects
  grassMap = []; treeMap = []; waterMap = []; pathMap = []; fogMap = [];
  chunks = {};

  if (data.chunkKeys) {
    for (const ck of data.chunkKeys) {
      const [cx, cy] = ck.split(',').map(Number);
      chunks[ck] = { generated: true, cx, cy };
      const baseX = cx * CHUNK_SIZE, baseY = cy * CHUNK_SIZE;
      for (let y = baseY; y < baseY + CHUNK_SIZE; y++) {
        if (!grassMap[y]) grassMap[y] = [];
        if (!treeMap[y]) treeMap[y] = [];
        if (!waterMap[y]) waterMap[y] = [];
        if (!pathMap[y]) pathMap[y] = [];
        if (!fogMap[y]) fogMap[y] = [];
        for (let x = baseX; x < baseX + CHUNK_SIZE; x++) {
          grassMap[y][x] = (data.grassMap && data.grassMap[y] && data.grassMap[y][x] !== undefined) ? data.grassMap[y][x] : noise(x, y);
          treeMap[y][x] = (data.treeMap && data.treeMap[y] && data.treeMap[y][x] !== undefined) ? data.treeMap[y][x] : false;
          waterMap[y][x] = (data.waterMap && data.waterMap[y] && data.waterMap[y][x] !== undefined) ? data.waterMap[y][x] : false;
          pathMap[y][x] = (data.pathMap && data.pathMap[y] && data.pathMap[y][x]) ? data.pathMap[y][x] : false;
          fogMap[y][x] = (data.fogMap && data.fogMap[y] && data.fogMap[y][x] !== undefined) ? data.fogMap[y][x] : 0;
        }
      }
    }
  }

  // Restore entities
  enemies = (data.enemies || []).map(e => ({ ...e, arrowCooldown: 0, vx: e.x, vy: e.y }));
  forts = (data.forts || []).map(f => ({ ...f }));
  allies = (data.allies || []).slice();
  chests = (data.chests || []).slice();
  mercCamps = (data.mercCamps || []).slice();
  overworldEngineers = (data.overworldEngineers || []).slice();

  // Restore player castles with garrisons
  playerForts = (data.playerForts || []).map(f => {
    const garrison = newArmy();
    if (f.garrison) {
      for (const t of TROOP_ORDER) {
        if (Array.isArray(f.garrison[t])) {
          garrison[t] = f.garrison[t].map(u => ({ ...u }));
        }
      }
    }
    return { gx: f.gx, gy: f.gy, garrison, walls: f.walls || 0, turrets: f.turrets || 0, mines: f.mines || 0, isHome: f.isHome || false };
  });

  // Restore settlers state
  resources = data.resources || { wood: 30, stone: 20, iron: 0, gold: 0, meat: 5, crops: 10 };
  storageCap = data.storageCap || { wood: 100, stone: 100, iron: 50, gold: 200, meat: 50, crops: 80 };
  population = data.population || 4;
  popCap = data.popCap || 4;
  idleWorkers = data.idleWorkers || 4;
  buildings = (data.buildings || []).map(b => ({ ...b }));
  nextBuildingId = data.nextBuildingId || 1;
  researched = data.researched || {};
  currentResearch = data.currentResearch ? { ...data.currentResearch } : null;

  // Restore player army
  const army = newArmy();
  if (data.army) {
    for (const t of TROOP_ORDER) {
      if (Array.isArray(data.army[t])) {
        army[t] = data.army[t].map(u => ({ ...u }));
      }
    }
  }

  // Init world with loaded data (isLoad=true)
  initWorld(army, true);
  player.x = data.playerX || 128;
  player.y = data.playerY || 128;
  playerVisual = { x: player.x, y: player.y };
  camX = player.x;
  camY = player.y;

  initEnemyVisuals();
  recalcTerritory();
  applyBuildingEffects();
  dimFog();
  updateBlacksmithButtons();
  minimapDirty = true;
  msg('Game loaded from slot ' + slot + '!');
  notify('Game loaded!', '#4caf50');
  updateHUD();
  draw();
}

function deleteSave(slot) {
  const saves = getSaves();
  delete saves['slot' + slot];
  localStorage.setItem(SAVE_KEY, JSON.stringify(saves));
  showSaveLoadUI(); // Refresh UI
}

function autoSave() {
  saveGame(0);
}

function showSaveLoadUI() {
  const saves = getSaves();
  let html = '<div style="text-align:center;font-family:sans-serif;max-width:400px">';
  html += '<h3 style="color:#f0c040;margin:0 0 8px">SAVE / LOAD</h3>';

  for (let i = 0; i < MAX_SLOTS; i++) {
    const data = saves['slot' + i];
    const label = i === 0 ? 'Auto-Save' : 'Slot ' + i;
    html += '<div style="margin:4px 0;padding:4px;background:rgba(255,255,255,0.05);border-radius:4px">';
    if (data) {
      const date = new Date(data.timestamp);
      const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
      const castles = (data.playerForts || []).length;
      html += '<span style="font-size:11px;color:#ccc">' + label + ': ' + (data.playerName || 'Lord') + ' | Turn ' + (data.turnCount || 0) + ' | Castles: ' + castles + ' | ' + dateStr + '</span>';
      html += '<br>';
      html += '<button onclick="loadGame(' + i + ');document.getElementById(\'overlay\').classList.remove(\'show\')" style="font-size:10px;padding:2px 8px;margin:2px">Load</button>';
      if (i > 0) html += '<button onclick="saveGame(' + i + ');showSaveLoadUI()" style="font-size:10px;padding:2px 8px;margin:2px">Overwrite</button>';
      if (i > 0) html += '<button onclick="deleteSave(' + i + ')" style="font-size:10px;padding:2px 8px;margin:2px;color:#ef5350">Delete</button>';
    } else {
      html += '<span style="font-size:11px;color:#666">' + label + ': Empty</span>';
      if (i > 0) html += ' <button onclick="saveGame(' + i + ');showSaveLoadUI()" style="font-size:10px;padding:2px 8px;margin:2px">Save</button>';
    }
    html += '</div>';
  }

  html += '<button onclick="document.getElementById(\'overlay\').classList.remove(\'show\')" style="margin-top:8px;padding:4px 16px">Close</button>';
  html += '</div>';
  document.getElementById('overlayTitle').textContent = '';
  document.getElementById('overlayMsg').innerHTML = html;
  document.getElementById('overlayBtn').style.display = 'none';
  document.getElementById('overlayInput').style.display = 'none';
  document.getElementById('overlay').classList.add('show');
  overlayCallback = () => { document.getElementById('overlayBtn').style.display = ''; document.getElementById('overlayMsg').innerHTML = ''; };
}
// ===============================================
//  PART 4: ALL DRAWING FUNCTIONS (Medieval Theme)
// ===============================================

// -----------------------------------------------
//  SECTION 1: ISO HELPERS
// -----------------------------------------------
function drawIsoDiamond(sx, sy, fill) {
  ctx.fillStyle = fill;
  ctx.beginPath();
  ctx.moveTo(sx, sy - TILE_H / 2);
  ctx.lineTo(sx + TILE_W / 2, sy);
  ctx.lineTo(sx, sy + TILE_H / 2);
  ctx.lineTo(sx - TILE_W / 2, sy);
  ctx.closePath();
  ctx.fill();
}

function isoDiamondPath(sx, sy) {
  ctx.beginPath();
  ctx.moveTo(sx, sy - TILE_H / 2);
  ctx.lineTo(sx + TILE_W / 2, sy);
  ctx.lineTo(sx, sy + TILE_H / 2);
  ctx.lineTo(sx - TILE_W / 2, sy);
  ctx.closePath();
}

function drawIsoBox(sx, sy, h, topCol, leftCol, rightCol) {
  ctx.fillStyle = topCol;
  ctx.beginPath();
  ctx.moveTo(sx, sy - h - TILE_H / 2);
  ctx.lineTo(sx + TILE_W / 2, sy - h);
  ctx.lineTo(sx, sy - h + TILE_H / 2);
  ctx.lineTo(sx - TILE_W / 2, sy - h);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = leftCol;
  ctx.beginPath();
  ctx.moveTo(sx - TILE_W / 2, sy - h);
  ctx.lineTo(sx, sy - h + TILE_H / 2);
  ctx.lineTo(sx, sy + TILE_H / 2);
  ctx.lineTo(sx - TILE_W / 2, sy);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = rightCol;
  ctx.beginPath();
  ctx.moveTo(sx + TILE_W / 2, sy - h);
  ctx.lineTo(sx, sy - h + TILE_H / 2);
  ctx.lineTo(sx, sy + TILE_H / 2);
  ctx.lineTo(sx + TILE_W / 2, sy);
  ctx.closePath();
  ctx.fill();
}

// -----------------------------------------------
//  SECTION 2: MAIN DRAW FUNCTION
// -----------------------------------------------
function draw() {
  const sx = shake > 0.1 ? (Math.random() - 0.5) * shake : 0;
  const sy = shake > 0.1 ? (Math.random() - 0.5) * shake : 0;

  ctx.save();
  ctx.translate(sx, sy);

  ctx.fillStyle = '#0d1117';
  ctx.fillRect(0, 0, W, H);

  const panelTop = H - PANEL_H;
  const vr = getVisibleRange();

  // Build entity lookup maps for O(1) per-tile checks
  const _chestMap = new Map(), _allyMap = new Map(), _fortMap = new Map();
  const _enemyMap = new Map(), _mercMap = new Map(), _engMap = new Map();
  const _bldMap = new Map();
  for (const c of chests) _chestMap.set(k(c.x, c.y), c);
  for (const a of allies) _allyMap.set(k(a.x, a.y), a);
  for (const f of forts)  _fortMap.set(k(f.x, f.y), f);
  for (const e of enemies) _enemyMap.set(k(e.x, e.y), e);
  if (mercCamps) for (const m of mercCamps) _mercMap.set(k(m.x, m.y), m);
  if (overworldEngineers) for (const eg of overworldEngineers) _engMap.set(k(eg.x, eg.y), eg);
  const _pFortMap = new Map();
  for (const pf of playerForts) _pFortMap.set(k(pf.gx, pf.gy), pf);
  for (const b of buildings) _bldMap.set(k(b.gx, b.gy), b);

  const topTypes = getTopTroopTypes();
  const _followerMap = new Map();
  for (let fi = 0; fi < Math.min(topTypes.length, followerTrail.length); fi++) {
    const fpos = followerTrail[fi];
    if (!walls.has(k(fpos.x, fpos.y))) _followerMap.set(k(fpos.x, fpos.y), fi);
  }

  // Z-sorted render: iterate visible tiles in painter's algorithm order
  const minSum = vr.minX + vr.minY;
  const maxSum = vr.maxX + vr.maxY;
  for (let sum = minSum; sum <= maxSum; sum++) {
    for (let x = Math.max(vr.minX, sum - vr.maxY); x <= Math.min(vr.maxX, sum - vr.minY); x++) {
      const y = sum - x;
      if (y < 0 || x < 0) continue;
      // Infinite map: check sparse arrays exist
      if (!grassMap[y] || grassMap[y][x] === undefined) continue;

      const iso = toIso(x, y);
      if (iso.x < -TILE_W || iso.x > W + TILE_W || iso.y < -80 || iso.y > H) continue;
      const tKey = k(x, y);
      const fog = fogMap[y] ? fogMap[y][x] : 0;

      if (fog === 0) {
        drawFogTile(iso.x, iso.y, x, y);
        continue;
      }

      // Draw terrain
      if (waterMap[y] && waterMap[y][x]) drawWater(iso.x, iso.y, x, y);
      else if (walls.has(tKey)) drawWall(iso.x, iso.y, x, y);
      else {
        drawGround(iso.x, iso.y, grassMap[y][x], x, y);
        if (treeMap[y] && treeMap[y][x]) drawTree(iso.x, iso.y, x, y);
      }

      // fog=1: show static entities but dim
      if (fog === 1) {
        const fo = _fortMap.get(tKey); if (fo) drawCastle(iso.x, iso.y, fo.str);
        const pfo = _pFortMap.get(tKey); if (pfo) drawPlayerCastle(iso.x, iso.y, pfo);
        const ch = _chestMap.get(tKey); if (ch) drawChest(iso.x, iso.y, ch.gold);
        const bld = _bldMap.get(tKey); if (bld) drawBuilding(bld, iso.x, iso.y);
        ctx.fillStyle = 'rgba(8,12,18,0.45)';
        isoDiamondPath(iso.x, iso.y);
        ctx.fill();
        continue;
      }

      // fog=2: draw everything
      const bld = _bldMap.get(tKey); if (bld) drawBuilding(bld, iso.x, iso.y);
      const ch = _chestMap.get(tKey); if (ch) drawChest(iso.x, iso.y, ch.gold);
      const al = _allyMap.get(tKey);  if (al) drawVolunteer(al, iso.x, iso.y);
      const mc = _mercMap.get(tKey);  if (mc) drawSellswordCamp(mc, iso.x, iso.y);
      const eg = _engMap.get(tKey);   if (eg) drawWanderingSmith(eg, iso.x, iso.y);
      const fo = _fortMap.get(tKey);  if (fo) drawCastle(iso.x, iso.y, fo.str);
      const pfo = _pFortMap.get(tKey); if (pfo) drawPlayerCastle(iso.x, iso.y, pfo);

      const en = _enemyMap.get(tKey);
      if (en) {
        const eiso = toIso(en.vx !== undefined ? en.vx : en.x, en.vy !== undefined ? en.vy : en.y);
        drawEnemy(en, eiso.x, eiso.y);
      }

      // Followers
      const fli = _followerMap.get(tKey);
      if (fli !== undefined) {
        const fv = followerVisuals[fli] || followerTrail[fli];
        const fiso = toIso(fv.x, fv.y);
        drawFollowerAt(fiso.x, fiso.y, topTypes[fli], fli);
      }

      // Player
      if (player.x === x && player.y === y) {
        const piso = toIso(playerVisual.x, playerVisual.y);
        drawPlayer(piso.x, piso.y);
      }

      // Build ghost overlay
      if (buildMode && buildSelected && buildGhost && buildGhost.gx === x && buildGhost.gy === y) {
        ctx.globalAlpha = 0.5;
        drawBuildingByType(iso.x, iso.y, buildSelected, 0);
        ctx.globalAlpha = 1;
      }
    }
  }

  // Movement hints
  drawMovementHints();

  // Ambient particles
  updateAmbientParticles();
  updateParticles();
  updateFloatingTexts();

  // Dynamic lighting - warm glow from visible castles
  for (const f of forts) {
    const fiso = toIso(f.x, f.y);
    if (fiso.x < -100 || fiso.x > W + 100 || fiso.y < -100 || fiso.y > H + 100) continue;
    if (fogMap[f.y] && fogMap[f.y][f.x] < 2) continue;
    const flGrad = ctx.createRadialGradient(fiso.x, fiso.y, 10, fiso.x, fiso.y, 100);
    flGrad.addColorStop(0, 'rgba(255,160,60,0.06)');
    flGrad.addColorStop(0.5, 'rgba(255,120,40,0.03)');
    flGrad.addColorStop(1, 'rgba(255,100,30,0)');
    ctx.fillStyle = flGrad;
    ctx.fillRect(fiso.x - 100, fiso.y - 100, 200, 200);
  }
  for (const pf of playerForts) {
    const pfiso = toIso(pf.gx, pf.gy);
    if (pfiso.x < -100 || pfiso.x > W + 100 || pfiso.y < -100 || pfiso.y > H + 100) continue;
    const cGrad = ctx.createRadialGradient(pfiso.x, pfiso.y, 10, pfiso.x, pfiso.y, 80);
    cGrad.addColorStop(0, pf.isHome ? 'rgba(255,215,0,0.08)' : 'rgba(100,181,246,0.06)');
    cGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = cGrad;
    ctx.fillRect(pfiso.x - 80, pfiso.y - 80, 160, 160);
  }

  // Minimap
  drawMinimap();

  // Vignette overlay
  const mapCX = W / 2, mapCY = (H - PANEL_H) / 2;
  const vigGrad = ctx.createRadialGradient(mapCX, mapCY, W * 0.22, mapCX, mapCY, W * 0.65);
  vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
  vigGrad.addColorStop(0.7, 'rgba(0,0,0,0.15)');
  vigGrad.addColorStop(1, 'rgba(0,0,0,0.45)');
  ctx.fillStyle = vigGrad;
  ctx.fillRect(0, 0, W, panelTop);

  // Army panel at bottom
  drawArmyPanel();

  ctx.restore();
}

// -----------------------------------------------
//  SECTION 3: TERRAIN DRAWING (Enhanced Medieval)
// -----------------------------------------------
function drawFogTile(sx, sy, tx, ty) {
  const gv = grassMap[ty] ? grassMap[ty][tx] || 0 : 0;
  ctx.save();
  isoDiamondPath(sx, sy);
  ctx.clip();
  const fogGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, TILE_W * 0.4);
  fogGrad.addColorStop(0, 'rgb(' + Math.floor(12 + gv * 6) + ',' + Math.floor(14 + gv * 4) + ',' + Math.floor(22 + gv * 5) + ')');
  fogGrad.addColorStop(1, '#080c12');
  ctx.fillStyle = fogGrad;
  ctx.fillRect(sx - TILE_W / 2, sy - TILE_H / 2, TILE_W, TILE_H);
  if (gv > 0.9) {
    const twinkle = Math.sin(animFrame * 0.08 + tx * 5 + ty * 3) * 0.3 + 0.3;
    ctx.fillStyle = 'rgba(180,200,255,' + twinkle + ')';
    ctx.fillRect(sx - 10 + gv * 20, sy - 5 + gv * 8, 1, 1);
  }
  ctx.restore();
}

function drawGround(sx, sy, gv, tx, ty) {
  const isPath = pathMap[ty] && pathMap[ty][tx];
  const seed = (tx * 7 + ty * 13) % 100 / 100;

  if (isPath) {
    // Cobblestone path
    const r = Math.floor(lerp(50, 65, gv)), g = Math.floor(lerp(42, 52, gv)), b = Math.floor(lerp(28, 36, gv));
    ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
    isoDiamondPath(sx, sy);
    ctx.fill();
    // Cobblestone hints
    ctx.fillStyle = 'rgba(0,0,0,0.08)';
    for (let ci = 0; ci < 5; ci++) {
      const cx2 = sx - 10 + ((seed * 100 + ci * 17) % 20);
      const cy2 = sy - 4 + ((seed * 100 + ci * 23) % 8);
      ctx.fillRect(cx2, cy2, 3, 2);
    }
    ctx.fillStyle = 'rgba(255,255,255,0.04)';
    for (let ci = 0; ci < 3; ci++) {
      const cx2 = sx - 8 + ((seed * 80 + ci * 19) % 16);
      const cy2 = sy - 3 + ((seed * 60 + ci * 11) % 6);
      ctx.fillRect(cx2, cy2, 2, 1);
    }
  } else {
    // Rich medieval meadow ground
    const rShade = Math.floor(lerp(24, 38, gv));
    const gShade = Math.floor(lerp(42, 65, gv));
    const bShade = Math.floor(lerp(18, 32, gv));
    ctx.fillStyle = 'rgb(' + rShade + ',' + gShade + ',' + bShade + ')';
    isoDiamondPath(sx, sy);
    ctx.fill();

    // Noise-based color variation patches
    if (seed > 0.6) {
      ctx.fillStyle = 'rgba(40,60,20,0.15)';
      ctx.beginPath();
      ctx.ellipse(sx + (seed - 0.5) * 10, sy + (seed - 0.5) * 4, 6, 3, seed, 0, Math.PI * 2);
      ctx.fill();
    }

    // Dense grass blades (6-10 per tile)
    if (gv > 0.25) {
      const bladeCount = Math.floor(6 + gv * 4);
      for (let j = 0; j < bladeCount; j++) {
        const gx2 = sx - 14 + ((gv * 100 + j * 17) % 28);
        const gy2 = sy - 5 + ((gv * 100 + j * 11) % 10);
        const bh = 2 + gv * 2 + ((j * 7) % 3);
        const gc = Math.floor(55 + gv * 40 + ((j * 13) % 20));
        ctx.fillStyle = 'rgba(' + Math.floor(35 + (j * 5) % 20) + ',' + gc + ',' + Math.floor(25 + (j * 3) % 15) + ',0.5)';
        ctx.fillRect(gx2, gy2, 1, bh);
      }
    }

    // Dirt patches
    if (seed > 0.8) {
      ctx.fillStyle = 'rgba(60,45,25,0.15)';
      ctx.beginPath();
      ctx.ellipse(sx + 3, sy + 1, 4, 2, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // Small pebbles
    if (seed > 0.7 && seed < 0.85) {
      ctx.fillStyle = 'rgba(100,90,75,0.3)';
      ctx.fillRect(sx - 5, sy + 2, 2, 1);
      ctx.fillRect(sx + 4, sy - 1, 1, 1);
    }

    // Wildflowers
    if (gv > 0.7 && seed > 0.75) {
      const flowerColors = ['rgba(255,100,100,0.6)', 'rgba(255,255,100,0.6)', 'rgba(150,100,255,0.5)', 'rgba(255,180,50,0.5)'];
      const fc = flowerColors[Math.floor(seed * 4) % 4];
      ctx.fillStyle = fc;
      ctx.beginPath();
      ctx.arc(sx - 6 + seed * 12, sy - 2 + seed * 4, 1.2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Territory overlay (sparse map)
  if (territoryMap[k(tx, ty)]) {
    const owner = territoryMap[k(tx, ty)];
    ctx.fillStyle = owner === 'player' ? 'rgba(30,100,200,0.15)' : 'rgba(200,50,50,0.15)';
    isoDiamondPath(sx, sy);
    ctx.fill();
  }

  // Diamond outline
  ctx.strokeStyle = 'rgba(0,0,0,0.1)';
  ctx.lineWidth = 0.5;
  isoDiamondPath(sx, sy);
  ctx.stroke();
}

function drawWater(sx, sy, tx, ty) {
  const wave = Math.sin(animFrame * 0.05 + tx * 1.5 + ty * 0.8);

  // Dark ground beneath (transparency effect)
  ctx.fillStyle = 'rgb(10,25,40)';
  isoDiamondPath(sx, sy);
  ctx.fill();

  // Water surface with transparency
  const r = Math.floor(18 + wave * 5), g = Math.floor(55 + wave * 10), b = Math.floor(95 + wave * 15);
  ctx.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',0.85)';
  isoDiamondPath(sx, sy);
  ctx.fill();

  // Animated ripple rings
  const ripplePhase = (animFrame * 0.03 + tx * 2.1 + ty * 1.7) % (Math.PI * 2);
  const rippleR = 4 + Math.sin(ripplePhase) * 3;
  ctx.strokeStyle = 'rgba(120,200,255,' + (0.08 + Math.sin(ripplePhase) * 0.04) + ')';
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.ellipse(sx + Math.sin(tx * 3) * 4, sy + Math.cos(ty * 2) * 2, rippleR, rippleR * 0.4, 0, 0, Math.PI * 2);
  ctx.stroke();

  // Wave lines
  ctx.fillStyle = 'rgba(120,200,255,' + (0.12 + wave * 0.06) + ')';
  for (let i = -12; i < 12; i += 7) {
    const wy = sy - 2 + Math.sin(animFrame * 0.06 + (sx + i) * 0.12) * 2;
    ctx.fillRect(sx + i, wy, 3, 1);
  }

  // Reflective highlight sparkle
  const sparkle = Math.sin(animFrame * 0.15 + tx * 4 + ty * 3);
  if (sparkle > 0.7) {
    ctx.fillStyle = 'rgba(255,255,255,' + ((sparkle - 0.7) * 1.5) + ')';
    ctx.fillRect(sx - 3 + Math.sin(tx * 5) * 6, sy - 1 + Math.cos(ty * 4) * 2, 2, 1);
  }

  // Shore foam where water meets land
  for (const [dx2, dy2] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {
    const nx = tx + dx2, ny = ty + dy2;
    if (ny >= 0 && nx >= 0 && grassMap[ny] && grassMap[ny][nx] !== undefined && !(waterMap[ny] && waterMap[ny][nx])) {
      const foamX = sx + dx2 * 8 - dy2 * 8;
      const foamY = sy + dx2 * 4 + dy2 * 4;
      ctx.fillStyle = 'rgba(200,230,255,' + (0.15 + wave * 0.05) + ')';
      ctx.beginPath();
      ctx.ellipse(foamX, foamY, 5, 2, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Border
  ctx.strokeStyle = 'rgba(5,20,45,0.5)';
  ctx.lineWidth = 1.5;
  isoDiamondPath(sx, sy);
  ctx.stroke();
}

function drawWall(sx, sy, wx, wy) {
  const seed = (wx * 7 + wy * 13) % 100 / 100;
  const h = WALL_HEIGHT;
  const topCol = '#606878';
  const leftCol = '#4a5060';
  const rightCol = '#363c48';

  // 3D extruded wall box
  drawIsoBox(sx, sy, h, topCol, leftCol, rightCol);

  // Individual stone block mortar lines on left face
  ctx.strokeStyle = 'rgba(0,0,0,0.15)';
  ctx.lineWidth = 0.4;
  for (let row = 0; row < 3; row++) {
    const ry = sy - h + 4 + row * 6;
    ctx.beginPath();
    ctx.moveTo(sx - TILE_W * 0.34, ry);
    ctx.lineTo(sx - 1, ry + 3);
    ctx.stroke();
    // Vertical mortar
    for (let col = 0; col < 2; col++) {
      const mx = sx - TILE_W * 0.25 + col * 10;
      ctx.beginPath();
      ctx.moveTo(mx, ry - 3);
      ctx.lineTo(mx, ry + 3);
      ctx.stroke();
    }
  }

  // Moss/lichen patches
  if (seed > 0.6) {
    ctx.fillStyle = 'rgba(60,90,40,0.2)';
    ctx.beginPath();
    ctx.ellipse(sx - 8, sy - h + 8 + seed * 6, 3, 2, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Cracks/weathering
  if (seed > 0.75) {
    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
    ctx.lineWidth = 0.3;
    ctx.beginPath();
    ctx.moveTo(sx + 3, sy - h + 5);
    ctx.lineTo(sx + 5, sy - h + 10);
    ctx.lineTo(sx + 3, sy - h + 14);
    ctx.stroke();
  }

  // Ambient occlusion at base
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  isoDiamondPath(sx, sy);
  ctx.fill();
}

function drawTree(sx, sy, tx, ty) {
  const sway = Math.sin(animFrame * 0.03 + tx * 2.5 + ty * 1.3) * 1;
  const seed = ((tx * 7 + ty * 13) % 100) / 100;

  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath();
  ctx.ellipse(sx + 6, sy + 6, 12, 5, 0.3, 0, Math.PI * 2);
  ctx.fill();

  // Fallen leaves around base
  if (seed > 0.5) {
    const leafColors = ['rgba(120,80,20,0.25)', 'rgba(140,100,30,0.2)', 'rgba(80,60,15,0.2)'];
    for (let li = 0; li < 3; li++) {
      ctx.fillStyle = leafColors[li % 3];
      ctx.fillRect(sx - 8 + li * 6 + seed * 4, sy + 4 + li * 2, 2, 1);
    }
  }

  // Determine tree species by seed
  if (seed < 0.35) {
    // PINE - conical
    // Trunk
    ctx.fillStyle = '#4a3018';
    ctx.fillRect(sx - 1.5, sy - 14, 3, 16);
    ctx.fillStyle = '#3d2a15';
    ctx.fillRect(sx - 0.5, sy - 10, 1, 5);
    // Conical foliage layers
    const layers = [
      { y: -10, w: 14, h: 8, col: '#1a4210' },
      { y: -16, w: 11, h: 7, col: '#245a16' },
      { y: -21, w: 8, h: 6, col: '#307020' },
      { y: -25, w: 5, h: 4, col: '#3c8828' },
    ];
    for (const l of layers) {
      ctx.fillStyle = l.col;
      ctx.beginPath();
      ctx.moveTo(sx + sway, sy + l.y - l.h);
      ctx.lineTo(sx + l.w / 2 + sway * 0.5, sy + l.y);
      ctx.lineTo(sx - l.w / 2 + sway * 0.5, sy + l.y);
      ctx.closePath();
      ctx.fill();
    }
    // Snow cap hint
    ctx.fillStyle = 'rgba(200,220,200,0.15)';
    ctx.beginPath();
    ctx.moveTo(sx + sway, sy - 29);
    ctx.lineTo(sx + 3 + sway * 0.5, sy - 25);
    ctx.lineTo(sx - 3 + sway * 0.5, sy - 25);
    ctx.closePath();
    ctx.fill();
  } else if (seed < 0.55) {
    // BIRCH - white trunk, smaller canopy
    // Trunk (white with dark marks)
    ctx.fillStyle = '#d8d0c0';
    ctx.fillRect(sx - 1.5, sy - 18, 4, 20);
    ctx.fillStyle = '#b0a890';
    ctx.fillRect(sx - 1, sy - 16, 3, 17);
    // Birch bark marks
    ctx.fillStyle = '#555';
    ctx.fillRect(sx - 1, sy - 14, 2, 0.5);
    ctx.fillRect(sx - 0.5, sy - 10, 1.5, 0.5);
    ctx.fillRect(sx - 1, sy - 6, 2, 0.5);
    // Lighter, airy foliage
    ctx.fillStyle = '#3a8028';
    ctx.beginPath(); ctx.ellipse(sx + sway, sy - 18, 8, 6, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#4a9a30';
    ctx.beginPath(); ctx.ellipse(sx - 1 + sway, sy - 22, 7, 5, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#5ab038';
    ctx.beginPath(); ctx.ellipse(sx + 1 + sway, sy - 25, 5, 4, 0, 0, Math.PI * 2); ctx.fill();
    // Light dappling
    ctx.fillStyle = 'rgba(140,220,80,0.2)';
    ctx.beginPath(); ctx.ellipse(sx - 2 + sway, sy - 24, 3, 2, 0, 0, Math.PI * 2); ctx.fill();
  } else {
    // OAK - broad, round (default)
    // Trunk with bark lines/knots
    ctx.fillStyle = '#3d2a15';
    ctx.fillRect(sx - 2, sy - 16, 5, 18);
    ctx.fillStyle = '#5a3d20';
    ctx.fillRect(sx - 1, sy - 15, 3, 16);
    // Bark texture
    ctx.fillStyle = '#4a3018';
    ctx.fillRect(sx, sy - 12, 1, 4);
    ctx.fillRect(sx - 1, sy - 7, 1, 3);
    // Knot
    if (seed > 0.8) {
      ctx.fillStyle = '#2a1a08';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 1.2, 0, Math.PI * 2); ctx.fill();
    }
    // Visible roots at base
    ctx.fillStyle = '#3d2a15';
    ctx.beginPath();
    ctx.moveTo(sx - 2, sy + 1);
    ctx.lineTo(sx - 6, sy + 3);
    ctx.lineTo(sx - 5, sy + 2);
    ctx.lineTo(sx - 2, sy);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(sx + 3, sy + 1);
    ctx.lineTo(sx + 7, sy + 3);
    ctx.lineTo(sx + 6, sy + 2);
    ctx.lineTo(sx + 3, sy);
    ctx.fill();
    // Foliage layers (bottom to top)
    ctx.fillStyle = '#1a4210';
    ctx.beginPath(); ctx.ellipse(sx + sway, sy - 14, 12, 8, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#245a16';
    ctx.beginPath(); ctx.ellipse(sx - 1 + sway, sy - 18, 10, 7, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#307020';
    ctx.beginPath(); ctx.ellipse(sx + 1 + sway, sy - 22, 8, 6, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#3c8828';
    ctx.beginPath(); ctx.ellipse(sx + sway, sy - 25, 6, 4, 0, 0, Math.PI * 2); ctx.fill();
    // Light/dark gradient highlight
    ctx.fillStyle = 'rgba(100,180,60,0.3)';
    ctx.beginPath(); ctx.ellipse(sx - 2 + sway, sy - 25, 4, 3, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = 'rgba(140,210,80,0.2)';
    ctx.beginPath(); ctx.ellipse(sx - 3 + sway, sy - 26, 3, 2, 0, 0, Math.PI * 2); ctx.fill();
  }
}

// -----------------------------------------------
//  SECTION 4: MOVEMENT HINTS
// -----------------------------------------------
function drawMovementHints() {
  const hintPulse = 0.08 + Math.sin(animFrame * 0.08) * 0.05;
  for (const [dx, dy] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {
    const hx = player.x + dx, hy = player.y + dy;
    if (hx < 0 || hy < 0) continue;
    if (walls.has(k(hx, hy))) continue;
    const hiso = toIso(hx, hy);
    if (hiso.x < -TILE_W || hiso.x > W + TILE_W || hiso.y < -40 || hiso.y > H) continue;
    const hasEnemy = enemies.some(e => e.x === hx && e.y === hy);
    const hasFort = forts.some(f => f.x === hx && f.y === hy);
    const hasAlly = allies.some(a => a.x === hx && a.y === hy);
    const hasChest = chests.some(c => c.x === hx && c.y === hy);
    let hCol = '79,195,247';
    if (hasEnemy || hasFort) hCol = '255,100,100';
    else if (hasAlly) hCol = '100,255,100';
    else if (hasChest) hCol = '255,213,79';
    ctx.fillStyle = 'rgba(' + hCol + ',' + (hintPulse + 0.06) + ')';
    isoDiamondPath(hiso.x, hiso.y);
    ctx.fill();
    ctx.strokeStyle = 'rgba(' + hCol + ',' + (hintPulse + 0.1) + ')';
    ctx.lineWidth = 1.5;
    isoDiamondPath(hiso.x, hiso.y);
    ctx.stroke();
  }
}

// -----------------------------------------------
//  SECTION 5: ARMY PANEL
// -----------------------------------------------
function drawArmyPanel() {
  const panelY = H - PANEL_H;

  // Medieval panel background - dark wood/leather
  const panelGrad = ctx.createLinearGradient(0, panelY, 0, panelY + PANEL_H);
  panelGrad.addColorStop(0, '#2a1e14');
  panelGrad.addColorStop(0.3, '#221810');
  panelGrad.addColorStop(1, '#16100a');
  ctx.fillStyle = panelGrad;
  ctx.fillRect(0, panelY, W, PANEL_H);
  // Top emboss line (gold trim)
  ctx.fillStyle = '#6a5030';
  ctx.fillRect(0, panelY, W, 1);
  ctx.fillStyle = '#3a2818';
  ctx.fillRect(0, panelY + 1, W, 1);

  drawPanelRow(panelY + 3, TROOP_ORDER, 0);
}

function drawPanelRow(rowY, types, startIdx) {
  const slotW = W / types.length;
  for (let i = 0; i < types.length; i++) {
    const type = types[i];
    const def = TROOP_TYPES[type];
    const hpArr = Array.isArray(player.army[type]) ? player.army[type] : [];
    const count = hpArr.length;
    const sx = i * slotW;
    const cx = sx + slotW / 2;
    const cy = rowY + 16;

    if (count > 0) {
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      ctx.fillRect(sx + 2, rowY + 1, slotW - 4, 44);
    }

    drawMiniTroop(cx - 12, cy - 8, type, def);

    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = count > 0 ? def.color : '#334';
    ctx.fillText(count, cx + 10, cy - 1);

    ctx.font = '8px sans-serif';
    ctx.fillStyle = count > 0 ? '#aab' : '#334';
    ctx.fillText(def.name, cx, cy + 14);

    // Health bar
    if (count > 0) {
      const maxHp = BATTLE_STATS[type].hp + upgrades.reinforced * 3;
      const avgHp = hpArr.reduce((s, h) => s + (typeof h === 'object' ? h.hp : h), 0) / count;
      const hpFrac = avgHp / maxHp;
      const barW = slotW - 20, barH = 3;
      const barX = sx + 10, barY = cy + 20;
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      ctx.fillRect(barX, barY, barW, barH);
      ctx.fillStyle = hpFrac > 0.5 ? '#4caf50' : (hpFrac > 0.25 ? '#ff9800' : '#f44336');
      ctx.fillRect(barX, barY, barW * hpFrac, barH);
      ctx.font = '6px sans-serif';
      ctx.fillStyle = '#778';
      ctx.fillText(Math.round(avgHp) + '/' + maxHp, cx, barY + 10);
    }

    if (i < types.length - 1) {
      ctx.fillStyle = '#2a1a10';
      ctx.fillRect(sx + slotW - 1, rowY + 3, 1, 32);
    }
  }
}

// -----------------------------------------------
//  SECTION 6: MINIMAP
// -----------------------------------------------
function drawMinimap() {
  const mmX = W - MINIMAP_SIZE - 8, mmY = 8;

  if (minimapDirty) {
    mmCtx.fillStyle = '#0a0a1a';
    mmCtx.fillRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);

    // Determine bounds from loaded chunks
    const chunkKeys = Object.keys(chunks);
    if (chunkKeys.length === 0) { minimapDirty = false; return; }
    let minCX = Infinity, maxCX = -Infinity, minCY = Infinity, maxCY = -Infinity;
    for (const ck of chunkKeys) {
      const c = chunks[ck];
      minCX = Math.min(minCX, c.cx); maxCX = Math.max(maxCX, c.cx);
      minCY = Math.min(minCY, c.cy); maxCY = Math.max(maxCY, c.cy);
    }
    const tilesW = (maxCX - minCX + 1) * CHUNK_SIZE;
    const tilesH = (maxCY - minCY + 1) * CHUNK_SIZE;
    const scale = Math.min(MINIMAP_SIZE / tilesW, MINIMAP_SIZE / tilesH);
    const offX = minCX * CHUNK_SIZE;
    const offY = minCY * CHUNK_SIZE;

    for (let y = offY; y < offY + tilesH; y++) {
      if (!fogMap[y]) continue;
      for (let x = offX; x < offX + tilesW; x++) {
        if (fogMap[y][x] === undefined || fogMap[y][x] === 0) continue;
        const fog = fogMap[y][x];
        const px = (x - offX) * scale, py = (y - offY) * scale;
        if (waterMap[y] && waterMap[y][x]) {
          mmCtx.fillStyle = fog === 2 ? '#1a3050' : '#101828';
        } else if (walls.has(k(x, y))) {
          mmCtx.fillStyle = fog === 2 ? '#2a2a3a' : '#1a1a24';
        } else {
          mmCtx.fillStyle = fog === 2 ? '#1a2e18' : '#101a10';
        }
        mmCtx.fillRect(px, py, Math.max(1, Math.ceil(scale)), Math.max(1, Math.ceil(scale)));
        // Territory colors (sparse map)
        const tOwner = territoryMap[k(x, y)];
        if (tOwner) {
          mmCtx.fillStyle = tOwner === 'player' ? 'rgba(30,100,200,0.3)' : 'rgba(200,50,50,0.3)';
          mmCtx.fillRect(px, py, Math.max(1, Math.ceil(scale)), Math.max(1, Math.ceil(scale)));
        }
      }
    }

    // Enemy castles (red dots)
    for (const f of forts) {
      if (fogMap[f.y] && fogMap[f.y][f.x] > 0) {
        mmCtx.fillStyle = '#ff4444';
        mmCtx.fillRect((f.x - offX) * scale - 1, (f.y - offY) * scale - 1, 3, 3);
      }
    }
    // Player castles (blue/gold dots)
    for (const pf of playerForts) {
      mmCtx.fillStyle = pf.isHome ? '#ffd54f' : '#4fc3f7';
      mmCtx.fillRect((pf.gx - offX) * scale - 1, (pf.gy - offY) * scale - 1, 3, 3);
    }
    // Buildings (gold dots)
    for (const b of buildings) {
      mmCtx.fillStyle = b.built ? '#ffd54f' : '#ff9800';
      mmCtx.fillRect((b.gx - offX) * scale - 1, (b.gy - offY) * scale - 1, 2, 2);
    }
    minimapDirty = false;
  }

  // Medieval parchment frame border
  ctx.fillStyle = '#2a1e14';
  ctx.fillRect(mmX - 4, mmY - 4, MINIMAP_SIZE + 8, MINIMAP_SIZE + 8);
  ctx.fillStyle = '#1a1208';
  ctx.fillRect(mmX - 2, mmY - 2, MINIMAP_SIZE + 4, MINIMAP_SIZE + 4);

  // Draw cached minimap
  ctx.drawImage(minimapCanvas, mmX, mmY);

  // Dynamic: player (blinking white dot)
  const blink = Math.sin(animFrame * 0.15) > 0;
  if (blink) {
    // Calculate scale for player dot
    const chunkKeys2 = Object.keys(chunks);
    if (chunkKeys2.length > 0) {
      let minCX2 = Infinity, maxCX2 = -Infinity, minCY2 = Infinity, maxCY2 = -Infinity;
      for (const ck of chunkKeys2) {
        const c = chunks[ck];
        minCX2 = Math.min(minCX2, c.cx); maxCX2 = Math.max(maxCX2, c.cx);
        minCY2 = Math.min(minCY2, c.cy); maxCY2 = Math.max(maxCY2, c.cy);
      }
      const tw2 = (maxCX2 - minCX2 + 1) * CHUNK_SIZE;
      const th2 = (maxCY2 - minCY2 + 1) * CHUNK_SIZE;
      const sc2 = Math.min(MINIMAP_SIZE / tw2, MINIMAP_SIZE / th2);
      const ox2 = minCX2 * CHUNK_SIZE;
      const oy2 = minCY2 * CHUNK_SIZE;
      ctx.fillStyle = '#fff';
      ctx.fillRect(mmX + (player.x - ox2) * sc2 - 1, mmY + (player.y - oy2) * sc2 - 1, 3, 3);
    }
  }

  // Viewport rectangle
  const vr = getVisibleRange();
  const chunkKeys3 = Object.keys(chunks);
  if (chunkKeys3.length > 0) {
    let minCX3 = Infinity, maxCX3 = -Infinity, minCY3 = Infinity, maxCY3 = -Infinity;
    for (const ck of chunkKeys3) {
      const c = chunks[ck];
      minCX3 = Math.min(minCX3, c.cx); maxCX3 = Math.max(maxCX3, c.cx);
      minCY3 = Math.min(minCY3, c.cy); maxCY3 = Math.max(maxCY3, c.cy);
    }
    const tw3 = (maxCX3 - minCX3 + 1) * CHUNK_SIZE;
    const th3 = (maxCY3 - minCY3 + 1) * CHUNK_SIZE;
    const sc3 = Math.min(MINIMAP_SIZE / tw3, MINIMAP_SIZE / th3);
    const ox3 = minCX3 * CHUNK_SIZE;
    const oy3 = minCY3 * CHUNK_SIZE;
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 1;
    ctx.strokeRect(
      mmX + (vr.minX - ox3) * sc3,
      mmY + (vr.minY - oy3) * sc3,
      (vr.maxX - vr.minX) * sc3,
      (vr.maxY - vr.minY) * sc3
    );
  }

  // Ornate border
  ctx.strokeStyle = '#6a5030';
  ctx.lineWidth = 2;
  ctx.strokeRect(mmX - 4, mmY - 4, MINIMAP_SIZE + 8, MINIMAP_SIZE + 8);
  ctx.strokeStyle = '#3a2818';
  ctx.lineWidth = 1;
  ctx.strokeRect(mmX - 2, mmY - 2, MINIMAP_SIZE + 4, MINIMAP_SIZE + 4);
  // Corner decorations
  const corners = [[mmX - 4, mmY - 4], [mmX + MINIMAP_SIZE + 2, mmY - 4], [mmX - 4, mmY + MINIMAP_SIZE + 2], [mmX + MINIMAP_SIZE + 2, mmY + MINIMAP_SIZE + 2]];
  ctx.fillStyle = '#8a6830';
  for (const [cx2, cy2] of corners) {
    ctx.beginPath(); ctx.arc(cx2, cy2, 3, 0, Math.PI * 2); ctx.fill();
  }
}

// -----------------------------------------------
//  SECTION 7: MINI TROOP SPRITES (Medieval)
// -----------------------------------------------
function drawMiniTroop(x, y, type, def) {
  ctx.fillStyle = def.color;
  switch (type) {
    case 'militia':
      // Leather armor body + sword
      ctx.fillRect(x + 3, y + 2, 6, 8);
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(x + 6, y, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#6d4c41'; ctx.fillRect(x + 3, y - 3, 6, 2); // leather helm
      // Sword
      ctx.fillStyle = '#aaa'; ctx.fillRect(x + 9, y + 1, 5, 1.5);
      ctx.fillStyle = '#8a6830'; ctx.fillRect(x + 8, y, 1.5, 3); // guard
      break;
    case 'longbowmen':
      // Green cloak body + longbow
      ctx.fillRect(x + 3, y + 2, 6, 8);
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(x + 6, y, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = def.dark; ctx.fillRect(x + 2, y - 3, 8, 2); // hood
      // Longbow (curved arc)
      ctx.strokeStyle = '#6d4c41'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(x + 12, y + 2, 5, -Math.PI * 0.7, Math.PI * 0.7); ctx.stroke();
      // Bowstring
      ctx.strokeStyle = '#aaa'; ctx.lineWidth = 0.5;
      ctx.beginPath(); ctx.moveTo(x + 9, y - 3); ctx.lineTo(x + 9, y + 7); ctx.stroke();
      break;
    case 'crossbowmen':
      // Heavier armor + crossbow
      ctx.fillRect(x + 2, y + 2, 8, 8);
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(x + 6, y, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#555'; ctx.fillRect(x + 2, y - 4, 8, 3); // steel helm
      // Crossbow
      ctx.fillStyle = '#5d4037'; ctx.fillRect(x + 9, y, 6, 2); // stock
      ctx.fillStyle = '#666'; ctx.fillRect(x + 11, y - 2, 1, 5); // prod
      break;
    case 'menatarms':
      // Chainmail body + shield + mace
      ctx.fillRect(x + 2, y + 1, 8, 9);
      ctx.fillStyle = '#888'; ctx.fillRect(x + 3, y + 2, 6, 4); // chainmail
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(x + 6, y - 1, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#444'; ctx.fillRect(x + 2, y - 5, 8, 3); // great helm
      // Tower shield
      ctx.fillStyle = '#1565c0'; ctx.fillRect(x - 1, y, 3, 7);
      ctx.fillStyle = '#ffd54f'; ctx.fillRect(x, y + 2, 1, 3);
      // Mace
      ctx.fillStyle = '#555'; ctx.fillRect(x + 10, y - 2, 1.5, 5);
      ctx.fillStyle = '#777'; ctx.beginPath(); ctx.arc(x + 11, y - 3, 2, 0, Math.PI * 2); ctx.fill();
      break;
    case 'pikemen':
      // Light armor + long pike
      ctx.fillRect(x + 3, y + 2, 6, 8);
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(x + 6, y, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = def.dark; ctx.fillRect(x + 3, y - 4, 6, 3); // kettle helm
      // Long pike (extends up)
      ctx.fillStyle = '#5d4037'; ctx.fillRect(x + 7, y - 12, 1.5, 16);
      ctx.fillStyle = '#aaa';
      ctx.beginPath(); ctx.moveTo(x + 6.5, y - 12); ctx.lineTo(x + 9, y - 12); ctx.lineTo(x + 7.75, y - 16); ctx.closePath(); ctx.fill();
      break;
    case 'knights':
      // Mounted on horse! + lance + plate armor
      // Horse body
      ctx.fillStyle = '#5d4037';
      ctx.fillRect(x, y + 3, 14, 5);
      ctx.fillStyle = '#6d4c41';
      ctx.fillRect(x + 1, y + 4, 12, 3);
      // Horse head
      ctx.fillStyle = '#5d4037';
      ctx.beginPath(); ctx.moveTo(x + 14, y + 3); ctx.lineTo(x + 17, y + 1); ctx.lineTo(x + 17, y + 5); ctx.closePath(); ctx.fill();
      // Legs
      ctx.fillStyle = '#4e342e';
      ctx.fillRect(x + 2, y + 8, 1.5, 3); ctx.fillRect(x + 5, y + 8, 1.5, 3);
      ctx.fillRect(x + 9, y + 8, 1.5, 3); ctx.fillRect(x + 12, y + 8, 1.5, 3);
      // Knight rider (plate armor)
      ctx.fillStyle = '#888';
      ctx.fillRect(x + 5, y - 2, 5, 5);
      ctx.fillStyle = '#ddd';
      ctx.beginPath(); ctx.arc(x + 7, y - 4, 2.5, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#666'; ctx.fillRect(x + 5, y - 6, 5, 2); // helm
      // Lance
      ctx.fillStyle = '#5d4037'; ctx.fillRect(x + 10, y - 8, 1, 10);
      ctx.fillStyle = '#aaa';
      ctx.beginPath(); ctx.moveTo(x + 9.5, y - 8); ctx.lineTo(x + 12, y - 8); ctx.lineTo(x + 10.5, y - 11); ctx.closePath(); ctx.fill();
      break;
    case 'catapults':
      // Wooden siege frame with arm
      ctx.fillStyle = '#5d4037';
      ctx.fillRect(x, y + 4, 14, 5); // base
      ctx.fillRect(x + 2, y + 1, 2, 4); // left support
      ctx.fillRect(x + 10, y + 1, 2, 4); // right support
      // Arm
      ctx.fillStyle = '#795548';
      ctx.save(); ctx.translate(x + 7, y + 2); ctx.rotate(-0.4);
      ctx.fillRect(-1, -8, 2, 10);
      ctx.restore();
      // Sling/bucket
      ctx.fillStyle = '#333';
      ctx.beginPath(); ctx.arc(x + 4, y - 4, 2, 0, Math.PI * 2); ctx.fill();
      // Rope detail
      ctx.strokeStyle = '#8a7a5a'; ctx.lineWidth = 0.5;
      ctx.beginPath(); ctx.moveTo(x + 6, y + 2); ctx.lineTo(x + 4, y - 2); ctx.stroke();
      break;
    case 'healers':
      // White robes + glowing staff
      ctx.fillStyle = '#e8e8e8';
      ctx.fillRect(x + 3, y + 2, 6, 8);
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(x + 6, y, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#fff'; ctx.fillRect(x + 3, y - 3, 6, 2); // hood
      // Staff
      ctx.fillStyle = '#8a6830'; ctx.fillRect(x + 10, y - 6, 1.5, 12);
      // Glowing orb
      ctx.fillStyle = '#4caf50'; ctx.beginPath(); ctx.arc(x + 11, y - 7, 2, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = 'rgba(100,255,100,0.3)'; ctx.beginPath(); ctx.arc(x + 11, y - 7, 3.5, 0, Math.PI * 2); ctx.fill();
      break;
    case 'firelancers':
      // Byzantine-style body + fire siphon
      ctx.fillStyle = def.color;
      ctx.fillRect(x + 3, y + 2, 6, 8);
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(x + 6, y, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = def.dark; ctx.fillRect(x + 3, y - 4, 6, 3); // helm
      // Fire siphon (tube)
      ctx.fillStyle = '#555'; ctx.fillRect(x + 9, y - 1, 6, 2);
      // Flame
      ctx.fillStyle = '#ff6600';
      ctx.beginPath(); ctx.moveTo(x + 14, y - 2); ctx.lineTo(x + 17, y); ctx.lineTo(x + 14, y + 2); ctx.fill();
      ctx.fillStyle = '#ffcc00';
      ctx.beginPath(); ctx.arc(x + 15, y, 1.2, 0, Math.PI * 2); ctx.fill();
      // Tank on back
      ctx.fillStyle = '#4e342e'; ctx.fillRect(x, y + 1, 3, 5);
      break;
    case 'assassins':
      // Dark cloak + daggers
      ctx.fillStyle = def.dark;
      ctx.fillRect(x + 3, y + 2, 6, 8);
      ctx.fillStyle = def.color; ctx.fillRect(x + 3, y + 1, 6, 3); // cloak upper
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(x + 6, y, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#222'; ctx.fillRect(x + 2, y - 4, 8, 3); // deep hood
      // Daggers (crossed)
      ctx.fillStyle = '#aaa';
      ctx.save(); ctx.translate(x + 12, y + 2); ctx.rotate(0.3);
      ctx.fillRect(-1, -3, 1, 5); ctx.restore();
      ctx.save(); ctx.translate(x + 12, y + 2); ctx.rotate(-0.3);
      ctx.fillRect(-1, -3, 1, 5); ctx.restore();
      break;
    case 'cannons':
      // Bronze barrel on wooden carriage
      // Carriage
      ctx.fillStyle = '#5d4037';
      ctx.fillRect(x, y + 4, 14, 4);
      // Wheels
      ctx.fillStyle = '#3e2723';
      ctx.beginPath(); ctx.arc(x + 2, y + 9, 2.5, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(x + 12, y + 9, 2.5, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#5d4037';
      ctx.beginPath(); ctx.arc(x + 2, y + 9, 1, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(x + 12, y + 9, 1, 0, Math.PI * 2); ctx.fill();
      // Bronze barrel
      const barrelGrad = ctx.createLinearGradient(x + 2, y, x + 16, y + 4);
      barrelGrad.addColorStop(0, '#8a7040'); barrelGrad.addColorStop(0.5, '#a88850'); barrelGrad.addColorStop(1, '#7a6030');
      ctx.fillStyle = barrelGrad;
      ctx.fillRect(x + 2, y + 1, 12, 3);
      // Muzzle
      ctx.fillStyle = '#5a4020';
      ctx.beginPath(); ctx.arc(x + 14, y + 2.5, 2, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#333';
      ctx.beginPath(); ctx.arc(x + 14, y + 2.5, 1, 0, Math.PI * 2); ctx.fill();
      break;
  }
}

// -----------------------------------------------
//  SECTION 8: FOLLOWERS
// -----------------------------------------------
function getTopTroopTypes() {
  const owned = TROOP_ORDER.filter(t => armyCount(player.army, t) > 0);
  owned.sort((a, b) => TROOP_TYPES[b].str - TROOP_TYPES[a].str);
  return owned.slice(0, 3);
}

function drawFollowers() {
  // Handled inline in z-sorted draw loop
}

function drawFollowerAt(sx, sy, type, idx) {
  const def = TROOP_TYPES[type];
  const bob = Math.sin(animFrame * 0.1 + idx * 2) * 1;
  const scale = 0.85 - idx * 0.05;
  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath(); ctx.ellipse(sx, sy + 4, 8 * scale, 3 * scale, 0, 0, Math.PI * 2); ctx.fill();
  ctx.globalAlpha = 0.7;
  drawMiniTroop(sx - 8, sy - 12 + bob, type, def);
  // Count badge
  const fCount = armyCount(player.army, type);
  ctx.font = 'bold 8px sans-serif'; ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillText(fCount, sx + 1, sy + bob + 9);
  ctx.fillStyle = def.color;
  ctx.fillText(fCount, sx, sy + bob + 8);
  ctx.globalAlpha = 1;
}

// -----------------------------------------------
//  SECTION 9: PLAYER SPRITE (Medieval Lord/Knight)
// -----------------------------------------------
function drawPlayer(sx, sy) {
  const cx = sx, cy = sy;
  const bob = Math.sin(animFrame * 0.1) * 1.5;
  const bon = armyBonus(player.army);

  // Player glow aura (golden)
  const glowPulse = 0.14 + Math.sin(animFrame * 0.06) * 0.06;
  const glowOuter = ctx.createRadialGradient(cx, cy, 4, cx, cy, 38);
  glowOuter.addColorStop(0, 'rgba(240,192,64,' + (glowPulse + 0.04) + ')');
  glowOuter.addColorStop(0.3, 'rgba(200,160,40,' + (glowPulse * 0.6) + ')');
  glowOuter.addColorStop(0.6, 'rgba(160,120,30,' + (glowPulse * 0.25) + ')');
  glowOuter.addColorStop(1, 'rgba(120,90,20,0)');
  ctx.fillStyle = glowOuter;
  ctx.fillRect(cx - 44, cy - 44, 88, 88);

  // Ground ellipse ring
  ctx.strokeStyle = 'rgba(240,192,64,0.2)'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.ellipse(cx, cy + 4, 18, 8, 0, 0, Math.PI * 2); ctx.stroke();
  ctx.strokeStyle = 'rgba(240,192,64,0.35)'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.ellipse(cx, cy + 4, 14, 6, 0, 0, Math.PI * 2); ctx.stroke();
  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.beginPath(); ctx.ellipse(cx + 3, cy + 6, 12, 4.5, 0.2, 0, Math.PI * 2); ctx.fill();

  const by = cy - 10 + bob;

  // === MEDIEVAL LORD / KNIGHT ===

  // Leather boots with metal greaves
  const bootLGrad = ctx.createLinearGradient(cx - 7, by + 11, cx - 1, by + 15);
  bootLGrad.addColorStop(0, '#5a3a1e'); bootLGrad.addColorStop(0.5, '#4a2e16'); bootLGrad.addColorStop(1, '#3a2410');
  ctx.fillStyle = bootLGrad;
  ctx.fillRect(cx - 7, by + 11, 6, 4);
  ctx.fillRect(cx + 1, by + 11, 6, 4);
  // Boot soles
  ctx.fillStyle = '#1a1008'; ctx.fillRect(cx - 8, by + 14, 7, 1.5); ctx.fillRect(cx, by + 14, 7, 1.5);
  // Metal greaves
  const greaveGrad = ctx.createLinearGradient(cx - 6, by + 11, cx - 2, by + 14);
  greaveGrad.addColorStop(0, '#8a8a8a'); greaveGrad.addColorStop(0.5, '#aaa'); greaveGrad.addColorStop(1, '#7a7a7a');
  ctx.fillStyle = greaveGrad;
  ctx.fillRect(cx - 6, by + 11, 4, 3);
  ctx.fillRect(cx + 2, by + 11, 4, 3);
  // Greave rivet
  ctx.fillStyle = '#bbb';
  ctx.beginPath(); ctx.arc(cx - 4, by + 12.5, 0.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 4, by + 12.5, 0.5, 0, Math.PI * 2); ctx.fill();
  // Greave highlight
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.fillRect(cx - 5.5, by + 11, 3, 0.8); ctx.fillRect(cx + 2.5, by + 11, 3, 0.8);

  // Legs (armored)
  const legGrad = ctx.createLinearGradient(cx - 7, by + 3, cx + 7, by + 11);
  legGrad.addColorStop(0, '#707880'); legGrad.addColorStop(0.5, '#606870'); legGrad.addColorStop(1, '#505860');
  ctx.fillStyle = legGrad;
  ctx.fillRect(cx - 7, by + 3, 6, 9);
  ctx.fillRect(cx + 1, by + 3, 6, 9);
  // Knee cops (articulated)
  ctx.fillStyle = '#8a8a90';
  ctx.beginPath();
  ctx.moveTo(cx - 6, by + 6); ctx.quadraticCurveTo(cx - 4, by + 5, cx - 2, by + 6);
  ctx.lineTo(cx - 2, by + 8); ctx.quadraticCurveTo(cx - 4, by + 8.8, cx - 6, by + 8); ctx.closePath(); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(cx + 2, by + 6); ctx.quadraticCurveTo(cx + 4, by + 5, cx + 6, by + 6);
  ctx.lineTo(cx + 6, by + 8); ctx.quadraticCurveTo(cx + 4, by + 8.8, cx + 2, by + 8); ctx.closePath(); ctx.fill();
  // Knee highlight
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  ctx.fillRect(cx - 5.5, by + 6, 3, 0.8); ctx.fillRect(cx + 2.5, by + 6, 3, 0.8);
  // Chainmail visible between plates
  ctx.fillStyle = 'rgba(150,150,160,0.3)';
  for (let ci = 0; ci < 3; ci++) {
    ctx.fillRect(cx - 1 + ci * 0.3, by + 3 + ci * 2, 2, 1);
  }
  // Belt/tassets
  ctx.fillStyle = '#4a3018'; ctx.fillRect(cx - 7, by + 3, 14, 1.8);
  ctx.fillStyle = '#b89840'; ctx.fillRect(cx - 1.5, by + 3, 3, 1.8); // gold buckle
  ctx.fillStyle = 'rgba(255,255,255,0.15)'; ctx.fillRect(cx - 1, by + 3.2, 2, 0.5);

  // Longsword at hip (left side)
  ctx.fillStyle = '#4a3018';
  ctx.fillRect(cx - 10, by + 1, 1.5, 8); // scabbard
  ctx.fillStyle = '#666';
  ctx.fillRect(cx - 10.5, by + 1, 2.5, 1); // mouth
  ctx.fillStyle = '#b89840';
  ctx.beginPath(); ctx.arc(cx - 9.5, by, 1, 0, Math.PI * 2); ctx.fill(); // pommel
  // Cross-guard
  ctx.fillStyle = '#b89840';
  ctx.fillRect(cx - 11.5, by + 0.5, 4, 0.8);

  // Body - steel plate armor with etched designs
  const bodyGrad = ctx.createLinearGradient(cx - 9, by - 7, cx + 9, by + 5);
  bodyGrad.addColorStop(0, '#8a8e96'); bodyGrad.addColorStop(0.3, '#7a7e86'); bodyGrad.addColorStop(0.6, '#6a6e76'); bodyGrad.addColorStop(1, '#5a5e66');
  ctx.fillStyle = bodyGrad;
  ctx.fillRect(cx - 9, by - 7, 18, 13);
  // Plate segments
  ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 0.4;
  ctx.beginPath(); ctx.moveTo(cx - 8, by - 3); ctx.lineTo(cx + 8, by - 3); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx - 8, by); ctx.lineTo(cx + 8, by); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx - 8, by + 3); ctx.lineTo(cx + 8, by + 3); ctx.stroke();
  // Etched design on breastplate (simple cross/crest)
  ctx.strokeStyle = 'rgba(184,152,64,0.25)'; ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.moveTo(cx, by - 5); ctx.lineTo(cx, by + 1); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx - 3, by - 2); ctx.lineTo(cx + 3, by - 2); ctx.stroke();
  // Rivet details along plate edges
  ctx.fillStyle = '#aab';
  for (let ri = 0; ri < 4; ri++) {
    ctx.beginPath(); ctx.arc(cx - 7 + ri * 4.5, by - 6, 0.5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx - 7 + ri * 4.5, by + 4, 0.5, 0, Math.PI * 2); ctx.fill();
  }
  // Chainmail at joints
  ctx.fillStyle = 'rgba(140,145,155,0.4)';
  for (let ci = 0; ci < 4; ci++) {
    for (let cj = 0; cj < 2; cj++) {
      ctx.beginPath(); ctx.arc(cx - 8 + ci * 1.5, by - 7 + cj * 1, 0.4, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(cx + 5 + ci * 1.5, by - 7 + cj * 1, 0.4, 0, Math.PI * 2); ctx.fill();
    }
  }
  // Body directional lighting
  ctx.fillStyle = 'rgba(255,255,220,0.1)';
  ctx.fillRect(cx - 8, by - 7, 9, 5);
  ctx.fillStyle = 'rgba(0,0,0,0.1)';
  ctx.fillRect(cx + 2, by + 1, 6, 5);

  // Gorget (neck armor)
  ctx.fillStyle = '#808890'; ctx.fillRect(cx - 4, by - 8, 8, 2);
  ctx.fillStyle = 'rgba(255,255,255,0.08)'; ctx.fillRect(cx - 3, by - 8, 6, 0.5);

  if (bon > 0) {
    ctx.strokeStyle = 'rgba(240,192,64,0.35)'; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(cx - 10, by - 8); ctx.lineTo(cx + 10, by - 8);
    ctx.lineTo(cx + 10, by + 7); ctx.lineTo(cx - 10, by + 7); ctx.closePath();
    ctx.stroke();
  }

  // Arms (pauldrons + gauntlets)
  // Left arm
  const armLGrad = ctx.createLinearGradient(cx - 13, by - 4, cx - 8, by + 5);
  armLGrad.addColorStop(0, '#7a7e86'); armLGrad.addColorStop(1, '#5a5e66');
  ctx.fillStyle = armLGrad;
  ctx.fillRect(cx - 13, by - 4, 5, 10);
  // Right arm
  const armRGrad = ctx.createLinearGradient(cx + 8, by - 4, cx + 13, by + 5);
  armRGrad.addColorStop(0, '#6a6e76'); armRGrad.addColorStop(1, '#5a5e66');
  ctx.fillStyle = armRGrad;
  ctx.fillRect(cx + 8, by - 4, 5, 10);
  // Pauldrons (shoulder plates, rounded)
  const pauldGrad = ctx.createLinearGradient(cx - 14, by - 6, cx - 8, by - 2);
  pauldGrad.addColorStop(0, '#9a9ea6'); pauldGrad.addColorStop(0.5, '#8a8e96'); pauldGrad.addColorStop(1, '#7a7e86');
  ctx.fillStyle = pauldGrad;
  ctx.beginPath(); ctx.ellipse(cx - 10, by - 5, 4, 3, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx + 10, by - 5, 4, 3, 0, 0, Math.PI * 2); ctx.fill();
  // Pauldron rivet
  ctx.fillStyle = '#bbb';
  ctx.beginPath(); ctx.arc(cx - 10, by - 5, 0.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 10, by - 5, 0.5, 0, Math.PI * 2); ctx.fill();
  // Elbow cops
  ctx.fillStyle = '#8a8e96'; ctx.fillRect(cx - 12, by + 1, 3, 2); ctx.fillRect(cx + 9, by + 1, 3, 2);
  // Gauntlets (metal gloves)
  const gauntGrad = ctx.createLinearGradient(cx - 13, by + 5, cx - 9, by + 8);
  gauntGrad.addColorStop(0, '#7a7e86'); gauntGrad.addColorStop(1, '#5a5e66');
  ctx.fillStyle = gauntGrad;
  ctx.fillRect(cx - 13, by + 5, 4, 3);
  ctx.fillRect(cx + 9, by + 5, 4, 3);
  // Gauntlet finger articulation
  ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 0.3;
  ctx.beginPath(); ctx.moveTo(cx - 12, by + 6.5); ctx.lineTo(cx - 10, by + 6.5); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 10, by + 6.5); ctx.lineTo(cx + 12, by + 6.5); ctx.stroke();
  // Gauntlet highlight
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  ctx.fillRect(cx - 12.5, by + 5, 3, 0.8); ctx.fillRect(cx + 9.5, by + 5, 3, 0.8);

  // Flowing cape (heraldic colors - blue/gold)
  const capeSway = Math.sin(animFrame * 0.08) * 2;
  const capeGrad = ctx.createLinearGradient(cx - 4, by - 6, cx + 4, by + 8);
  capeGrad.addColorStop(0, '#1565c0'); capeGrad.addColorStop(0.5, '#1e88e5'); capeGrad.addColorStop(1, '#0d47a1');
  ctx.fillStyle = capeGrad;
  ctx.beginPath();
  ctx.moveTo(cx - 6, by - 6);
  ctx.lineTo(cx + 6, by - 6);
  ctx.quadraticCurveTo(cx + 8 + capeSway, by + 4, cx + 5 + capeSway * 1.5, by + 10);
  ctx.lineTo(cx - 5 + capeSway * 1.2, by + 10);
  ctx.quadraticCurveTo(cx - 8 + capeSway * 0.5, by + 4, cx - 6, by - 6);
  ctx.closePath();
  ctx.fill();
  // Cape gold trim at bottom
  ctx.fillStyle = '#b89840';
  ctx.fillRect(cx - 5 + capeSway * 1.2, by + 9, 10 + capeSway * 0.3, 1.5);
  // Cape heraldic symbol (simple lion shape hint)
  ctx.fillStyle = 'rgba(184,152,64,0.3)';
  ctx.beginPath();
  ctx.arc(cx + capeSway * 0.5, by + 2, 3, 0, Math.PI * 2);
  ctx.fill();

  // Shield on back (visible behind cape)
  ctx.fillStyle = '#1565c0';
  ctx.beginPath();
  ctx.moveTo(cx + 7, by - 4);
  ctx.lineTo(cx + 14, by - 2);
  ctx.lineTo(cx + 14, by + 4);
  ctx.lineTo(cx + 10, by + 7);
  ctx.lineTo(cx + 7, by + 4);
  ctx.closePath();
  ctx.fill();
  // Shield border
  ctx.strokeStyle = '#b89840'; ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.moveTo(cx + 7, by - 4);
  ctx.lineTo(cx + 14, by - 2);
  ctx.lineTo(cx + 14, by + 4);
  ctx.lineTo(cx + 10, by + 7);
  ctx.lineTo(cx + 7, by + 4);
  ctx.closePath();
  ctx.stroke();
  // Lion emblem on shield
  ctx.fillStyle = '#b89840';
  ctx.beginPath(); ctx.arc(cx + 10, by + 1, 2.5, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#1565c0';
  ctx.beginPath(); ctx.arc(cx + 10, by + 1, 1.5, 0, Math.PI * 2); ctx.fill();

  // Head
  // Neck
  ctx.fillStyle = '#c8a882'; ctx.fillRect(cx - 2.5, by - 9, 5, 2);

  // Head shape
  const headGrad = ctx.createRadialGradient(cx - 2, by - 15, 1, cx, by - 13, 7);
  headGrad.addColorStop(0, '#e8d0b0'); headGrad.addColorStop(0.6, '#d8b898'); headGrad.addColorStop(1, '#c0a080');
  ctx.fillStyle = headGrad;
  ctx.beginPath(); ctx.arc(cx, by - 13, 6.5, 0, Math.PI * 2); ctx.fill();

  // Beard (determined, short)
  ctx.fillStyle = '#4a2e16';
  ctx.beginPath();
  ctx.moveTo(cx - 4, by - 11);
  ctx.quadraticCurveTo(cx - 5, by - 9, cx - 3, by - 7.5);
  ctx.quadraticCurveTo(cx, by - 6.5, cx + 3, by - 7.5);
  ctx.quadraticCurveTo(cx + 5, by - 9, cx + 4, by - 11);
  ctx.closePath();
  ctx.fill();
  // Beard texture
  ctx.strokeStyle = 'rgba(30,15,5,0.15)'; ctx.lineWidth = 0.3;
  for (let s = 0; s < 5; s++) {
    ctx.beginPath(); ctx.moveTo(cx - 2 + s, by - 10); ctx.lineTo(cx - 2 + s + 0.2, by - 7.5); ctx.stroke();
  }

  // Eyes (determined expression)
  ctx.fillStyle = '#f0f0e8'; ctx.fillRect(cx - 3, by - 14.5, 2.5, 2); ctx.fillRect(cx + 0.5, by - 14.5, 2.5, 2);
  ctx.fillStyle = '#4a6a7a'; ctx.fillRect(cx - 2.5, by - 14, 1.8, 1.6); ctx.fillRect(cx + 1, by - 14, 1.8, 1.6);
  ctx.fillStyle = '#111'; ctx.fillRect(cx - 2, by - 13.8, 1.2, 1.2); ctx.fillRect(cx + 1.5, by - 13.8, 1.2, 1.2);
  ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.fillRect(cx - 2.3, by - 14, 0.5, 0.5); ctx.fillRect(cx + 1.2, by - 14, 0.5, 0.5);
  // Furrowed eyebrows
  ctx.fillStyle = 'rgba(50,35,20,0.55)';
  ctx.save(); ctx.translate(cx - 3.5, by - 15.5); ctx.rotate(0.1);
  ctx.fillRect(0, 0, 3.5, 0.9); ctx.restore();
  ctx.save(); ctx.translate(cx + 0.5, by - 15.8); ctx.rotate(-0.1);
  ctx.fillRect(0, 0, 3.5, 0.9); ctx.restore();
  // Nose
  ctx.fillStyle = 'rgba(190,160,130,0.35)';
  ctx.beginPath(); ctx.moveTo(cx - 0.5, by - 13); ctx.lineTo(cx + 0.5, by - 11);
  ctx.lineTo(cx + 1.5, by - 10.5); ctx.lineTo(cx - 0.5, by - 10.5); ctx.closePath(); ctx.fill();
  // Ears
  ctx.fillStyle = '#d4b494';
  ctx.beginPath(); ctx.ellipse(cx + 6, by - 13, 1.5, 2.5, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#c8a882';
  ctx.beginPath(); ctx.ellipse(cx + 6, by - 13, 0.8, 1.5, 0, 0, Math.PI * 2); ctx.fill();

  // Helmet (great helm / crowned)
  const helmetGrad = ctx.createLinearGradient(cx - 8, by - 22, cx + 8, by - 14);
  helmetGrad.addColorStop(0, '#9a9ea6'); helmetGrad.addColorStop(0.3, '#8a8e96'); helmetGrad.addColorStop(0.7, '#7a7e86'); helmetGrad.addColorStop(1, '#6a6e76');
  ctx.fillStyle = helmetGrad;
  ctx.beginPath(); ctx.arc(cx, by - 17, 8.5, Math.PI, 0); ctx.fill();
  ctx.fillRect(cx - 8.5, by - 17.5, 17, 4);
  // Helmet visor (open, showing face)
  ctx.fillStyle = '#7a7e86';
  ctx.fillRect(cx - 7, by - 14, 14, 1);
  // Helmet highlight
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.beginPath(); ctx.arc(cx - 2, by - 20, 4, Math.PI, 0); ctx.fill();
  // Nose guard
  ctx.fillStyle = '#8a8e96';
  ctx.fillRect(cx - 0.8, by - 16, 1.6, 3);

  // Crown/circlet over helmet (gold)
  ctx.fillStyle = '#d4ae3a';
  ctx.fillRect(cx - 8, by - 16.5, 16, 2);
  // Crown points
  ctx.fillStyle = '#d4ae3a';
  for (let cp = 0; cp < 5; cp++) {
    const cpx = cx - 7 + cp * 3.5;
    ctx.beginPath();
    ctx.moveTo(cpx, by - 16.5);
    ctx.lineTo(cpx + 1.2, by - 19);
    ctx.lineTo(cpx + 2.4, by - 16.5);
    ctx.closePath();
    ctx.fill();
  }
  // Crown gems
  ctx.fillStyle = '#e53935';
  ctx.beginPath(); ctx.arc(cx, by - 18, 0.8, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#1565c0';
  ctx.beginPath(); ctx.arc(cx - 3.5, by - 17.5, 0.6, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 3.5, by - 17.5, 0.6, 0, Math.PI * 2); ctx.fill();
  // Crown gold trim highlight
  ctx.fillStyle = 'rgba(255,255,200,0.2)'; ctx.fillRect(cx - 7, by - 16.5, 14, 0.5);

  // Chin strap
  ctx.fillStyle = '#5a5e66'; ctx.fillRect(cx - 6, by - 13.5, 1, 3); ctx.fillRect(cx + 5.5, by - 13.5, 1, 3);

  // Player name floating above
  if (playerName) {
    ctx.font = 'bold 8px sans-serif'; ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.fillText(playerName, cx + 1, by - 22);
    ctx.fillStyle = '#f0e0a0'; ctx.fillText(playerName, cx, by - 23);
  }

  const pw = armyPower(player.army);
  drawLabel(cx, cy + 16, pw + (bon > 0 ? '+' + bon : ''), '#f0c040');
}

// -----------------------------------------------
//  SECTION 10: ENEMY SPRITES (Medieval)
// -----------------------------------------------

// --- BANDIT (replaces militant) ---
function drawBandit(cx, by, def) {
  // Worn leather boots
  ctx.fillStyle = '#3e2a1a';
  ctx.fillRect(cx - 5, by + 9, 4, 3); ctx.fillRect(cx + 1, by + 9, 4, 3);
  ctx.fillStyle = '#2a1a0a'; ctx.fillRect(cx - 6, by + 11, 5, 1.5); ctx.fillRect(cx, by + 11, 5, 1.5);

  // Ragged pants (patched)
  const pantsGrad = ctx.createLinearGradient(cx - 5, by + 3, cx + 4, by + 9);
  pantsGrad.addColorStop(0, '#7a6a4a'); pantsGrad.addColorStop(1, '#5a4a2a');
  ctx.fillStyle = pantsGrad;
  ctx.fillRect(cx - 5, by + 3, 4, 7); ctx.fillRect(cx + 1, by + 3, 4, 7);
  // Patches
  ctx.fillStyle = '#6a5a3a'; ctx.fillRect(cx - 4, by + 5, 2, 2);
  ctx.fillStyle = '#8a7a5a'; ctx.fillRect(cx + 2, by + 7, 2, 2);
  // Belt with stolen pouches
  ctx.fillStyle = '#3a2a1a'; ctx.fillRect(cx - 5, by + 3, 10, 1.5);
  ctx.fillStyle = '#5a4a3a';
  ctx.fillRect(cx + 3, by + 2, 2, 2); // pouch
  ctx.fillRect(cx - 5, by + 2, 2, 2); // pouch

  // Ragged tunic (brown/tan, torn)
  const torsoGrad = ctx.createLinearGradient(cx - 7, by - 5, cx + 7, by + 4);
  torsoGrad.addColorStop(0, '#9a8a6a'); torsoGrad.addColorStop(0.4, def.color); torsoGrad.addColorStop(1, def.dark);
  ctx.fillStyle = torsoGrad;
  ctx.fillRect(cx - 7, by - 5, 14, 10);
  // Torn edges
  ctx.fillStyle = 'rgba(0,0,0,0.1)';
  ctx.fillRect(cx - 7, by + 3, 3, 1);
  ctx.fillRect(cx + 5, by + 2, 2, 1.5);
  // Stitching/patches
  ctx.strokeStyle = '#5a4a30'; ctx.lineWidth = 0.4;
  ctx.beginPath(); ctx.moveTo(cx - 3, by - 2); ctx.lineTo(cx - 1, by + 2); ctx.stroke();
  ctx.fillStyle = '#7a6a4a'; ctx.fillRect(cx + 2, by - 3, 3, 3); // patch

  // Arms
  ctx.fillStyle = '#c8a070';
  ctx.fillRect(cx - 10, by - 3, 4, 8); ctx.fillRect(cx + 6, by - 3, 4, 8);
  // Rolled sleeves
  ctx.fillStyle = def.color;
  ctx.fillRect(cx - 10, by - 4, 4, 2); ctx.fillRect(cx + 6, by - 4, 4, 2);
  // Hands
  ctx.fillStyle = '#c8a070';
  ctx.fillRect(cx - 10, by + 4, 3, 2); ctx.fillRect(cx + 7, by + 4, 3, 2);

  // Curved dagger in hand
  ctx.fillStyle = '#aaa';
  ctx.save(); ctx.translate(cx + 9, by + 3);
  ctx.rotate(0.3);
  ctx.beginPath();
  ctx.moveTo(0, 0); ctx.quadraticCurveTo(3, -3, 2, -7);
  ctx.lineTo(1, -7); ctx.quadraticCurveTo(2, -3, -1, 0);
  ctx.closePath(); ctx.fill();
  ctx.restore();
  // Dagger handle
  ctx.fillStyle = '#5d4037'; ctx.fillRect(cx + 8, by + 3, 2, 3);

  // Head
  ctx.fillStyle = '#c8a070'; ctx.fillRect(cx - 2, by - 8, 4, 3);
  const headGrad = ctx.createRadialGradient(cx - 1, by - 13, 1, cx, by - 11, 6);
  headGrad.addColorStop(0, '#d8b890'); headGrad.addColorStop(1, '#b89070');
  ctx.fillStyle = headGrad;
  ctx.beginPath(); ctx.arc(cx, by - 11, 6, 0, Math.PI * 2); ctx.fill();
  // Scarred face, stubble
  ctx.fillStyle = 'rgba(40,30,20,0.2)';
  ctx.beginPath(); ctx.arc(cx, by - 8, 4, 0, Math.PI); ctx.fill();
  // Scar
  ctx.strokeStyle = 'rgba(180,100,100,0.4)'; ctx.lineWidth = 0.6;
  ctx.beginPath(); ctx.moveTo(cx - 3, by - 13); ctx.lineTo(cx - 1, by - 9); ctx.stroke();
  // Eyes (shifty)
  ctx.fillStyle = '#e8e8d8'; ctx.fillRect(cx - 3, by - 12.5, 2.5, 1.8); ctx.fillRect(cx + 0.5, by - 12.5, 2.5, 1.8);
  ctx.fillStyle = '#2a1a0a'; ctx.fillRect(cx - 2.5, by - 12, 1.5, 1.3); ctx.fillRect(cx + 1, by - 12, 1.5, 1.3);
  // Angry brows
  ctx.fillStyle = 'rgba(40,30,20,0.5)';
  ctx.save(); ctx.translate(cx - 3, by - 13.5); ctx.rotate(0.15);
  ctx.fillRect(0, 0, 3, 0.8); ctx.restore();
  ctx.save(); ctx.translate(cx + 0.5, by - 14); ctx.rotate(-0.15);
  ctx.fillRect(0, 0, 3, 0.8); ctx.restore();
  // Nose, mouth
  ctx.fillStyle = 'rgba(180,140,110,0.4)'; ctx.fillRect(cx - 0.5, by - 11, 1.5, 2);
  ctx.fillStyle = 'rgba(100,50,30,0.4)'; ctx.fillRect(cx - 1.5, by - 8.5, 3, 0.7);

  // Hood pulled low
  ctx.fillStyle = def.dark;
  ctx.beginPath(); ctx.arc(cx, by - 15, 7, Math.PI, 0); ctx.fill();
  ctx.fillRect(cx - 7, by - 16, 14, 4);
  ctx.fillStyle = def.color;
  ctx.fillRect(cx - 6.5, by - 13, 13, 1.5);
  // Hood shadow over eyes
  ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.fillRect(cx - 5, by - 14, 10, 2);
}

// --- RAIDER (replaces commando) ---
function drawRaider(cx, by, def) {
  // Heavy boots
  ctx.fillStyle = '#2a1a0a';
  ctx.fillRect(cx - 6, by + 9, 5, 3); ctx.fillRect(cx + 1, by + 9, 5, 3);
  ctx.fillStyle = '#1a0a00'; ctx.fillRect(cx - 7, by + 11, 6, 1.5); ctx.fillRect(cx, by + 11, 6, 1.5);

  // Leather pants with studs
  ctx.fillStyle = '#4a3a2a';
  ctx.fillRect(cx - 6, by + 3, 5, 7); ctx.fillRect(cx + 1, by + 3, 5, 7);
  // Studs on legs
  ctx.fillStyle = '#888';
  ctx.beginPath(); ctx.arc(cx - 4, by + 5, 0.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 3, by + 6, 0.5, 0, Math.PI * 2); ctx.fill();
  // Belt
  ctx.fillStyle = '#3a2a1a'; ctx.fillRect(cx - 6, by + 3, 12, 1.5);

  // Leather armor torso with studs
  const torsoGrad = ctx.createLinearGradient(cx - 7, by - 6, cx + 7, by + 4);
  torsoGrad.addColorStop(0, '#5a4a3a'); torsoGrad.addColorStop(0.4, def.color); torsoGrad.addColorStop(1, def.dark);
  ctx.fillStyle = torsoGrad;
  ctx.fillRect(cx - 7, by - 6, 14, 11);
  // Stud rows
  ctx.fillStyle = '#888';
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 4; c++) {
      ctx.beginPath(); ctx.arc(cx - 5 + c * 3, by - 4 + r * 3, 0.6, 0, Math.PI * 2); ctx.fill();
    }
  }
  // Fur-trimmed cloak collar
  ctx.fillStyle = '#6a5040';
  ctx.fillRect(cx - 8, by - 7, 16, 2);
  ctx.fillStyle = '#8a7a6a';
  for (let fc = 0; fc < 8; fc++) {
    ctx.fillRect(cx - 7 + fc * 2, by - 7, 1.5, 2);
  }

  // Arms (leather sleeves)
  ctx.fillStyle = '#4a3a2a';
  ctx.fillRect(cx - 11, by - 4, 4, 9); ctx.fillRect(cx + 7, by - 4, 4, 9);
  // Forearms
  ctx.fillStyle = '#c8a070';
  ctx.fillRect(cx - 11, by + 3, 3, 2); ctx.fillRect(cx + 8, by + 3, 3, 2);

  // Round wooden shield with iron boss (left hand)
  ctx.fillStyle = '#6d4c41';
  ctx.beginPath(); ctx.arc(cx - 13, by, 5, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#5d4037';
  ctx.beginPath(); ctx.arc(cx - 13, by, 4, 0, Math.PI * 2); ctx.fill();
  // Iron boss
  ctx.fillStyle = '#888';
  ctx.beginPath(); ctx.arc(cx - 13, by, 1.8, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#aaa';
  ctx.beginPath(); ctx.arc(cx - 13, by, 0.8, 0, Math.PI * 2); ctx.fill();
  // Shield rim
  ctx.strokeStyle = '#555'; ctx.lineWidth = 0.8;
  ctx.beginPath(); ctx.arc(cx - 13, by, 5, 0, Math.PI * 2); ctx.stroke();

  // War axe in right hand
  ctx.fillStyle = '#5d4037'; ctx.fillRect(cx + 9, by - 4, 1.5, 10); // handle
  // Axe head
  ctx.fillStyle = '#777';
  ctx.beginPath();
  ctx.moveTo(cx + 9, by - 4);
  ctx.lineTo(cx + 13, by - 7);
  ctx.lineTo(cx + 14, by - 5);
  ctx.lineTo(cx + 11, by - 3);
  ctx.closePath(); ctx.fill();
  // Edge gleam
  ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.moveTo(cx + 13, by - 7); ctx.lineTo(cx + 14, by - 5); ctx.stroke();

  // Head
  ctx.fillStyle = '#c8a070'; ctx.fillRect(cx - 2, by - 9, 4, 3);
  const headGrad = ctx.createRadialGradient(cx - 1, by - 13, 1, cx, by - 11, 6);
  headGrad.addColorStop(0, '#d8b890'); headGrad.addColorStop(1, '#b89070');
  ctx.fillStyle = headGrad;
  ctx.beginPath(); ctx.arc(cx, by - 11, 6, 0, Math.PI * 2); ctx.fill();
  // War paint (red streaks)
  ctx.fillStyle = 'rgba(180,40,40,0.35)';
  ctx.fillRect(cx - 4, by - 12, 2, 4);
  ctx.fillRect(cx + 2, by - 13, 2, 5);
  ctx.beginPath(); ctx.moveTo(cx - 1, by - 14); ctx.lineTo(cx, by - 9); ctx.lineTo(cx + 1, by - 14); ctx.fill();
  // Eyes (fierce)
  ctx.fillStyle = '#e8e8d8'; ctx.fillRect(cx - 3, by - 12.5, 2.5, 1.8); ctx.fillRect(cx + 0.5, by - 12.5, 2.5, 1.8);
  ctx.fillStyle = '#1a1a0a'; ctx.fillRect(cx - 2.5, by - 12, 1.5, 1.3); ctx.fillRect(cx + 1, by - 12, 1.5, 1.3);
  // Brows
  ctx.fillStyle = 'rgba(40,30,20,0.6)';
  ctx.save(); ctx.translate(cx - 3, by - 13.5); ctx.rotate(0.15);
  ctx.fillRect(0, 0, 3, 0.8); ctx.restore();
  ctx.save(); ctx.translate(cx + 0.5, by - 14); ctx.rotate(-0.15);
  ctx.fillRect(0, 0, 3, 0.8); ctx.restore();
  // Mouth
  ctx.fillStyle = 'rgba(100,50,30,0.4)'; ctx.fillRect(cx - 1.5, by - 8.5, 3, 0.7);
  // Leather helmet/cap
  ctx.fillStyle = '#3a2a1a';
  ctx.beginPath(); ctx.arc(cx, by - 15, 7, Math.PI, 0); ctx.fill();
  ctx.fillRect(cx - 7, by - 16, 14, 3);
  // Helmet nose guard
  ctx.fillStyle = '#555'; ctx.fillRect(cx - 0.5, by - 14, 1.5, 3);
}

// --- ENEMY ARCHER (replaces sniper_e) ---
function drawEnemyArcher(cx, by, def) {
  // Light leather boots
  ctx.fillStyle = '#4a3a20';
  ctx.fillRect(cx - 5, by + 9, 4, 3); ctx.fillRect(cx + 1, by + 9, 4, 3);

  // Leggings
  ctx.fillStyle = '#5a5030';
  ctx.fillRect(cx - 5, by + 3, 4, 7); ctx.fillRect(cx + 1, by + 3, 4, 7);

  // Light leather armor
  const torsoGrad = ctx.createLinearGradient(cx - 6, by - 5, cx + 6, by + 4);
  torsoGrad.addColorStop(0, '#5a5030'); torsoGrad.addColorStop(0.5, def.color); torsoGrad.addColorStop(1, def.dark);
  ctx.fillStyle = torsoGrad;
  ctx.fillRect(cx - 6, by - 5, 12, 10);

  // Green cloak with hood
  ctx.fillStyle = def.color;
  ctx.beginPath();
  ctx.moveTo(cx - 7, by - 6);
  ctx.lineTo(cx + 7, by - 6);
  ctx.lineTo(cx + 5, by + 5);
  ctx.lineTo(cx - 5, by + 5);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = 'rgba(0,0,0,0.1)';
  ctx.fillRect(cx - 1, by - 5, 0.5, 10);

  // Arms
  ctx.fillStyle = def.color;
  ctx.fillRect(cx - 10, by - 3, 4, 8); ctx.fillRect(cx + 6, by - 3, 4, 8);
  ctx.fillStyle = '#c8a070';
  ctx.fillRect(cx - 10, by + 4, 3, 2); ctx.fillRect(cx + 7, by + 4, 3, 2);

  // Longbow (drawn with arrow nocked)
  ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(cx + 14, by, 8, -Math.PI * 0.6, Math.PI * 0.6);
  ctx.stroke();
  // Bowstring
  ctx.strokeStyle = '#ccc'; ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(cx + 14 + Math.cos(-Math.PI * 0.6) * 8, by + Math.sin(-Math.PI * 0.6) * 8);
  ctx.lineTo(cx + 9, by);
  ctx.lineTo(cx + 14 + Math.cos(Math.PI * 0.6) * 8, by + Math.sin(Math.PI * 0.6) * 8);
  ctx.stroke();
  // Arrow
  ctx.fillStyle = '#5d4037'; ctx.fillRect(cx + 5, by - 0.5, 10, 1);
  ctx.fillStyle = '#aaa';
  ctx.beginPath(); ctx.moveTo(cx + 15, by - 1.5); ctx.lineTo(cx + 18, by); ctx.lineTo(cx + 15, by + 1.5); ctx.closePath(); ctx.fill();
  // Fletching
  ctx.fillStyle = '#888'; ctx.fillRect(cx + 4, by - 1, 2, 0.5); ctx.fillRect(cx + 4, by + 0.5, 2, 0.5);

  // Quiver on back
  ctx.fillStyle = '#5d4037'; ctx.fillRect(cx - 8, by - 6, 3, 10);
  // Arrows visible
  ctx.fillStyle = '#795548';
  ctx.fillRect(cx - 7.5, by - 8, 0.8, 3);
  ctx.fillRect(cx - 6.5, by - 9, 0.8, 4);
  ctx.fillRect(cx - 5.5, by - 7, 0.8, 2);

  // Head with pointed hood
  ctx.fillStyle = '#c8a070'; ctx.fillRect(cx - 2, by - 8, 4, 3);
  ctx.fillStyle = '#c8a070';
  ctx.beginPath(); ctx.arc(cx, by - 11, 5.5, 0, Math.PI * 2); ctx.fill();
  // Hood (pointed)
  ctx.fillStyle = def.dark;
  ctx.beginPath(); ctx.arc(cx, by - 15, 6.5, Math.PI, 0); ctx.fill();
  ctx.fillRect(cx - 6.5, by - 15.5, 13, 3);
  ctx.fillStyle = def.color;
  ctx.beginPath();
  ctx.moveTo(cx, by - 22);
  ctx.lineTo(cx + 5, by - 14);
  ctx.lineTo(cx - 5, by - 14);
  ctx.closePath();
  ctx.fill();
  // Eyes
  ctx.fillStyle = '#e8e8d8'; ctx.fillRect(cx - 2.5, by - 12, 2, 1.5); ctx.fillRect(cx + 0.5, by - 12, 2, 1.5);
  ctx.fillStyle = '#0a3a0a'; ctx.fillRect(cx - 2, by - 11.5, 1.3, 1); ctx.fillRect(cx + 1, by - 11.5, 1.3, 1);
}

// --- WAR ELEPHANT (replaces APC) ---
function drawWarElephant(cx, by, def) {
  // Larger shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath(); ctx.ellipse(cx + 3, by + 12, 16, 6, 0.2, 0, Math.PI * 2); ctx.fill();

  // Large gray elephant body (wider)
  const bodyGrad = ctx.createLinearGradient(cx - 14, by - 4, cx + 14, by + 8);
  bodyGrad.addColorStop(0, '#8a8a88'); bodyGrad.addColorStop(0.5, '#7a7a78'); bodyGrad.addColorStop(1, '#6a6a68');
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.ellipse(cx, by + 2, 14, 8, 0, 0, Math.PI * 2);
  ctx.fill();

  // Legs (thick pillars)
  ctx.fillStyle = '#6a6a68';
  ctx.fillRect(cx - 12, by + 6, 5, 8);
  ctx.fillRect(cx - 5, by + 6, 5, 8);
  ctx.fillRect(cx + 2, by + 6, 5, 8);
  ctx.fillRect(cx + 9, by + 6, 5, 8);
  // Feet
  ctx.fillStyle = '#5a5a58';
  ctx.fillRect(cx - 13, by + 13, 6, 2);
  ctx.fillRect(cx - 6, by + 13, 6, 2);
  ctx.fillRect(cx + 1, by + 13, 6, 2);
  ctx.fillRect(cx + 8, by + 13, 6, 2);

  // Elephant head
  ctx.fillStyle = '#8a8a88';
  ctx.beginPath(); ctx.arc(cx + 12, by - 2, 6, 0, Math.PI * 2); ctx.fill();
  // Trunk
  ctx.strokeStyle = '#7a7a78'; ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(cx + 16, by);
  ctx.quadraticCurveTo(cx + 20, by + 5, cx + 18, by + 10);
  ctx.stroke();
  // Tusks
  ctx.fillStyle = '#f0e8d8';
  ctx.beginPath();
  ctx.moveTo(cx + 14, by + 1);
  ctx.quadraticCurveTo(cx + 20, by - 2, cx + 18, by - 5);
  ctx.lineTo(cx + 17, by - 4);
  ctx.quadraticCurveTo(cx + 19, by - 1, cx + 13, by + 1);
  ctx.closePath(); ctx.fill();
  // Ear
  ctx.fillStyle = '#888886';
  ctx.beginPath(); ctx.ellipse(cx + 8, by - 4, 4, 6, -0.2, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#9a8a8a';
  ctx.beginPath(); ctx.ellipse(cx + 8, by - 4, 2.5, 4, -0.2, 0, Math.PI * 2); ctx.fill();
  // Eye
  ctx.fillStyle = '#333';
  ctx.beginPath(); ctx.arc(cx + 14, by - 3, 1, 0, Math.PI * 2); ctx.fill();

  // Decorated cloth/armor on elephant
  ctx.fillStyle = '#8b1a1a';
  ctx.fillRect(cx - 10, by - 5, 20, 4);
  ctx.fillStyle = '#ffd54f';
  ctx.fillRect(cx - 10, by - 5, 20, 0.8);
  ctx.fillRect(cx - 10, by - 2, 20, 0.8);
  // Tassels
  for (let t = 0; t < 4; t++) {
    ctx.fillStyle = '#ffd54f';
    ctx.fillRect(cx - 8 + t * 5, by - 1.2, 1, 3);
  }

  // Howdah (wooden platform on top)
  ctx.fillStyle = '#5d4037';
  ctx.fillRect(cx - 8, by - 12, 16, 7);
  ctx.fillStyle = '#795548';
  ctx.fillRect(cx - 7, by - 11, 14, 5);
  // Railing
  ctx.strokeStyle = '#8d6e63'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(cx - 8, by - 12); ctx.lineTo(cx - 8, by - 16); ctx.lineTo(cx + 8, by - 16); ctx.lineTo(cx + 8, by - 12); ctx.stroke();
  // Railing posts
  ctx.fillStyle = '#8d6e63';
  ctx.fillRect(cx - 8, by - 16, 1.5, 5);
  ctx.fillRect(cx + 6.5, by - 16, 1.5, 5);

  // Rider with spear in howdah
  ctx.fillStyle = '#dbb896';
  ctx.beginPath(); ctx.arc(cx, by - 18, 3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#8b1a1a';
  ctx.fillRect(cx - 2, by - 15, 4, 4);
  ctx.fillStyle = '#555';
  ctx.fillRect(cx - 2, by - 20, 4, 2); // helmet
  // Spear
  ctx.fillStyle = '#5d4037'; ctx.fillRect(cx + 3, by - 26, 1.5, 14);
  ctx.fillStyle = '#aaa';
  ctx.beginPath(); ctx.moveTo(cx + 3, by - 26); ctx.lineTo(cx + 5, by - 26); ctx.lineTo(cx + 4, by - 30); ctx.closePath(); ctx.fill();
}

// --- DRAGON RIDER (replaces helicopter) ---
function drawDragonRider(cx, by, def) {
  const wingFlap = Math.sin(animFrame * 0.15) * 5;

  // Wings (bat-like, behind body)
  ctx.fillStyle = def.dark;
  // Left wing
  ctx.beginPath();
  ctx.moveTo(cx - 4, by - 4);
  ctx.quadraticCurveTo(cx - 18, by - 12 - wingFlap, cx - 22, by - 6 - wingFlap);
  ctx.quadraticCurveTo(cx - 16, by - 2, cx - 8, by + 2);
  ctx.closePath();
  ctx.fill();
  // Right wing
  ctx.beginPath();
  ctx.moveTo(cx + 4, by - 4);
  ctx.quadraticCurveTo(cx + 18, by - 12 + wingFlap, cx + 22, by - 6 + wingFlap);
  ctx.quadraticCurveTo(cx + 16, by - 2, cx + 8, by + 2);
  ctx.closePath();
  ctx.fill();
  // Wing membrane lines
  ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.moveTo(cx - 5, by - 3); ctx.lineTo(cx - 18, by - 8 - wingFlap * 0.7); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx - 6, by - 1); ctx.lineTo(cx - 15, by - 3 - wingFlap * 0.4); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 5, by - 3); ctx.lineTo(cx + 18, by - 8 + wingFlap * 0.7); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 6, by - 1); ctx.lineTo(cx + 15, by - 3 + wingFlap * 0.4); ctx.stroke();

  // Dragon body (reptilian)
  const dragonGrad = ctx.createLinearGradient(cx - 8, by - 4, cx + 8, by + 6);
  dragonGrad.addColorStop(0, '#2a5a3a'); dragonGrad.addColorStop(0.5, '#1a4a2a'); dragonGrad.addColorStop(1, '#0a3a1a');
  ctx.fillStyle = dragonGrad;
  ctx.beginPath(); ctx.ellipse(cx, by + 2, 10, 6, 0, 0, Math.PI * 2); ctx.fill();
  // Scales
  ctx.fillStyle = 'rgba(0,60,20,0.2)';
  for (let si = 0; si < 5; si++) {
    ctx.beginPath(); ctx.arc(cx - 6 + si * 3, by + 1, 2, 0, Math.PI); ctx.fill();
  }
  // Dragon head
  ctx.fillStyle = '#1a4a2a';
  ctx.beginPath(); ctx.ellipse(cx + 10, by - 2, 5, 4, 0.2, 0, Math.PI * 2); ctx.fill();
  // Snout
  ctx.fillStyle = '#1a4a2a';
  ctx.beginPath();
  ctx.moveTo(cx + 14, by - 3);
  ctx.lineTo(cx + 18, by - 1);
  ctx.lineTo(cx + 14, by + 1);
  ctx.closePath();
  ctx.fill();
  // Glowing red/orange eyes
  ctx.fillStyle = '#ff4400';
  ctx.beginPath(); ctx.arc(cx + 12, by - 4, 1.2, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = 'rgba(255,100,0,0.4)';
  ctx.beginPath(); ctx.arc(cx + 12, by - 4, 2.5, 0, Math.PI * 2); ctx.fill();
  // Horns
  ctx.fillStyle = '#3a2a1a';
  ctx.beginPath(); ctx.moveTo(cx + 9, by - 5); ctx.lineTo(cx + 7, by - 10); ctx.lineTo(cx + 10, by - 5); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(cx + 12, by - 5); ctx.lineTo(cx + 11, by - 10); ctx.lineTo(cx + 13, by - 5); ctx.closePath(); ctx.fill();

  // Fire breath particles
  const breathPhase = animFrame * 0.2;
  ctx.fillStyle = 'rgba(255,120,0,0.5)';
  ctx.beginPath(); ctx.arc(cx + 19 + Math.sin(breathPhase) * 2, by - 1, 2, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = 'rgba(255,200,0,0.4)';
  ctx.beginPath(); ctx.arc(cx + 21 + Math.sin(breathPhase + 1) * 1.5, by, 1.5, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = 'rgba(255,80,0,0.3)';
  ctx.beginPath(); ctx.arc(cx + 23 + Math.sin(breathPhase + 2) * 2, by + 1, 1, 0, Math.PI * 2); ctx.fill();

  // Tail trailing behind
  ctx.strokeStyle = '#1a4a2a'; ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(cx - 10, by + 3);
  ctx.quadraticCurveTo(cx - 16, by + 5, cx - 20, by + 2);
  ctx.stroke();
  ctx.fillStyle = '#1a4a2a';
  ctx.beginPath(); ctx.moveTo(cx - 20, by + 1); ctx.lineTo(cx - 23, by + 2); ctx.lineTo(cx - 20, by + 3); ctx.closePath(); ctx.fill();

  // Dragon legs/claws
  ctx.fillStyle = '#1a4a2a';
  ctx.fillRect(cx - 6, by + 6, 3, 5); ctx.fillRect(cx + 3, by + 6, 3, 5);
  ctx.fillStyle = '#333';
  ctx.fillRect(cx - 7, by + 10, 4, 1.5); ctx.fillRect(cx + 2, by + 10, 4, 1.5);

  // Rider mounted on top
  ctx.fillStyle = '#dbb896';
  ctx.beginPath(); ctx.arc(cx, by - 10, 3.5, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = def.color;
  ctx.fillRect(cx - 3, by - 7, 6, 5);
  ctx.fillStyle = '#333';
  ctx.fillRect(cx - 3, by - 13, 6, 2); // helmet
  // Eyes
  ctx.fillStyle = '#fff'; ctx.fillRect(cx - 1.5, by - 11, 1.2, 1); ctx.fillRect(cx + 0.5, by - 11, 1.2, 1);
}

// --- DARK MAGE (replaces mad_scientist) ---
function drawDarkMage(cx, by, def) {
  // Legs hidden by robes
  ctx.fillStyle = '#1a1030'; ctx.fillRect(cx - 4, by + 4, 3, 7); ctx.fillRect(cx + 1, by + 4, 3, 7);

  // Flowing purple/dark robes
  const robeGrad = ctx.createLinearGradient(cx - 8, by - 6, cx + 8, by + 8);
  robeGrad.addColorStop(0, '#4a148c'); robeGrad.addColorStop(0.4, def.color); robeGrad.addColorStop(1, def.dark);
  ctx.fillStyle = robeGrad;
  ctx.fillRect(cx - 8, by - 6, 16, 14);
  // Robe hem flare
  ctx.beginPath();
  ctx.moveTo(cx - 8, by + 8);
  ctx.lineTo(cx - 10, by + 10);
  ctx.lineTo(cx + 10, by + 10);
  ctx.lineTo(cx + 8, by + 8);
  ctx.closePath();
  ctx.fill();
  // Robe inner lining (darker)
  ctx.fillStyle = '#1a0a30';
  ctx.fillRect(cx - 2, by - 4, 4, 12);
  // Robe fold lines
  ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.moveTo(cx - 5, by - 4); ctx.lineTo(cx - 6, by + 8); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 5, by - 4); ctx.lineTo(cx + 6, by + 8); ctx.stroke();

  // Robe trim (gold runes)
  ctx.fillStyle = '#b89840';
  ctx.fillRect(cx - 8, by + 6, 16, 0.8);
  // Rune symbols on trim
  ctx.font = '4px serif'; ctx.textAlign = 'center';
  ctx.fillStyle = '#d4ae3a';
  ctx.fillText('~*~', cx, by + 6.5);

  // Arms in robes (wide sleeves)
  ctx.fillStyle = def.color;
  ctx.fillRect(cx - 12, by - 4, 5, 8); ctx.fillRect(cx + 7, by - 4, 5, 8);
  // Sleeve flare
  ctx.beginPath();
  ctx.moveTo(cx - 12, by + 3);
  ctx.lineTo(cx - 14, by + 5);
  ctx.lineTo(cx - 8, by + 5);
  ctx.lineTo(cx - 8, by + 3);
  ctx.closePath();
  ctx.fill();
  // Hands (pale)
  ctx.fillStyle = '#c8b898';
  ctx.fillRect(cx - 12, by + 3, 3, 2); ctx.fillRect(cx + 9, by + 3, 3, 2);

  // Glowing staff with crystal/orb top (right hand)
  ctx.fillStyle = '#5d4037'; ctx.fillRect(cx + 10, by - 14, 1.5, 18);
  // Crystal orb
  const orbGlow = 0.5 + Math.sin(animFrame * 0.12) * 0.3;
  ctx.fillStyle = 'rgba(160,80,255,' + orbGlow + ')';
  ctx.beginPath(); ctx.arc(cx + 11, by - 16, 4, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = 'rgba(200,150,255,' + (orbGlow * 0.6) + ')';
  ctx.beginPath(); ctx.arc(cx + 11, by - 16, 2, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.beginPath(); ctx.arc(cx + 10, by - 17, 1, 0, Math.PI * 2); ctx.fill();
  // Staff glow aura
  ctx.fillStyle = 'rgba(160,80,255,0.1)';
  ctx.beginPath(); ctx.arc(cx + 11, by - 16, 8, 0, Math.PI * 2); ctx.fill();

  // Arcane symbols orbiting (rotating animated)
  const orbAngle = animFrame * 0.04;
  ctx.fillStyle = 'rgba(200,100,255,0.5)';
  for (let si = 0; si < 3; si++) {
    const sa = orbAngle + si * (Math.PI * 2 / 3);
    const ox = cx + Math.cos(sa) * 12;
    const oy = by - 2 + Math.sin(sa) * 6;
    ctx.font = '6px serif';
    ctx.fillText(['*', '+', 'o'][si], ox, oy);
  }

  // Book at belt
  ctx.fillStyle = '#5d4037'; ctx.fillRect(cx - 6, by + 3, 3, 2);
  ctx.fillStyle = '#f0e0c0'; ctx.fillRect(cx - 5.5, by + 3.2, 2, 1.6);

  // Head (pale with glowing eyes)
  ctx.fillStyle = '#c8b898'; ctx.fillRect(cx - 2, by - 9, 4, 3);
  const headGrad = ctx.createRadialGradient(cx, by - 13, 1, cx, by - 12, 5.5);
  headGrad.addColorStop(0, '#e0d0c0'); headGrad.addColorStop(1, '#c0b0a0');
  ctx.fillStyle = headGrad;
  ctx.beginPath(); ctx.arc(cx, by - 12, 5, 0, Math.PI * 2); ctx.fill();
  // Glowing eyes
  const eyeGlow = 0.6 + Math.sin(animFrame * 0.15) * 0.3;
  ctx.fillStyle = 'rgba(200,100,255,' + eyeGlow + ')';
  ctx.beginPath(); ctx.arc(cx - 2, by - 12.5, 1.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 2, by - 12.5, 1.5, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(cx - 2, by - 12.5, 0.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 2, by - 12.5, 0.5, 0, Math.PI * 2); ctx.fill();
  // Gaunt features
  ctx.fillStyle = 'rgba(0,0,0,0.08)';
  ctx.beginPath(); ctx.arc(cx - 3, by - 11, 1.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 3, by - 11, 1.5, 0, Math.PI * 2); ctx.fill();
  // Thin mouth
  ctx.fillStyle = 'rgba(100,50,80,0.3)'; ctx.fillRect(cx - 1.5, by - 9.5, 3, 0.5);
  // Tall pointed hood
  ctx.fillStyle = def.dark;
  ctx.beginPath(); ctx.arc(cx, by - 16, 6, Math.PI, 0); ctx.fill();
  ctx.fillRect(cx - 6, by - 17, 12, 3);
  ctx.fillStyle = def.color;
  ctx.beginPath();
  ctx.moveTo(cx, by - 26);
  ctx.lineTo(cx + 5, by - 15);
  ctx.lineTo(cx - 5, by - 15);
  ctx.closePath(); ctx.fill();
  // Hood trim
  ctx.fillStyle = '#b89840'; ctx.fillRect(cx - 5, by - 15, 10, 0.8);
}

// --- TROLL (replaces mutant) ---
function drawTroll(cx, by, def) {
  // Large feet (bare)
  ctx.fillStyle = '#4a6a2a';
  ctx.fillRect(cx - 7, by + 7, 6, 4); ctx.fillRect(cx + 1, by + 7, 6, 4);
  // Toes
  ctx.fillStyle = '#3a5a1a';
  ctx.fillRect(cx - 8, by + 10, 2, 1.5); ctx.fillRect(cx - 6, by + 10, 2, 1.5);
  ctx.fillRect(cx + 5, by + 10, 2, 1.5); ctx.fillRect(cx + 7, by + 10, 2, 1.5);

  // Thick legs
  ctx.fillStyle = '#5a7a30';
  ctx.fillRect(cx - 6, by + 2, 5, 6); ctx.fillRect(cx + 1, by + 2, 5, 6);

  // Loincloth/furs
  ctx.fillStyle = '#5d4037';
  ctx.fillRect(cx - 7, by + 1, 14, 3);
  ctx.fillStyle = '#795548';
  ctx.fillRect(cx - 4, by + 2, 8, 2);
  // Fur tufts
  ctx.fillStyle = '#6d4c41';
  ctx.fillRect(cx - 6, by + 3, 2, 1.5); ctx.fillRect(cx + 4, by + 3, 2, 1.5);

  // Massive torso (green/gray)
  const torsoGrad = ctx.createLinearGradient(cx - 10, by - 10, cx + 10, by + 4);
  torsoGrad.addColorStop(0, '#6a8a3a'); torsoGrad.addColorStop(0.4, def.color); torsoGrad.addColorStop(1, def.dark);
  ctx.fillStyle = torsoGrad;
  ctx.fillRect(cx - 10, by - 10, 20, 14);
  // Belly
  ctx.fillStyle = 'rgba(100,140,60,0.3)';
  ctx.beginPath(); ctx.ellipse(cx, by - 2, 7, 5, 0, 0, Math.PI * 2); ctx.fill();
  // Mossy shoulders
  ctx.fillStyle = 'rgba(80,120,40,0.4)';
  ctx.beginPath(); ctx.ellipse(cx - 8, by - 8, 4, 3, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx + 8, by - 8, 4, 3, 0, 0, Math.PI * 2); ctx.fill();
  // Moss detail
  ctx.fillStyle = 'rgba(60,100,30,0.3)';
  ctx.fillRect(cx - 9, by - 7, 3, 1); ctx.fillRect(cx + 7, by - 7, 3, 1);

  // Muscular arms (very thick)
  ctx.fillStyle = def.color;
  ctx.fillRect(cx - 15, by - 8, 6, 12); ctx.fillRect(cx + 9, by - 8, 6, 12);
  // Fists
  ctx.fillStyle = def.dark;
  ctx.fillRect(cx - 15, by + 3, 5, 4); ctx.fillRect(cx + 10, by + 3, 5, 4);

  // Crude wooden club (right hand)
  ctx.fillStyle = '#5d4037';
  ctx.save(); ctx.translate(cx + 13, by - 2); ctx.rotate(-0.3);
  ctx.fillRect(-2, -12, 4, 16);
  // Club knot
  ctx.fillStyle = '#4e342e';
  ctx.beginPath(); ctx.arc(0, -10, 3.5, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#5d4037';
  ctx.beginPath(); ctx.arc(0, -10, 2, 0, Math.PI * 2); ctx.fill();
  ctx.restore();

  // Small head (heavy brow)
  ctx.fillStyle = '#5a7a30';
  ctx.beginPath(); ctx.arc(cx, by - 14, 5, 0, Math.PI * 2); ctx.fill();
  // Heavy brow ridge
  ctx.fillStyle = '#4a6a20';
  ctx.fillRect(cx - 5, by - 17, 10, 2.5);
  // Small angry eyes
  ctx.fillStyle = '#ffff00';
  ctx.beginPath(); ctx.arc(cx - 2, by - 15, 1.2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 2, by - 15, 1.2, 0, Math.PI * 2); ctx.fill();
  // Eye glow
  const trollGlow = 0.3 + Math.sin(animFrame * 0.15) * 0.2;
  ctx.fillStyle = 'rgba(255,255,0,' + trollGlow + ')';
  ctx.beginPath(); ctx.arc(cx, by - 15, 5, 0, Math.PI * 2); ctx.fill();
  // Pupils
  ctx.fillStyle = '#111';
  ctx.beginPath(); ctx.arc(cx - 2, by - 15, 0.6, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 2, by - 15, 0.6, 0, Math.PI * 2); ctx.fill();

  // Underbite with large fangs
  ctx.fillStyle = '#4a6a20';
  ctx.fillRect(cx - 4, by - 11, 8, 3);
  // Lower jaw (protruding)
  ctx.fillStyle = '#5a7a30';
  ctx.beginPath();
  ctx.moveTo(cx - 5, by - 11);
  ctx.quadraticCurveTo(cx, by - 9, cx + 5, by - 11);
  ctx.lineTo(cx + 4, by - 10);
  ctx.quadraticCurveTo(cx, by - 8, cx - 4, by - 10);
  ctx.closePath(); ctx.fill();
  // Fangs protruding upward
  ctx.fillStyle = '#f0e8d0';
  ctx.beginPath();
  ctx.moveTo(cx - 3, by - 11);
  ctx.lineTo(cx - 2.5, by - 14);
  ctx.lineTo(cx - 2, by - 11);
  ctx.closePath(); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(cx + 2, by - 11);
  ctx.lineTo(cx + 2.5, by - 14);
  ctx.lineTo(cx + 3, by - 11);
  ctx.closePath(); ctx.fill();
}

// -----------------------------------------------
//  SECTION 11: ENEMY DISPATCHER
// -----------------------------------------------
function drawEnemy(e, sx, sy) {
  const def = ENEMY_TYPES[e.type];
  const cx = sx, cy = sy;
  const bob = Math.sin(animFrame * 0.12 + e.x * 3) * 1;

  // Danger glow for strong enemies
  const myPow = effectivePower(player.army, e.str, e.type);
  if (e.str > myPow * 0.8) {
    const dangerPulse = 0.1 + Math.sin(animFrame * 0.12 + e.x) * 0.06;
    const dGrad = ctx.createRadialGradient(cx, cy, 3, cx, cy, 28);
    dGrad.addColorStop(0, 'rgba(255,40,40,' + (dangerPulse + 0.04) + ')');
    dGrad.addColorStop(0.5, 'rgba(255,60,30,' + dangerPulse + ')');
    dGrad.addColorStop(1, 'rgba(200,30,30,0)');
    ctx.fillStyle = dGrad;
    ctx.fillRect(cx - 30, cy - 30, 60, 60);
  }

  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.beginPath(); ctx.ellipse(cx + 3, cy + 5, 10, 4, 0.2, 0, Math.PI * 2); ctx.fill();

  const by = cy - 10 + bob;

  switch (e.type) {
    case 'bandit': drawBandit(cx, by, def); break;
    case 'raider': drawRaider(cx, by, def); break;
    case 'enemy_archer': drawEnemyArcher(cx, by, def); break;
    case 'war_elephant': drawWarElephant(cx, by, def); break;
    case 'dragon_rider': drawDragonRider(cx, by, def); break;
    case 'dark_mage': drawDarkMage(cx, by, def); break;
    case 'troll': drawTroll(cx, by, def); break;
  }

  drawLabel(cx, cy + 14, e.str, def.color);
  ctx.fillStyle = def.color; ctx.font = '8px sans-serif'; ctx.textAlign = 'center';
  ctx.globalAlpha = 0.7; ctx.fillText(def.name, cx, cy + 24); ctx.globalAlpha = 1;
}

// -----------------------------------------------
//  SECTION 12: CASTLE SPRITES
// -----------------------------------------------

// Enemy castle (dark red/black theme, skull banners)
function drawCastle(sx, sy, str) {
  const cx = sx, cy = sy;
  const fortH = 30;

  // Ground shadow
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.beginPath(); ctx.ellipse(cx + 4, cy + 6, 20, 8, 0.2, 0, Math.PI * 2); ctx.fill();

  // Main keep - right wall
  ctx.fillStyle = '#4a2020';
  ctx.beginPath();
  ctx.moveTo(cx + TILE_W * 0.38, cy - fortH);
  ctx.lineTo(cx, cy - fortH + TILE_H * 0.38);
  ctx.lineTo(cx, cy + TILE_H * 0.38);
  ctx.lineTo(cx + TILE_W * 0.38, cy);
  ctx.closePath(); ctx.fill();
  // Left wall
  ctx.fillStyle = '#3a1515';
  ctx.beginPath();
  ctx.moveTo(cx - TILE_W * 0.38, cy - fortH);
  ctx.lineTo(cx, cy - fortH + TILE_H * 0.38);
  ctx.lineTo(cx, cy + TILE_H * 0.38);
  ctx.lineTo(cx - TILE_W * 0.38, cy);
  ctx.closePath(); ctx.fill();
  // Roof (top)
  ctx.fillStyle = '#5a2a2a';
  ctx.beginPath();
  ctx.moveTo(cx, cy - fortH - TILE_H * 0.38);
  ctx.lineTo(cx + TILE_W * 0.38, cy - fortH);
  ctx.lineTo(cx, cy - fortH + TILE_H * 0.38);
  ctx.lineTo(cx - TILE_W * 0.38, cy - fortH);
  ctx.closePath(); ctx.fill();

  // Stone block detail on walls
  ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.lineWidth = 0.4;
  for (let row = 0; row < 4; row++) {
    const ry = cy - fortH + 5 + row * 7;
    ctx.beginPath(); ctx.moveTo(cx + 2, ry); ctx.lineTo(cx + TILE_W * 0.35, ry - 2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx - 2, ry); ctx.lineTo(cx - TILE_W * 0.35, ry - 2); ctx.stroke();
  }

  // Crenellated battlements
  ctx.fillStyle = '#4a2020';
  for (let i = 0; i < 4; i++) {
    ctx.fillRect(cx - 14 + i * 7, cy - fortH - 7, 4, 5);
  }
  // Merlon gaps
  ctx.fillStyle = '#2a0a0a';
  for (let i = 0; i < 3; i++) {
    ctx.fillRect(cx - 10 + i * 7, cy - fortH - 5, 3, 3);
  }

  // Arched gatehouse with portcullis
  ctx.fillStyle = '#1a0808';
  ctx.beginPath(); ctx.arc(cx, cy - 10, 4, Math.PI, 0); ctx.fill();
  ctx.fillRect(cx - 4, cy - 10, 8, 12);
  // Portcullis bars
  ctx.strokeStyle = '#555'; ctx.lineWidth = 0.6;
  for (let gi = 0; gi < 3; gi++) {
    ctx.beginPath(); ctx.moveTo(cx - 3 + gi * 3, cy - 10); ctx.lineTo(cx - 3 + gi * 3, cy + 2); ctx.stroke();
  }
  ctx.beginPath(); ctx.moveTo(cx - 4, cy - 6); ctx.lineTo(cx + 4, cy - 6); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx - 4, cy - 3); ctx.lineTo(cx + 4, cy - 3); ctx.stroke();

  // Windows with warm glow
  ctx.fillStyle = '#ff8800'; ctx.shadowColor = '#ff6600'; ctx.shadowBlur = 5;
  ctx.fillRect(cx + 5, cy - fortH + 10, 3, 3);
  ctx.fillRect(cx + 13, cy - fortH + 8, 3, 3);
  ctx.fillRect(cx - 8, cy - fortH + 10, 3, 3);
  ctx.fillRect(cx - 15, cy - fortH + 8, 3, 3);
  ctx.shadowBlur = 0;

  // Corner turrets
  ctx.fillStyle = '#3a1515';
  ctx.fillRect(cx - 18, cy - fortH - 2, 5, fortH + 2);
  ctx.fillRect(cx + 14, cy - fortH - 2, 5, fortH + 2);
  // Turret tops (pointed)
  ctx.fillStyle = '#2a0a0a';
  ctx.beginPath(); ctx.moveTo(cx - 18, cy - fortH - 2); ctx.lineTo(cx - 15.5, cy - fortH - 8); ctx.lineTo(cx - 13, cy - fortH - 2); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(cx + 14, cy - fortH - 2); ctx.lineTo(cx + 16.5, cy - fortH - 8); ctx.lineTo(cx + 19, cy - fortH - 2); ctx.closePath(); ctx.fill();

  // Torches
  const flicker1 = Math.sin(animFrame * 0.2) * 2;
  const flicker2 = Math.sin(animFrame * 0.25 + 1) * 2;
  ctx.fillStyle = '#ffcc02'; ctx.shadowColor = '#ff8800'; ctx.shadowBlur = 5;
  ctx.fillRect(cx - 10, cy - 12, 2, 3);
  ctx.fillStyle = '#ff6600';
  ctx.beginPath(); ctx.moveTo(cx - 10, cy - 13); ctx.lineTo(cx - 9, cy - 18 + flicker1); ctx.lineTo(cx - 8, cy - 13); ctx.fill();
  ctx.fillStyle = '#ffcc02';
  ctx.fillRect(cx + 8, cy - 12, 2, 3);
  ctx.fillStyle = '#ff6600';
  ctx.beginPath(); ctx.moveTo(cx + 8, cy - 13); ctx.lineTo(cx + 9, cy - 18 + flicker2); ctx.lineTo(cx + 10, cy - 13); ctx.fill();
  ctx.shadowBlur = 0;

  // Flag pole + dark red flag with skull hint
  ctx.strokeStyle = '#555'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(cx, cy - fortH - 8); ctx.lineTo(cx, cy - fortH - 28); ctx.stroke();
  const flagW = Math.sin(animFrame * 0.12) * 2;
  ctx.fillStyle = '#8b1a1a';
  ctx.beginPath();
  ctx.moveTo(cx + 1, cy - fortH - 28); ctx.lineTo(cx + 10 + flagW, cy - fortH - 26);
  ctx.lineTo(cx + 10 + flagW, cy - fortH - 20); ctx.lineTo(cx + 1, cy - fortH - 18);
  ctx.closePath(); ctx.fill();
  // Skull on flag
  ctx.fillStyle = '#e0d0c0';
  ctx.beginPath(); ctx.arc(cx + 5 + flagW * 0.5, cy - fortH - 23, 2, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#1a0808';
  ctx.fillRect(cx + 4 + flagW * 0.5, cy - fortH - 24, 0.8, 0.8);
  ctx.fillRect(cx + 5.5 + flagW * 0.5, cy - fortH - 24, 0.8, 0.8);

  // Castle glow on ground
  const castleGlow = ctx.createRadialGradient(cx, cy, 6, cx, cy, 38);
  castleGlow.addColorStop(0, 'rgba(255,100,50,0.06)');
  castleGlow.addColorStop(1, 'rgba(255,100,50,0)');
  ctx.fillStyle = castleGlow;
  ctx.fillRect(cx - 40, cy - 40, 80, 80);

  drawLabel(cx, cy + 18, str, '#ff8a65');
}

// Player castle (blue/silver, golden flags)
function drawPlayerCastle(sx, sy, castle) {
  const cx = sx, cy = sy;
  const fortH = castle.isHome ? 34 : 28;
  // Wall colors by upgrade level
  const wLvl = castle.walls || 0;
  const wallPalette = [
    { top: '#5d4037', left: '#4e342e', right: '#3e2723' },  // Palisade (wood)
    { top: '#607d8b', left: '#546e7a', right: '#455a64' },  // Stone Ramparts
    { top: '#78909c', left: '#607d8b', right: '#546e7a' },  // Fortified Keep
    { top: '#90a4ae', left: '#78909c', right: '#607d8b' },  // Grand Fortress
  ];
  const wp = wallPalette[Math.min(wLvl, 3)];

  // Ground shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.ellipse(cx + 4, cy + 6, castle.isHome ? 24 : 18, castle.isHome ? 9 : 7, 0.2, 0, Math.PI * 2); ctx.fill();

  // Right wall
  ctx.fillStyle = wp.top;
  ctx.beginPath();
  ctx.moveTo(cx + TILE_W * 0.38, cy - fortH);
  ctx.lineTo(cx, cy - fortH + TILE_H * 0.38);
  ctx.lineTo(cx, cy + TILE_H * 0.38);
  ctx.lineTo(cx + TILE_W * 0.38, cy);
  ctx.closePath(); ctx.fill();
  // Left wall
  ctx.fillStyle = wp.left;
  ctx.beginPath();
  ctx.moveTo(cx - TILE_W * 0.38, cy - fortH);
  ctx.lineTo(cx, cy - fortH + TILE_H * 0.38);
  ctx.lineTo(cx, cy + TILE_H * 0.38);
  ctx.lineTo(cx - TILE_W * 0.38, cy);
  ctx.closePath(); ctx.fill();
  // Roof
  ctx.fillStyle = wp.right;
  ctx.beginPath();
  ctx.moveTo(cx, cy - fortH - TILE_H * 0.38);
  ctx.lineTo(cx + TILE_W * 0.38, cy - fortH);
  ctx.lineTo(cx, cy - fortH + TILE_H * 0.38);
  ctx.lineTo(cx - TILE_W * 0.38, cy - fortH);
  ctx.closePath(); ctx.fill();

  // Stone block detail (if stone level)
  if (wLvl >= 1) {
    ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 0.4;
    for (let row = 0; row < 4; row++) {
      const ry = cy - fortH + 5 + row * 7;
      ctx.beginPath(); ctx.moveTo(cx + 2, ry); ctx.lineTo(cx + TILE_W * 0.35, ry - 2); ctx.stroke();
    }
  }

  // Crenellated battlements
  ctx.fillStyle = wp.top;
  for (let i = 0; i < 4; i++) ctx.fillRect(cx - 14 + i * 7, cy - fortH - 7, 4, 5);

  // Corner turrets with pointed roofs
  ctx.fillStyle = wp.left;
  ctx.fillRect(cx - 18, cy - fortH - 2, 5, fortH + 2);
  ctx.fillRect(cx + 14, cy - fortH - 2, 5, fortH + 2);
  ctx.fillStyle = '#1565c0';
  ctx.beginPath(); ctx.moveTo(cx - 18, cy - fortH - 2); ctx.lineTo(cx - 15.5, cy - fortH - 10); ctx.lineTo(cx - 13, cy - fortH - 2); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(cx + 14, cy - fortH - 2); ctx.lineTo(cx + 16.5, cy - fortH - 10); ctx.lineTo(cx + 19, cy - fortH - 2); ctx.closePath(); ctx.fill();

  // Arched gatehouse
  ctx.fillStyle = '#1a2030';
  ctx.beginPath(); ctx.arc(cx, cy - 8, 3.5, Math.PI, 0); ctx.fill();
  ctx.fillRect(cx - 3.5, cy - 8, 7, 10);
  // Door (wooden with iron banding)
  ctx.fillStyle = '#4e342e';
  ctx.fillRect(cx - 2.5, cy - 6, 5, 8);
  ctx.strokeStyle = '#555'; ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.moveTo(cx - 2.5, cy - 3); ctx.lineTo(cx + 2.5, cy - 3); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx - 2.5, cy); ctx.lineTo(cx + 2.5, cy); ctx.stroke();

  // Windows (warm candlelight glow)
  ctx.fillStyle = '#ffcc66'; ctx.shadowColor = '#ff9900'; ctx.shadowBlur = 5;
  ctx.fillRect(cx + 5, cy - fortH + 10, 3, 3);
  ctx.fillRect(cx + 13, cy - fortH + 8, 3, 3);
  ctx.fillRect(cx - 8, cy - fortH + 10, 3, 3);
  ctx.fillRect(cx - 15, cy - fortH + 8, 3, 3);
  ctx.shadowBlur = 0;

  // Blue/golden torches
  const flicker1 = Math.sin(animFrame * 0.2) * 2;
  const flicker2 = Math.sin(animFrame * 0.25 + 1) * 2;
  ctx.fillStyle = '#64b5f6'; ctx.shadowColor = '#2196f3'; ctx.shadowBlur = 5;
  ctx.fillRect(cx - 10, cy - 12, 2, 3);
  ctx.fillStyle = '#42a5f5';
  ctx.beginPath(); ctx.moveTo(cx - 10, cy - 13); ctx.lineTo(cx - 9, cy - 18 + flicker1); ctx.lineTo(cx - 8, cy - 13); ctx.fill();
  ctx.fillStyle = '#64b5f6';
  ctx.fillRect(cx + 8, cy - 12, 2, 3);
  ctx.fillStyle = '#42a5f5';
  ctx.beginPath(); ctx.moveTo(cx + 8, cy - 13); ctx.lineTo(cx + 9, cy - 18 + flicker2); ctx.lineTo(cx + 10, cy - 13); ctx.fill();
  ctx.shadowBlur = 0;

  // Flag pole + golden/blue flag
  ctx.strokeStyle = '#bbb'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(cx, cy - fortH - 10); ctx.lineTo(cx, cy - fortH - 30); ctx.stroke();
  const flagW = Math.sin(animFrame * 0.12) * 2;
  ctx.fillStyle = castle.isHome ? '#ffd54f' : '#1e88e5';
  ctx.beginPath();
  ctx.moveTo(cx + 1, cy - fortH - 30); ctx.lineTo(cx + 11 + flagW, cy - fortH - 28);
  ctx.lineTo(cx + 11 + flagW, cy - fortH - 22); ctx.lineTo(cx + 1, cy - fortH - 20);
  ctx.closePath(); ctx.fill();
  // Heraldic symbol on flag
  if (castle.isHome) {
    ctx.fillStyle = '#1565c0';
    ctx.beginPath(); ctx.arc(cx + 6 + flagW * 0.5, cy - fortH - 25, 2, 0, Math.PI * 2); ctx.fill();
  }

  // Home castle: extra pennants on turrets
  if (castle.isHome) {
    const pfW = Math.sin(animFrame * 0.14 + 1) * 1.5;
    ctx.fillStyle = '#ffd54f';
    // Left turret pennant
    ctx.strokeStyle = '#b89840'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(cx - 15.5, cy - fortH - 10); ctx.lineTo(cx - 15.5, cy - fortH - 18); ctx.stroke();
    ctx.fillStyle = '#ffd54f';
    ctx.beginPath();
    ctx.moveTo(cx - 15, cy - fortH - 18); ctx.lineTo(cx - 10 + pfW, cy - fortH - 16);
    ctx.lineTo(cx - 15, cy - fortH - 14); ctx.closePath(); ctx.fill();
    // Right turret pennant
    ctx.beginPath(); ctx.moveTo(cx + 16.5, cy - fortH - 10); ctx.lineTo(cx + 16.5, cy - fortH - 18); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cx + 17, cy - fortH - 18); ctx.lineTo(cx + 22 + pfW, cy - fortH - 16);
    ctx.lineTo(cx + 17, cy - fortH - 14); ctx.closePath(); ctx.fill();

    // Golden glow
    const hGlow = ctx.createRadialGradient(cx, cy, 8, cx, cy, 50);
    hGlow.addColorStop(0, 'rgba(255,215,0,0.1)');
    hGlow.addColorStop(1, 'rgba(255,215,0,0)');
    ctx.fillStyle = hGlow;
    ctx.fillRect(cx - 52, cy - 52, 104, 104);
  }

  // Turret upgrades visible
  if (castle.turrets > 0) {
    ctx.fillStyle = '#90a4ae';
    ctx.fillRect(cx - 20, cy - fortH - 4, 4, 6);
    ctx.fillRect(cx + 16, cy - fortH - 4, 4, 6);
    if (castle.turrets >= 2) {
      ctx.fillStyle = '#78909c';
      ctx.fillRect(cx - 21, cy - fortH - 7, 6, 4);
      ctx.fillRect(cx + 15, cy - fortH - 7, 6, 4);
    }
  }

  // Label
  const garCount = TROOP_ORDER.reduce((s, t) => s + (castle.garrison[t] ? castle.garrison[t].length : 0), 0);
  const label = castle.isHome ? 'HOME' : 'Castle';
  drawLabel(cx, cy + 18, label + (garCount > 0 ? ' [' + garCount + ']' : ''), '#64b5f6');
}

// -----------------------------------------------
//  SECTION 13: CHEST, VOLUNTEER, SELLSWORD, SMITH
// -----------------------------------------------

// Ornate treasure chest
function drawChest(sx, sy, goldAmt) {
  const cx = sx, cy = sy;
  const sparkle = Math.sin(animFrame * 0.2) * 0.3 + 0.7;
  const chestH = 8;

  // Glow
  const chGlow = ctx.createRadialGradient(cx, cy, 3, cx, cy, 22);
  chGlow.addColorStop(0, 'rgba(255,200,50,' + (sparkle * 0.1) + ')');
  chGlow.addColorStop(1, 'rgba(200,150,30,0)');
  ctx.fillStyle = chGlow;
  ctx.fillRect(cx - 24, cy - 18, 48, 40);
  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.beginPath(); ctx.ellipse(cx + 2, cy + 4, 10, 4, 0.2, 0, Math.PI * 2); ctx.fill();

  // 3D chest box
  const bw = 10, bh = 6;
  // Top face (lid - wooden with gold trim)
  ctx.fillStyle = '#6d4c41';
  ctx.beginPath();
  ctx.moveTo(cx, cy - chestH - bh); ctx.lineTo(cx + bw, cy - chestH);
  ctx.lineTo(cx, cy - chestH + bh); ctx.lineTo(cx - bw, cy - chestH);
  ctx.closePath(); ctx.fill();
  // Lid highlight
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.beginPath();
  ctx.moveTo(cx, cy - chestH - bh); ctx.lineTo(cx + bw, cy - chestH);
  ctx.lineTo(cx, cy - chestH + bh); ctx.lineTo(cx - bw, cy - chestH);
  ctx.closePath(); ctx.fill();
  // Left face
  ctx.fillStyle = '#5d4037';
  ctx.beginPath();
  ctx.moveTo(cx - bw, cy - chestH); ctx.lineTo(cx, cy - chestH + bh);
  ctx.lineTo(cx, cy + bh); ctx.lineTo(cx - bw, cy);
  ctx.closePath(); ctx.fill();
  // Right face
  ctx.fillStyle = '#4e342e';
  ctx.beginPath();
  ctx.moveTo(cx + bw, cy - chestH); ctx.lineTo(cx, cy - chestH + bh);
  ctx.lineTo(cx, cy + bh); ctx.lineTo(cx + bw, cy);
  ctx.closePath(); ctx.fill();

  // Gold metal bands
  ctx.fillStyle = '#d4ae3a';
  ctx.fillRect(cx - bw + 1, cy - chestH, bw * 2 - 2, 1.5);
  ctx.fillRect(cx - bw + 1, cy - 2, bw * 2 - 2, 1.5);
  // Lock
  ctx.fillStyle = '#ffd54f'; ctx.shadowColor = 'rgba(255,213,79,' + sparkle + ')'; ctx.shadowBlur = 6;
  ctx.beginPath(); ctx.arc(cx, cy - chestH / 2, 2.5, 0, Math.PI * 2); ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#333'; ctx.fillRect(cx - 0.5, cy - chestH / 2 - 0.5, 1, 2);
  // Gem on lock
  ctx.fillStyle = '#e53935';
  ctx.beginPath(); ctx.arc(cx, cy - chestH / 2 - 0.5, 0.8, 0, Math.PI * 2); ctx.fill();

  // Sparkle orbits
  for (let s = 0; s < 3; s++) {
    const sa = Math.sin(animFrame * 0.18 + s * 2.1);
    const spx = cx + Math.cos(animFrame * 0.07 + s * 2.3) * (12 + s * 3);
    const spy = cy - 6 + Math.sin(animFrame * 0.09 + s * 1.7) * 8;
    if (sa > 0.3) {
      ctx.fillStyle = 'rgba(255,215,80,' + ((sa - 0.3) * 0.8) + ')';
      ctx.fillRect(spx - 1, spy - 1, 2, 2);
    }
  }
  drawLabel(cx, cy + 14, goldAmt + 'g', '#ffd54f');
}

// Volunteer (peasant with pitchfork - replaces ally)
function drawVolunteer(a, sx, sy) {
  const cx = sx, cy = sy;
  const bob = Math.sin(animFrame * 0.08 + a.x * 2) * 1;
  const td = TROOP_TYPES[a.troopType];

  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.ellipse(cx + 3, cy + 5, 9, 3, 0.2, 0, Math.PI * 2); ctx.fill();

  const by = cy - 10 + bob;

  // Simple peasant clothes
  ctx.fillStyle = '#5d4037'; ctx.fillRect(cx - 4, by + 3, 3, 7); ctx.fillRect(cx + 1, by + 3, 3, 7);
  ctx.fillStyle = '#8d6e63'; ctx.fillRect(cx - 6, by - 5, 12, 10);
  ctx.fillStyle = '#a1887f'; ctx.fillRect(cx - 5, by - 4, 10, 3);
  // Arms
  ctx.fillStyle = '#8d6e63'; ctx.fillRect(cx - 9, by - 3, 3, 7); ctx.fillRect(cx + 6, by - 3, 3, 7);
  // Hands
  ctx.fillStyle = '#dbb896'; ctx.fillRect(cx - 9, by + 3, 2, 2); ctx.fillRect(cx + 7, by + 3, 2, 2);
  // Head
  ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(cx, by - 10, 5, 0, Math.PI * 2); ctx.fill();
  // Happy eyes
  ctx.fillStyle = '#111'; ctx.fillRect(cx - 3, by - 11, 1, 1); ctx.fillRect(cx + 2, by - 11, 1, 1);
  // Smile
  ctx.strokeStyle = '#111'; ctx.lineWidth = 0.8;
  ctx.beginPath(); ctx.arc(cx, by - 8, 3, 0.2, Math.PI - 0.2); ctx.stroke();
  // Simple hat
  ctx.fillStyle = '#795548';
  ctx.beginPath(); ctx.arc(cx, by - 14, 4, Math.PI, 0); ctx.fill();
  ctx.fillRect(cx - 6, by - 14, 12, 1.5);

  // Pitchfork
  ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(cx + 8, by - 18); ctx.lineTo(cx + 8, by + 1); ctx.stroke();
  // Tines
  ctx.strokeStyle = '#777'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(cx + 6, by - 18); ctx.lineTo(cx + 6, by - 14); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 8, by - 20); ctx.lineTo(cx + 8, by - 14); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 10, by - 18); ctx.lineTo(cx + 10, by - 14); ctx.stroke();

  // Green flag
  const flagWave = Math.sin(animFrame * 0.15) * 2;
  ctx.fillStyle = '#4caf50';
  ctx.beginPath();
  ctx.moveTo(cx - 7, by - 16); ctx.lineTo(cx - 14 + flagWave, by - 14);
  ctx.lineTo(cx - 14 + flagWave, by - 10); ctx.lineTo(cx - 7, by - 8); ctx.closePath(); ctx.fill();

  drawLabel(cx, cy + 14, a.count + ' ' + td.name, td.color);
}

// Sellsword camp (tent with crossed swords banner - replaces mercCamp)
function drawSellswordCamp(m, sx, sy) {
  const cx = sx, cy = sy;
  const bob = Math.sin(animFrame * 0.06 + m.x * 3) * 0.5;
  const by = cy - 8 + bob;
  const td = TROOP_TYPES[m.troopType];

  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.ellipse(cx + 3, cy + 5, 12, 4, 0.2, 0, Math.PI * 2); ctx.fill();

  // Tent (medieval style, striped)
  ctx.fillStyle = '#795548';
  ctx.beginPath(); ctx.moveTo(cx - 12, by + 8); ctx.lineTo(cx, by - 8);
  ctx.lineTo(cx + 12, by + 8); ctx.closePath(); ctx.fill();
  // Front
  ctx.fillStyle = '#8d6e63';
  ctx.beginPath(); ctx.moveTo(cx - 10, by + 8); ctx.lineTo(cx, by - 6);
  ctx.lineTo(cx + 10, by + 8); ctx.closePath(); ctx.fill();
  // Tent stripe
  ctx.fillStyle = '#6d4c41';
  ctx.beginPath(); ctx.moveTo(cx - 5, by + 8); ctx.lineTo(cx, by - 4);
  ctx.lineTo(cx + 5, by + 8); ctx.closePath(); ctx.fill();
  // Opening
  ctx.fillStyle = '#3e2723';
  ctx.beginPath(); ctx.moveTo(cx - 3, by + 8); ctx.lineTo(cx, by + 3);
  ctx.lineTo(cx + 3, by + 8); ctx.closePath(); ctx.fill();

  // Flag pole with crossed swords banner
  ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(cx + 10, by - 12); ctx.lineTo(cx + 10, by + 2); ctx.stroke();
  ctx.fillStyle = '#8b1a1a';
  const flagWave = Math.sin(animFrame * 0.15 + m.y) * 2;
  ctx.beginPath(); ctx.moveTo(cx + 11, by - 12); ctx.lineTo(cx + 19 + flagWave, by - 10);
  ctx.lineTo(cx + 19 + flagWave, by - 5); ctx.lineTo(cx + 11, by - 3); ctx.closePath(); ctx.fill();
  // Crossed swords symbol
  ctx.strokeStyle = '#ffd54f'; ctx.lineWidth = 0.8;
  ctx.beginPath(); ctx.moveTo(cx + 13, by - 10); ctx.lineTo(cx + 17 + flagWave * 0.5, by - 5); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 17 + flagWave * 0.5, by - 10); ctx.lineTo(cx + 13, by - 5); ctx.stroke();

  // Campfire nearby
  ctx.fillStyle = '#ff6600';
  const fireFlicker = Math.sin(animFrame * 0.3) * 1.5;
  ctx.beginPath(); ctx.moveTo(cx - 8, by + 7); ctx.lineTo(cx - 7, by + 3 + fireFlicker); ctx.lineTo(cx - 6, by + 7); ctx.fill();
  ctx.fillStyle = '#ffcc00';
  ctx.beginPath(); ctx.arc(cx - 7, by + 5 + fireFlicker * 0.5, 1, 0, Math.PI * 2); ctx.fill();

  // Armor rack
  ctx.fillStyle = '#555'; ctx.fillRect(cx - 12, by + 2, 1, 5);
  ctx.fillStyle = '#777'; ctx.fillRect(cx - 13, by + 1, 3, 1);

  // Gold coin
  ctx.fillStyle = '#ffd54f'; ctx.beginPath(); ctx.arc(cx - 8, by + 6, 2.5, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#ff8f00'; ctx.beginPath(); ctx.arc(cx - 8, by + 6, 1.5, 0, Math.PI * 2); ctx.fill();

  drawLabel(cx, cy + 16, m.count + ' ' + td.name + ' (' + m.cost + 'g)', '#ffd54f');
}

// Wandering smith (replaces overworldEngineer)
function drawWanderingSmith(eng, sx, sy) {
  const cx = sx, cy = sy;
  const bob = Math.sin(animFrame * 0.09 + eng.x * 4) * 1;
  const by = cy - 8 + bob;

  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.ellipse(cx + 2, cy + 4, 8, 3, 0.1, 0, Math.PI * 2); ctx.fill();

  // Boots
  ctx.fillStyle = '#5d4037'; ctx.fillRect(cx - 4, by + 8, 3, 3); ctx.fillRect(cx + 1, by + 8, 3, 3);
  // Pants
  ctx.fillStyle = '#4a3a2a'; ctx.fillRect(cx - 5, by + 3, 4, 6); ctx.fillRect(cx + 1, by + 3, 4, 6);
  // Orange leather apron
  ctx.fillStyle = '#e65100'; ctx.fillRect(cx - 5, by - 2, 10, 7);
  ctx.fillStyle = '#ff9800'; ctx.fillRect(cx - 4, by - 1, 8, 5);
  // Apron straps
  ctx.fillStyle = '#bf360c'; ctx.fillRect(cx - 3, by - 5, 1.5, 4); ctx.fillRect(cx + 2, by - 5, 1.5, 4);
  // Body
  ctx.fillStyle = '#5d4037'; ctx.fillRect(cx - 6, by - 5, 12, 4);
  // Arms
  ctx.fillStyle = '#c8a070'; ctx.fillRect(cx - 8, by - 3, 3, 6); ctx.fillRect(cx + 5, by - 3, 3, 6);
  // Hands
  ctx.fillStyle = '#c8a070'; ctx.fillRect(cx - 8, by + 2, 2, 2); ctx.fillRect(cx + 6, by + 2, 2, 2);

  // Head
  ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(cx, by - 7, 4, 0, Math.PI * 2); ctx.fill();
  // Bushy eyebrows
  ctx.fillStyle = '#4a3a2a'; ctx.fillRect(cx - 3, by - 9, 2.5, 0.8); ctx.fillRect(cx + 0.5, by - 9, 2.5, 0.8);
  // Eyes
  ctx.fillStyle = '#333'; ctx.fillRect(cx - 2, by - 8, 1.2, 1.2); ctx.fillRect(cx + 1, by - 8, 1.2, 1.2);
  // Smile
  ctx.strokeStyle = '#888'; ctx.lineWidth = 0.6;
  ctx.beginPath(); ctx.arc(cx, by - 5.5, 2, 0.2, Math.PI - 0.2); ctx.stroke();
  // Bald head / bandana
  ctx.fillStyle = '#8b1a1a'; ctx.fillRect(cx - 4, by - 10.5, 8, 2);

  // Hammer in hand (right)
  ctx.fillStyle = '#5d4037'; ctx.fillRect(cx + 7, by - 2, 1.5, 6);
  ctx.fillStyle = '#777'; ctx.fillRect(cx + 6, by - 3, 3.5, 2);
  ctx.fillStyle = 'rgba(255,255,255,0.15)'; ctx.fillRect(cx + 6.5, by - 3, 2, 0.5);

  // Portable anvil (small, beside)
  ctx.fillStyle = '#555'; ctx.fillRect(cx - 10, by + 4, 4, 2);
  ctx.fillStyle = '#666'; ctx.fillRect(cx - 9, by + 2, 2, 2);
  // Sparks
  const sparkT = animFrame * 0.2;
  if (Math.sin(sparkT) > 0.5) {
    ctx.fillStyle = '#ffab00';
    ctx.beginPath(); ctx.arc(cx - 8 + Math.sin(sparkT * 2) * 2, by + 1 - Math.abs(Math.sin(sparkT * 3)) * 3, 0.8, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#ff6600';
    ctx.beginPath(); ctx.arc(cx - 9 + Math.sin(sparkT * 1.5) * 1.5, by - Math.abs(Math.sin(sparkT * 2.5)) * 2, 0.5, 0, Math.PI * 2); ctx.fill();
  }

  ctx.font = 'bold 7px sans-serif'; ctx.textAlign = 'center';
  ctx.fillStyle = '#4caf50'; ctx.fillText('FREE', cx, cy + 15);
}

// -----------------------------------------------
//  SECTION 14: BUILDING DRAWING
// -----------------------------------------------
function drawBuilding(bld, sx, sy) {
  const def = BUILDING_DEFS[bld.type];
  if (!bld.built && !bld.upgrading) {
    // Under construction - scaffolding
    const pct = bld.buildProgress / bld.buildTarget;
    ctx.globalAlpha = 0.4 + pct * 0.6;
    drawBuildingByType(sx, sy, bld.type, 0);
    ctx.globalAlpha = 1;
    // Scaffolding
    ctx.strokeStyle = '#8d6e63'; ctx.lineWidth = 0.8;
    ctx.beginPath(); ctx.moveTo(sx - 10, sy); ctx.lineTo(sx - 10, sy - 20); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(sx + 10, sy); ctx.lineTo(sx + 10, sy - 20); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(sx - 10, sy - 10); ctx.lineTo(sx + 10, sy - 10); ctx.stroke();
    // Progress bar
    const bw = 24;
    ctx.fillStyle = '#333'; ctx.fillRect(sx - bw / 2, sy - 28, bw, 3);
    ctx.fillStyle = '#ffa726'; ctx.fillRect(sx - bw / 2, sy - 28, bw * pct, 3);
    return;
  }
  if (bld.upgrading) {
    drawBuildingByType(sx, sy, bld.type, bld.level);
    const pct = bld.buildProgress / bld.buildTarget;
    const bw = 24;
    ctx.fillStyle = '#333'; ctx.fillRect(sx - bw / 2, sy - 28, bw, 3);
    ctx.fillStyle = '#64b5f6'; ctx.fillRect(sx - bw / 2, sy - 28, bw * pct, 3);
    return;
  }
  drawBuildingByType(sx, sy, bld.type, bld.level);
  // Level star indicator
  if (bld.level > 0) {
    ctx.fillStyle = '#ffd54f';
    ctx.font = '8px sans-serif'; ctx.textAlign = 'center';
    let stars = '';
    for (let s = 0; s <= bld.level; s++) stars += '*';
    ctx.fillText(stars, sx, sy - 22);
  }
  // Worker dots
  if (def && def.levels && def.levels[0] && def.levels[0].workers > 0 && bld.workers > 0) {
    for (let i = 0; i < bld.workers; i++) {
      ctx.fillStyle = '#4caf50';
      ctx.beginPath(); ctx.arc(sx - 8 + i * 5, sy + 12, 2, 0, Math.PI * 2); ctx.fill();
    }
  }
}

function drawBuildingByType(sx, sy, type, level) {
  switch (type) {
    case 'house': drawHouse(sx, sy, level); break;
    case 'farm': drawFarm(sx, sy, level); break;
    case 'lumbermill': drawLumbermill(sx, sy, level); break;
    case 'quarry': drawQuarry(sx, sy, level); break;
    case 'mine': drawMine(sx, sy, level); break;
    case 'huntingLodge': drawHuntingLodge(sx, sy, level); break;
    case 'watchtower': drawWatchtower(sx, sy, level); break;
    case 'market': drawMarket(sx, sy, level); break;
    case 'warehouse': drawWarehouse(sx, sy, level); break;
    case 'hospital': drawHospital(sx, sy, level); break;
    case 'academy': drawAcademy(sx, sy, level); break;
    case 'temple': drawTemple(sx, sy, level); break;
    case 'port': drawPort(sx, sy, level); break;
    case 'blacksmith': drawBlacksmith(sx, sy, level); break;
    default: drawIsoBox(sx, sy, 14, '#888', '#666', '#555'); break;
  }
}

// --- Individual building draws (all enhanced medieval) ---

function drawHouse(sx, sy, lv) {
  const h = 16 + lv * 4;
  const colors = [['#8d6e63', '#6d4c41', '#5d4037'], ['#a1887f', '#795548', '#6d4c41'], ['#bcaaa4', '#8d6e63', '#795548']][lv] || ['#8d6e63', '#6d4c41', '#5d4037'];
  drawIsoBox(sx, sy, h, colors[0], colors[1], colors[2]);
  // Thatched roof
  ctx.fillStyle = '#8a7a3a';
  ctx.beginPath();
  ctx.moveTo(sx, sy - h - 8 - lv * 2);
  ctx.lineTo(sx + 18, sy - h + 2);
  ctx.lineTo(sx, sy - h + 8);
  ctx.lineTo(sx - 18, sy - h + 2);
  ctx.closePath(); ctx.fill();
  // Thatch texture
  ctx.strokeStyle = 'rgba(100,80,30,0.3)'; ctx.lineWidth = 0.4;
  for (let ti = 0; ti < 5; ti++) {
    ctx.beginPath(); ctx.moveTo(sx - 12 + ti * 6, sy - h + 1); ctx.lineTo(sx + ti * 1.5, sy - h - 5 - lv); ctx.stroke();
  }
  // Warm window
  ctx.fillStyle = '#ffeb3b'; ctx.fillRect(sx + 2, sy - h + 5, 2 + lv, 2 + lv);
  // Wooden door
  ctx.fillStyle = '#3e2723'; ctx.fillRect(sx - 2, sy - 5, 3, 6);
  ctx.fillStyle = '#b89840'; ctx.beginPath(); ctx.arc(sx, sy - 3, 0.5, 0, Math.PI * 2); ctx.fill();
  // Flower garden
  if (lv >= 1) {
    ctx.fillStyle = '#ff5252'; ctx.beginPath(); ctx.arc(sx - 8, sy + 4, 1, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#ffeb3b'; ctx.beginPath(); ctx.arc(sx - 6, sy + 5, 1, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#7c4dff'; ctx.beginPath(); ctx.arc(sx - 10, sy + 5, 0.8, 0, Math.PI * 2); ctx.fill();
  }
  // Smoke from chimney
  if (lv >= 1) {
    ctx.fillStyle = '#5d4037'; ctx.fillRect(sx + 8, sy - h - 6 - lv * 2, 3, 5);
    const smokeT = animFrame * 0.04;
    ctx.fillStyle = 'rgba(180,180,180,0.2)';
    ctx.beginPath(); ctx.arc(sx + 9, sy - h - 8 - lv * 2 - Math.sin(smokeT) * 2, 2, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = 'rgba(150,150,150,0.12)';
    ctx.beginPath(); ctx.arc(sx + 10, sy - h - 12 - lv * 2 - Math.sin(smokeT + 1) * 1.5, 1.5, 0, Math.PI * 2); ctx.fill();
  }
}

function drawFarm(sx, sy, lv) {
  // Tilled soil base
  ctx.fillStyle = '#4e342e';
  isoDiamondPath(sx, sy); ctx.fill();
  // Fence
  ctx.strokeStyle = '#6d4c41'; ctx.lineWidth = 0.8;
  ctx.beginPath(); ctx.moveTo(sx - 14, sy); ctx.lineTo(sx, sy - 7); ctx.lineTo(sx + 14, sy); ctx.stroke();
  // Crop rows
  ctx.fillStyle = '#66bb6a';
  const rows = 5 + lv * 2;
  for (let i = -rows; i < rows; i += 3) {
    const wave = Math.sin(animFrame * 0.03 + i) * 0.5;
    ctx.fillRect(sx + i, sy - 2 + wave, 1.5, 4 + lv);
    // Wheat tips
    if (lv >= 1) {
      ctx.fillStyle = '#ffd54f';
      ctx.fillRect(sx + i - 0.5, sy - 3 + wave, 2.5, 1);
      ctx.fillStyle = '#66bb6a';
    }
  }
  // Scarecrow
  if (lv >= 1) {
    ctx.fillStyle = '#5d4037'; ctx.fillRect(sx + 10, sy - 8, 1, 10);
    ctx.fillRect(sx + 7, sy - 6, 7, 1);
    ctx.fillStyle = '#ff9800'; ctx.beginPath(); ctx.arc(sx + 10, sy - 10, 2, 0, Math.PI * 2); ctx.fill();
  }
  // Barn
  if (lv >= 2) {
    drawIsoBox(sx + 12, sy - 3, 8, '#795548', '#5d4037', '#4e342e');
    ctx.fillStyle = '#c62828';
    ctx.beginPath(); ctx.moveTo(sx + 12, sy - 14); ctx.lineTo(sx + 16, sy - 11); ctx.lineTo(sx + 8, sy - 11); ctx.closePath(); ctx.fill();
  }
}

function drawLumbermill(sx, sy, lv) {
  const h = 14 + lv * 3;
  drawIsoBox(sx, sy, h, '#795548', '#5d4037', '#4e342e');
  // Sawblade (spinning)
  const angle = animFrame * 0.05;
  ctx.strokeStyle = '#90a4ae'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(sx + 8, sy - h - 2, 4 + lv, angle, angle + Math.PI); ctx.stroke();
  // Sawblade teeth
  for (let t = 0; t < 6; t++) {
    const ta = angle + t * (Math.PI / 3);
    ctx.fillStyle = '#78909c';
    ctx.beginPath();
    ctx.arc(sx + 8 + Math.cos(ta) * (4 + lv), sy - h - 2 + Math.sin(ta) * (4 + lv), 0.8, 0, Math.PI * 2);
    ctx.fill();
  }
  // Log pile
  ctx.fillStyle = '#8d6e63';
  ctx.fillRect(sx - 12, sy - 3, 6, 3);
  if (lv >= 1) { ctx.fillRect(sx - 12, sy - 6, 6, 3); }
  if (lv >= 2) { ctx.fillStyle = '#a1887f'; ctx.fillRect(sx - 12, sy - 9, 6, 3); }
  // Wood shavings
  ctx.fillStyle = 'rgba(160,140,100,0.3)';
  ctx.fillRect(sx + 5, sy + 2, 4, 1); ctx.fillRect(sx + 7, sy + 3, 3, 1);
}

function drawQuarry(sx, sy, lv) {
  // Open pit
  ctx.fillStyle = '#37474f';
  isoDiamondPath(sx, sy); ctx.fill();
  ctx.fillStyle = '#263238';
  ctx.beginPath(); ctx.ellipse(sx, sy, 8, 4, 0, 0, Math.PI * 2); ctx.fill();
  // Stone blocks
  const blocks = 3 + lv * 2;
  for (let i = 0; i < blocks; i++) {
    const bx = sx - 10 + (i % 3) * 8, bsy = sy - 4 - Math.floor(i / 3) * 6;
    ctx.fillStyle = i % 2 ? '#78909c' : '#607d8b';
    ctx.fillRect(bx, bsy, 6, 5);
    // Mortar lines
    ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 0.3;
    ctx.strokeRect(bx, bsy, 6, 5);
  }
  // Crane
  if (lv >= 1) {
    ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(sx + 10, sy); ctx.lineTo(sx + 10, sy - 16); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(sx + 10, sy - 16); ctx.lineTo(sx + 18, sy - 14); ctx.stroke();
    // Rope
    ctx.strokeStyle = '#8a7a5a'; ctx.lineWidth = 0.5;
    ctx.beginPath(); ctx.moveTo(sx + 16, sy - 13); ctx.lineTo(sx + 16, sy - 6); ctx.stroke();
    // Hanging block
    ctx.fillStyle = '#607d8b'; ctx.fillRect(sx + 14, sy - 7, 4, 3);
  }
  if (lv >= 2) {
    ctx.fillStyle = '#b0bec5'; ctx.beginPath(); ctx.arc(sx, sy - 18, 3, 0, Math.PI * 2); ctx.fill();
  }
}

function drawMine(sx, sy, lv) {
  drawIsoBox(sx, sy, 10, '#455a64', '#37474f', '#263238');
  // Mine entrance (dark tunnel)
  ctx.fillStyle = '#0a0a18';
  ctx.beginPath(); ctx.arc(sx, sy - 4, 5, Math.PI, 0); ctx.fill();
  ctx.fillRect(sx - 5, sy - 4, 10, 4);
  // Support beams (timber)
  ctx.fillStyle = '#795548';
  ctx.fillRect(sx - 6, sy - 10, 2, 10);
  ctx.fillRect(sx + 4, sy - 10, 2, 10);
  // Crossbeam
  ctx.fillRect(sx - 6, sy - 10, 12, 2);
  // Lantern at entrance
  ctx.fillStyle = '#ffcc00'; ctx.shadowColor = '#ff9900'; ctx.shadowBlur = 4;
  ctx.beginPath(); ctx.arc(sx, sy - 11, 1.5, 0, Math.PI * 2); ctx.fill();
  ctx.shadowBlur = 0;
  // Ore cart
  if (lv >= 1) {
    ctx.fillStyle = '#5d4037'; ctx.fillRect(sx + 6, sy - 2, 5, 3);
    ctx.fillStyle = '#888'; ctx.fillRect(sx + 7, sy - 3, 3, 1.5);
    // Cart wheels
    ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(sx + 7, sy + 2, 1, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(sx + 10, sy + 2, 1, 0, Math.PI * 2); ctx.fill();
  }
  if (lv >= 2) {
    ctx.fillStyle = '#ffd54f'; ctx.beginPath(); ctx.arc(sx, sy - 14, 2, 0, Math.PI * 2); ctx.fill();
  }
}

function drawHuntingLodge(sx, sy, lv) {
  const h = 12 + lv * 2;
  drawIsoBox(sx, sy, h, '#6d4c41', '#5d4037', '#4e342e');
  // Antler rack decoration
  ctx.strokeStyle = '#bcaaa4'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(sx - 3, sy - h - 2); ctx.lineTo(sx - 6, sy - h - 8); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(sx + 3, sy - h - 2); ctx.lineTo(sx + 6, sy - h - 8); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(sx - 5, sy - h - 6); ctx.lineTo(sx - 8, sy - h - 9); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(sx + 5, sy - h - 6); ctx.lineTo(sx + 8, sy - h - 9); ctx.stroke();
  // Animal pelts on wall
  if (lv >= 1) {
    ctx.fillStyle = '#8d6e63'; ctx.fillRect(sx - 10, sy - h + 3, 4, 5);
    ctx.fillStyle = '#795548'; ctx.fillRect(sx - 9, sy - h + 4, 2, 3);
  }
  // Campfire
  ctx.fillStyle = '#ff6600';
  const ff = Math.sin(animFrame * 0.25) * 1;
  ctx.beginPath(); ctx.moveTo(sx + 10, sy + 2); ctx.lineTo(sx + 11, sy - 2 + ff); ctx.lineTo(sx + 12, sy + 2); ctx.fill();
  ctx.fillStyle = '#ffcc00';
  ctx.beginPath(); ctx.arc(sx + 11, sy + ff, 1, 0, Math.PI * 2); ctx.fill();
  // Meat drying rack
  if (lv >= 2) {
    ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(sx - 12, sy - 2); ctx.lineTo(sx - 12, sy - 8); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(sx - 8, sy - 2); ctx.lineTo(sx - 8, sy - 8); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(sx - 12, sy - 8); ctx.lineTo(sx - 8, sy - 8); ctx.stroke();
    ctx.fillStyle = '#ef5350';
    ctx.fillRect(sx - 11, sy - 7, 2, 3);
    ctx.fillRect(sx - 9, sy - 7, 2, 3);
  }
}

function drawWatchtower(sx, sy, lv) {
  const h = 24 + lv * 6;
  drawIsoBox(sx, sy, h, '#5d4037', '#4e342e', '#3e2723');
  // Platform
  ctx.fillStyle = '#795548'; ctx.fillRect(sx - 10, sy - h - 2, 20, 3);
  // Railing with crenellations
  ctx.fillStyle = '#8d6e63';
  for (let i = 0; i < 4; i++) {
    ctx.fillRect(sx - 9 + i * 5, sy - h - 6, 3, 4);
  }
  // Guard figure
  ctx.fillStyle = '#dbb896';
  ctx.beginPath(); ctx.arc(sx, sy - h - 8, 2, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#546e7a'; ctx.fillRect(sx - 1.5, sy - h - 6, 3, 3);
  // Beacon flame
  if (lv >= 1) {
    ctx.fillStyle = '#ff9800';
    const beaconF = Math.sin(animFrame * 0.2) * 2;
    ctx.beginPath(); ctx.moveTo(sx - 2, sy - h - 10); ctx.lineTo(sx, sy - h - 16 + beaconF); ctx.lineTo(sx + 2, sy - h - 10); ctx.fill();
    ctx.fillStyle = '#ffeb3b';
    ctx.beginPath(); ctx.arc(sx, sy - h - 12 + beaconF * 0.5, 1.5, 0, Math.PI * 2); ctx.fill();
  }
  // Arrow slits
  if (lv >= 2) {
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(sx - 1, sy - h + 6, 2, 5);
    ctx.fillRect(sx - 1, sy - h + 14, 2, 5);
  }
}

function drawMarket(sx, sy, lv) {
  drawIsoBox(sx, sy, 10, '#795548', '#5d4037', '#4e342e');
  // Colored canopy
  const canopyColors = ['#e53935', '#ff8f00', '#43a047'];
  ctx.fillStyle = canopyColors[lv] || '#e53935';
  ctx.beginPath();
  ctx.moveTo(sx - 18, sy - 10); ctx.lineTo(sx + 18, sy - 10);
  ctx.lineTo(sx + 14, sy - 18); ctx.lineTo(sx - 14, sy - 18);
  ctx.closePath(); ctx.fill();
  // Canopy stripes
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.fillRect(sx - 12, sy - 17, 4, 7);
  ctx.fillRect(sx - 2, sy - 17, 4, 7);
  ctx.fillRect(sx + 8, sy - 17, 4, 7);
  // Stall counter
  ctx.fillStyle = '#6d4c41'; ctx.fillRect(sx - 12, sy - 4, 24, 2);
  // Hanging goods
  ctx.fillStyle = '#ffd54f'; ctx.beginPath(); ctx.arc(sx - 5, sy - 7, 1.5, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#ff7043'; ctx.beginPath(); ctx.arc(sx + 2, sy - 6, 1.5, 0, Math.PI * 2); ctx.fill();
  // Barrels
  ctx.fillStyle = '#5d4037'; ctx.fillRect(sx + 10, sy - 4, 4, 5);
  ctx.strokeStyle = '#444'; ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.moveTo(sx + 10, sy - 2); ctx.lineTo(sx + 14, sy - 2); ctx.stroke();
  if (lv >= 1) {
    ctx.fillStyle = '#8d6e63'; ctx.fillRect(sx - 14, sy - 4, 3, 5);
    ctx.fillStyle = '#66bb6a'; ctx.beginPath(); ctx.arc(sx + 8, sy - 3, 2, 0, Math.PI * 2); ctx.fill();
  }
}

function drawWarehouse(sx, sy, lv) {
  const h = 14 + lv * 4;
  drawIsoBox(sx, sy, h, '#6d4c41', '#5d4037', '#4e342e');
  // Large door
  ctx.fillStyle = '#3e2723'; ctx.fillRect(sx - 5, sy - 7, 10, 9);
  ctx.fillStyle = '#555'; ctx.fillRect(sx - 5, sy - 4, 10, 0.8);
  // Crates
  const crates = 1 + lv;
  for (let i = 0; i < crates; i++) {
    ctx.fillStyle = '#8d6e63'; ctx.fillRect(sx + 10, sy - 3 - i * 5, 5, 4);
    ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 0.3; ctx.strokeRect(sx + 10, sy - 3 - i * 5, 5, 4);
  }
  // Barrels
  ctx.fillStyle = '#5d4037'; ctx.fillRect(sx - 12, sy - 2, 4, 5);
  ctx.strokeStyle = '#444'; ctx.lineWidth = 0.4;
  ctx.beginPath(); ctx.moveTo(sx - 12, sy); ctx.lineTo(sx - 8, sy); ctx.stroke();
}

function drawHospital(sx, sy, lv) {
  const h = 16 + lv * 3;
  drawIsoBox(sx, sy, h, '#e0e0e0', '#bdbdbd', '#9e9e9e');
  // Red cross banner
  ctx.fillStyle = '#f44336';
  ctx.fillRect(sx - 1, sy - h + 3, 3, 7);
  ctx.fillRect(sx - 3, sy - h + 5, 7, 3);
  // Herb garden
  ctx.fillStyle = '#4caf50';
  ctx.fillRect(sx - 10, sy + 2, 2, 3); ctx.fillRect(sx - 7, sy + 3, 2, 2);
  ctx.fillStyle = '#66bb6a';
  ctx.fillRect(sx - 9, sy + 1, 1.5, 2);
  if (lv >= 1) {
    ctx.fillStyle = '#81d4fa';
    ctx.fillRect(sx - 6, sy - h + 5, 2, 3);
    ctx.fillRect(sx + 5, sy - h + 5, 2, 3);
  }
}

function drawAcademy(sx, sy, lv) {
  const h = 20 + lv * 4;
  drawIsoBox(sx, sy, h, '#5c6bc0', '#3f51b5', '#303f9f');
  // Columns (stone)
  ctx.fillStyle = '#9fa8da';
  ctx.fillRect(sx - 10, sy - 6, 2, 8);
  ctx.fillRect(sx + 8, sy - 6, 2, 8);
  // Column capitals
  ctx.fillStyle = '#b0bec5';
  ctx.fillRect(sx - 11, sy - 7, 4, 1.5);
  ctx.fillRect(sx + 7, sy - 7, 4, 1.5);
  // Scrolls on pediment
  ctx.fillStyle = '#f0e0c0';
  ctx.fillRect(sx - 3, sy - h + 4, 6, 3);
  ctx.strokeStyle = '#b89840'; ctx.lineWidth = 0.4;
  ctx.strokeRect(sx - 3, sy - h + 4, 6, 3);
  // Steps
  ctx.fillStyle = '#7986cb';
  ctx.fillRect(sx - 8, sy - 1, 16, 2);
}

function drawTemple(sx, sy, lv) {
  const h = 22 + lv * 5;
  drawIsoBox(sx, sy, h, '#f5f5dc', '#e8e0c0', '#d4c99a');
  // Ornate spire
  ctx.fillStyle = '#ffd54f';
  ctx.beginPath();
  ctx.moveTo(sx, sy - h - 12 - lv * 3);
  ctx.lineTo(sx + 5, sy - h);
  ctx.lineTo(sx - 5, sy - h);
  ctx.closePath(); ctx.fill();
  // Cross/symbol at top
  ctx.fillStyle = '#b89840';
  ctx.fillRect(sx - 0.5, sy - h - 14 - lv * 3, 1.5, 4);
  ctx.fillRect(sx - 2, sy - h - 12 - lv * 3, 5, 1);
  // Stained glass window
  if (lv >= 1) {
    ctx.fillStyle = '#e53935';
    ctx.beginPath(); ctx.arc(sx, sy - h + 6, 2.5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#1565c0';
    ctx.beginPath(); ctx.arc(sx, sy - h + 6, 1.5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#ffd54f';
    ctx.beginPath(); ctx.arc(sx, sy - h + 6, 0.5, 0, Math.PI * 2); ctx.fill();
  }
  // Bell
  if (lv >= 2) {
    ctx.fillStyle = '#b89840';
    ctx.beginPath(); ctx.arc(sx, sy - h - 3, 2, 0, Math.PI); ctx.fill();
    ctx.fillStyle = '#8a6830';
    ctx.beginPath(); ctx.arc(sx, sy - h - 1, 0.8, 0, Math.PI * 2); ctx.fill();
  }
}

function drawPort(sx, sy, lv) {
  drawIsoBox(sx, sy, 10, '#795548', '#5d4037', '#4e342e');
  // Wooden dock
  ctx.fillStyle = '#8d6e63';
  ctx.fillRect(sx + 10, sy - 2, 14, 3);
  // Dock planks
  ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 0.3;
  for (let pi = 0; pi < 5; pi++) {
    ctx.beginPath(); ctx.moveTo(sx + 12 + pi * 2.5, sy - 2); ctx.lineTo(sx + 12 + pi * 2.5, sy + 1); ctx.stroke();
  }
  // Moored boat
  if (lv >= 1) {
    ctx.fillStyle = '#5d4037';
    ctx.beginPath();
    ctx.moveTo(sx + 16, sy - 6); ctx.lineTo(sx + 24, sy - 4);
    ctx.lineTo(sx + 16, sy - 2); ctx.closePath(); ctx.fill();
    // Sail
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.moveTo(sx + 18, sy - 6); ctx.lineTo(sx + 18, sy - 12); ctx.lineTo(sx + 22, sy - 6); ctx.closePath(); ctx.fill();
    // Mast
    ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(sx + 18, sy - 4); ctx.lineTo(sx + 18, sy - 13); ctx.stroke();
  }
  // Fishing nets
  ctx.strokeStyle = 'rgba(150,150,130,0.3)'; ctx.lineWidth = 0.4;
  ctx.beginPath(); ctx.moveTo(sx + 8, sy - 2); ctx.quadraticCurveTo(sx + 6, sy + 3, sx + 10, sy + 4); ctx.stroke();
  if (lv >= 2) {
    ctx.fillStyle = '#ffd54f'; ctx.beginPath(); ctx.arc(sx + 18, sy - 14, 2, 0, Math.PI * 2); ctx.fill();
  }
}

function drawBlacksmith(sx, sy, lv) {
  const h = 16 + lv * 3;
  const colors = [['#5d4037', '#4e342e', '#3e2723'], ['#6d4c41', '#5d4037', '#4e342e'], ['#795548', '#6d4c41', '#5d4037']][lv] || ['#5d4037', '#4e342e', '#3e2723'];
  drawIsoBox(sx, sy, h, colors[0], colors[1], colors[2]);
  // Chimney
  ctx.fillStyle = '#4e342e'; ctx.fillRect(sx + 8, sy - h - 8, 4, 10);
  // Smoke puffs
  const smokeT = animFrame * 0.04;
  ctx.fillStyle = 'rgba(180,180,180,0.25)';
  ctx.beginPath(); ctx.arc(sx + 10, sy - h - 10 - Math.sin(smokeT) * 3, 3 + lv * 0.5, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = 'rgba(150,150,150,0.15)';
  ctx.beginPath(); ctx.arc(sx + 9, sy - h - 16 - Math.sin(smokeT + 1) * 2, 2 + lv * 0.5, 0, Math.PI * 2); ctx.fill();
  // Forge glow (opening)
  ctx.fillStyle = 'rgba(255,100,0,0.5)'; ctx.fillRect(sx - 4, sy - 6, 4, 4);
  ctx.fillStyle = 'rgba(255,160,0,0.3)'; ctx.fillRect(sx - 5, sy - 7, 6, 6);
  // Anvil
  ctx.fillStyle = '#424242'; ctx.fillRect(sx + 2, sy - 4, 5, 2);
  ctx.fillStyle = '#555'; ctx.fillRect(sx + 3, sy - 7, 3, 3);
  ctx.fillStyle = '#666'; ctx.fillRect(sx + 3, sy - 7, 2, 1);
  // Hammer
  ctx.fillStyle = '#6d4c41'; ctx.fillRect(sx + 6, sy - 9, 1.5, 5);
  ctx.fillStyle = '#757575'; ctx.fillRect(sx + 5, sy - 10, 3.5, 2);
  // Bellows
  if (lv >= 2) {
    ctx.fillStyle = '#5d4037';
    ctx.beginPath(); ctx.moveTo(sx - 8, sy - 5); ctx.lineTo(sx - 12, sy - 3); ctx.lineTo(sx - 12, sy - 7); ctx.closePath(); ctx.fill();
    ctx.fillStyle = '#4e342e'; ctx.fillRect(sx - 12, sy - 6, 1, 2);
  }
  // Sparks from forge
  if (lv >= 1) {
    const sparkTime = animFrame * 0.15;
    ctx.fillStyle = '#ffab00';
    ctx.beginPath(); ctx.arc(sx - 2 + Math.sin(sparkTime) * 2, sy - 8 - Math.abs(Math.cos(sparkTime)) * 3, 0.8, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#ff6600';
    ctx.beginPath(); ctx.arc(sx - 4 + Math.sin(sparkTime + 1) * 1.5, sy - 9 - Math.abs(Math.cos(sparkTime + 0.5)) * 2, 0.6, 0, Math.PI * 2); ctx.fill();
  }
  // Tool rack
  if (lv >= 1) {
    ctx.strokeStyle = '#8d6e63'; ctx.lineWidth = 0.8;
    ctx.beginPath(); ctx.moveTo(sx - 8, sy - h + 3); ctx.lineTo(sx - 2, sy - h + 3); ctx.stroke();
    ctx.fillStyle = '#9e9e9e';
    ctx.fillRect(sx - 7, sy - h + 3, 1, 4);
    ctx.fillRect(sx - 4, sy - h + 3, 1, 4);
  }
}

// -----------------------------------------------
//  SECTION 15: PARTICLES & EFFECTS
// -----------------------------------------------
function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.ox += p.vx; p.oy += p.vy;
    p.vy += 0.04;
    p.vx *= 0.96; p.vy *= 0.98;
    p.life--;
    const t = p.life / p.maxLife;
    const alpha = t * t;
    p.size *= 0.995;
    const iso = toIso(p.gx, p.gy);
    const psx = iso.x + p.ox, psy = iso.y + p.oy;
    if (psx < -20 || psx > W + 20 || psy < -20 || psy > H + 20) { particles.splice(i, 1); continue; }
    ctx.globalAlpha = alpha;
    const pGrad = ctx.createRadialGradient(psx, psy, 0, psx, psy, p.size);
    pGrad.addColorStop(0, p.color);
    pGrad.addColorStop(0.5, p.color);
    pGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = pGrad;
    ctx.beginPath(); ctx.arc(psx, psy, p.size, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function updateAmbientParticles() {
  for (let i = ambientParticles.length - 1; i >= 0; i--) {
    const p = ambientParticles[i];
    p.x += p.vx + Math.sin(animFrame * 0.02 + i) * 0.15;
    p.y += p.vy;
    p.life--;
    if (p.y > 0 && p.y < H - PANEL_H && p.x > 0 && p.x < W) {
      ctx.fillStyle = 'rgba(200,210,180,' + (p.alpha * (p.life / p.maxLife)) + ')';
      ctx.fillRect(p.x, p.y, p.size, p.size);
    }
    if (p.life <= 0 || p.y < -10 || p.x < -10 || p.x > W + 10) {
      ambientParticles[i] = {
        x: Math.random() * W, y: H - PANEL_H + 10,
        vx: (Math.random() - 0.5) * 0.3, vy: -0.1 - Math.random() * 0.2,
        size: 1 + Math.random() * 1.5, alpha: 0.15 + Math.random() * 0.25,
        life: 200 + randInt(0, 200), maxLife: 400,
      };
    }
  }
}

function updateFloatingTexts() {
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const ft = floatingTexts[i];
    const t = ft.life / 60;
    ft.oy -= 0.4 + t * 0.6;
    ft.life--;
    const raw = ft.life / 60;
    const alpha = raw * raw;
    const scale = 1 + (1 - raw) * 0.2;
    const iso = toIso(ft.gx, ft.gy);
    const fsx = iso.x, fsy = iso.y + ft.oy;
    if (fsx < -100 || fsx > W + 100 || fsy < -100 || fsy > H + 100) { floatingTexts.splice(i, 1); continue; }
    ctx.font = 'bold ' + Math.floor(13 * scale) + 'px sans-serif'; ctx.textAlign = 'center';
    ctx.globalAlpha = Math.min(1, alpha);
    ctx.shadowColor = ft.color; ctx.shadowBlur = 8;
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillText(ft.text, fsx + 1, fsy + 1);
    ctx.fillStyle = ft.color; ctx.fillText(ft.text, fsx, fsy);
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    if (ft.life <= 0) floatingTexts.splice(i, 1);
  }
}

// spawnParticles, spawnFloatingText - defined in Part 2

function drawLabel(x, y, text, color) {
  ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'center';
  const w = ctx.measureText(text).width + 8;
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  const rx = x - w / 2, ry = y - 10, rw = w, rh = 14, rr = 4;
  ctx.beginPath();
  ctx.moveTo(rx + rr, ry); ctx.lineTo(rx + rw - rr, ry);
  ctx.arcTo(rx + rw, ry, rx + rw, ry + rr, rr);
  ctx.lineTo(rx + rw, ry + rh - rr);
  ctx.arcTo(rx + rw, ry + rh, rx + rw - rr, ry + rh, rr);
  ctx.lineTo(rx + rr, ry + rh);
  ctx.arcTo(rx, ry + rh, rx, ry + rh - rr, rr);
  ctx.lineTo(rx, ry + rr);
  ctx.arcTo(rx, ry, rx + rr, ry, rr);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = 'rgba(0,0,0,0.8)';
  ctx.fillText(text, x + 1, y + 1);
  ctx.fillText(text, x - 1, y + 1);
  ctx.fillStyle = color; ctx.fillText(text, x, y);
}

// -----------------------------------------------
//  SECTION 16: SETTLEMENT INFO PANEL
// -----------------------------------------------
function drawSettlementPanel() {
  const panelY = H - PANEL_H;

  // Medieval wood panel background
  const panelGrad = ctx.createLinearGradient(0, panelY, 0, panelY + PANEL_H);
  panelGrad.addColorStop(0, '#2a1e14');
  panelGrad.addColorStop(1, '#16100a');
  ctx.fillStyle = panelGrad;
  ctx.fillRect(0, panelY, W, PANEL_H);
  ctx.fillStyle = '#6a5030'; ctx.fillRect(0, panelY, W, 1);

  // Notifications
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'left';
  const recent = notifications.slice(-3);
  for (let i = 0; i < recent.length; i++) {
    ctx.fillStyle = recent[i].color || '#aab';
    ctx.fillText(recent[i].text || '', 10, panelY + 15 + i * 14);
  }

  // Build mode indicator
  if (buildMode && buildSelected) {
    ctx.textAlign = 'right';
    ctx.fillStyle = '#ffd54f'; ctx.font = '12px sans-serif';
    const bName = BUILDING_DEFS[buildSelected] ? BUILDING_DEFS[buildSelected].name : buildSelected;
    ctx.fillText('Placing: ' + bName + '  (ESC to cancel)', W - 10, panelY + 20);
  }

  // Turn counter
  ctx.textAlign = 'right';
  ctx.fillStyle = '#556'; ctx.font = '10px sans-serif';
  ctx.fillText('Turn ' + turnCount, W - 10, panelY + PANEL_H - 6);
}

// ===============================================
//  END OF PART 4 - DRAWING FUNCTIONS
// ===============================================
// PART 5: TACTICAL BATTLE SYSTEM (Medieval)
// 
// NOTE: toBattleIso, fromBattleIso, BATTLE_ISO_X, BATTLE_ISO_Y are defined in Part 1

function enterBattle(arr, idx, isFort) {
  const entity = arr[idx];
  gameMode = 'deploy';
  deploySelectedType = null;
  battleParticles = [];
  battleFloatingTexts = [];

  // Generate battle grid
  const grid = [];
  for (let y = 0; y < BROWS; y++) {
    grid[y] = [];
    for (let x = 0; x < BCOLS; x++) {
      // Random obstacles (10% in middle area, not in deployment zones)
      if (x >= 3 && x < BCOLS - 3 && Math.random() < 0.1) grid[y][x] = 'wall';
      else grid[y][x] = 'grass';
    }
  }

  // Generate enemy units from strength
  const eType = isFort ? 'bandit' : entity.type;
  const eStr = isFort ? entity.str : entity.str;
  const eStats = ENEMY_BATTLE_STATS[eType];
  const numEnemies = Math.max(1, Math.ceil(eStr / eStats.hp));
  const enemyUnits = [];
  for (let i = 0; i < numEnemies; i++) {
    const ex = BCOLS - 1 - (i % 3);
    const ey = Math.floor(i / 3) + Math.floor((BROWS - Math.ceil(numEnemies / 3)) / 2);
    const ey2 = Math.max(0, Math.min(BROWS - 1, ey));
    // Mix unit types for castles and dark mages
    let unitType = eType;
    if (isFort && i > 0 && Math.random() < 0.4) unitType = 'raider';
    if (eType === 'dark_mage' && i > 0 && Math.random() < 0.5) unitType = 'troll';
    const stats = ENEMY_BATTLE_STATS[unitType];
    enemyUnits.push({
      type: unitType, hp: stats.hp, maxHp: stats.hp,
      atk: stats.atk, range: stats.range,
      aoe: stats.aoe, heavy: stats.heavy || false,
      x: ex, y: ey2, vx: ex, vy: ey2,
      moveSpeed: stats.moveSpeed, attackRate: stats.attackRate, attackCD: 0,
    });
  }
  // Make sure no two enemies overlap
  for (let i = 1; i < enemyUnits.length; i++) {
    while (enemyUnits.some((u, j) => j < i && u.x === enemyUnits[i].x && u.y === enemyUnits[i].y)) {
      enemyUnits[i].y = (enemyUnits[i].y + 1) % BROWS;
    }
    enemyUnits[i].vx = enemyUnits[i].x;
    enemyUnits[i].vy = enemyUnits[i].y;
  }

  battle = {
    grid,
    playerUnits: [],
    enemyUnits,
    enemyContext: { type: eType, str: eStr, index: idx, isFort, arr },
    simSpeed: 1,     // 1, 2, or 4
    simPaused: false,
    frameCount: 0,
    resultMsg: '',
    deployArmy: {}, // copy of player army HP arrays for deployment
  };
  // Copy army HP arrays for deployment
  for (const t of TROOP_ORDER) battle.deployArmy[t] = Array.isArray(player.army[t]) ? player.army[t].slice() : [];
}

function cancelDeploy() {
  // player.army was never modified during deploy, so just reset
  gameMode = 'overworld';
  battle = null;
  // Push player back so they don't re-trigger
  player.x = Math.max(0, player.x - player.lastDx);
  player.y = Math.max(0, player.y - player.lastDy);
}

function startBattle() {
  if (battle.playerUnits.length === 0) return;
  for (const t of TROOP_ORDER) player.army[t] = Array.isArray(battle.deployArmy[t]) ? battle.deployArmy[t].slice() : [];
  battle.deployedSnapshot = {};
  for (const u of battle.playerUnits) {
    if (!battle.deployedSnapshot[u.type]) battle.deployedSnapshot[u.type] = [];
    battle.deployedSnapshot[u.type].push(u.maxHp);
  }
  // Init real-time fields on all units
  for (const u of battle.playerUnits) {
    const s = BATTLE_STATS[u.type];
    u.moveSpeed = s.moveSpeed; u.attackRate = s.attackRate; u.attackCD = Math.floor(Math.random() * 20);
    u.vx = u.x; u.vy = u.y;
  }
  for (const u of battle.enemyUnits) {
    const s = ENEMY_BATTLE_STATS[u.type];
    u.moveSpeed = s.moveSpeed; u.attackRate = s.attackRate; u.attackCD = Math.floor(Math.random() * 30);
    u.vx = u.x; u.vy = u.y;
  }
  battleProjectiles = [];
  updateHUD();
  gameMode = 'battle';
  battle.simSpeed = 1;
  battle.simPaused = false;
  battle.frameCount = 0;
}

function getEuclidDist(a, b) {
  return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
}

//  PROJECTILE HELPERS 
function getProjectileType(unitType) {
  if (unitType === 'pikemen') return 'pike_thrust';
  if (unitType === 'knights' || unitType === 'war_elephant') return 'lance_charge';
  if (unitType === 'catapults') return 'stone';
  if (unitType === 'firelancers') return 'greek_fire';
  if (unitType === 'healers') return 'heal';
  if (unitType === 'crossbowmen') return 'bolt_volley';
  if (unitType === 'troll') return 'club_smash';
  if (unitType === 'dark_mage') return 'magic_bolt';
  if (unitType === 'longbowmen' || unitType === 'enemy_archer') return 'arrow';
  if (unitType === 'assassins') return 'thrown_dagger';
  if (unitType === 'cannons' || unitType === 'dragon_rider') return 'cannonball';
  return 'arrow';
}

function getProjectileColor(pType) {
  if (pType === 'pike_thrust') return '#8d6e63';
  if (pType === 'lance_charge') return '#c0c0c0';
  if (pType === 'stone') return '#888';
  if (pType === 'greek_fire') return '#ff9800';
  if (pType === 'heal') return '#ffd54f';
  if (pType === 'bolt_volley') return '#8d6e63';
  if (pType === 'club_smash') return '#76ff03';
  if (pType === 'magic_bolt') return '#ce93d8';
  if (pType === 'thrown_dagger') return '#b0bec5';
  if (pType === 'cannonball') return '#555';
  return '#8d6e63';
}

function getProjectileSpeed(pType) {
  if (pType === 'pike_thrust') return 0.12;
  if (pType === 'lance_charge') return 0.1;
  if (pType === 'stone') return 0.08;
  if (pType === 'greek_fire') return 0.15;
  if (pType === 'heal') return 0.15;
  if (pType === 'club_smash') return 0.2;
  if (pType === 'magic_bolt') return 0.14;
  if (pType === 'bolt_volley') return 0.18;
  if (pType === 'thrown_dagger') return 0.16;
  if (pType === 'cannonball') return 0.1;
  return 0.16;
}

function spawnProjectile(attacker, target, isPlayer) {
  const pType = getProjectileType(attacker.type);
  const count = pType === 'bolt_volley' ? 3 : 1;
  for (let i = 0; i < count; i++) {
    battleProjectiles.push({
      x: attacker.x, y: attacker.y,
      tx: target.x, ty: target.y,
      targetUnit: target,
      speed: getProjectileSpeed(pType),
      dmg: attacker.atk, atk: attacker.atk,
      attackerType: attacker.type, aoe: attacker.aoe || 0,
      isPlayer, type: pType,
      color: getProjectileColor(pType),
      life: 120, delay: i * 5,
      heavy: attacker.heavy,
    });
  }
}

//  REAL-TIME BATTLE AI 
function updateRealTimeBattle() {
  if (!battle || battle.simPaused || gameMode !== 'battle') return;
  const speedMul = battle.simSpeed;
  battle.frameCount = (battle.frameCount || 0) + 1;

  const allUnits = battle.playerUnits.concat(battle.enemyUnits);

  // Process burning DOT every ~60 frames
  if (battle.frameCount % 60 === 0) {
    for (const u of allUnits) {
      if (u.hp <= 0 || !u.burning || u.burning <= 0) continue;
      u.hp -= 2;
      u.burning--;
      const biso = toBattleIso(u.x, u.y);
      for (let i = 0; i < 4; i++) {
        battleParticles.push({ x: biso.x + (Math.random()-0.5)*8, y: biso.y - 10 + (Math.random()-0.5)*6, vx: (Math.random()-0.5)*1.5, vy: -1.5 - Math.random(), life: 18, maxLife: 18, color: i < 2 ? '#ff9800' : '#ffeb3b', size: 2 + Math.random() });
      }
      battleFloatingTexts.push({ x: biso.x, y: biso.y - 28, text: '-2 BURN', color: '#ff9800', life: 40 });
      if (u.hp <= 0) {
        battle.enemyUnits = battle.enemyUnits.filter(x => x.hp > 0);
        battle.playerUnits = battle.playerUnits.filter(x => x.hp > 0);
        if (battle.enemyUnits.length === 0) { battleVictory(); return; }
        if (battle.playerUnits.length === 0) { battleDefeat(); return; }
      }
    }
  }

  // Turret bonus damage every ~120 frames
  if (battle.turretBonus && battle.frameCount % 120 === 0 && battle.enemyUnits.length > 0) {
    const target = battle.enemyUnits[randInt(0, battle.enemyUnits.length - 1)];
    if (target && target.hp > 0) {
      target.hp -= battle.turretBonus;
      const tiso = toBattleIso(target.x, target.y);
      battleFloatingTexts.push({ x: tiso.x, y: tiso.y - 28, text: '-' + battle.turretBonus + ' TURRET', color: '#90a4ae', life: 40 });
      for (let i = 0; i < 6; i++) {
        battleParticles.push({ x: tiso.x + (Math.random()-0.5)*12, y: tiso.y - 10 + (Math.random()-0.5)*8, vx: (Math.random()-0.5)*2, vy: -2 - Math.random(), life: 15, maxLife: 15, color: '#b0bec5', size: 2 });
      }
      if (target.hp <= 0) {
        battle.enemyUnits = battle.enemyUnits.filter(x => x.hp > 0);
        if (battle.enemyUnits.length === 0) { battleVictory(); return; }
      }
    }
  }

  // Dark mages summon trolls every ~180 frames in battle
  if (battle.frameCount % 180 === 0) {
    for (const u of battle.enemyUnits) {
      if (u.hp <= 0 || u.type !== 'dark_mage') continue;
      if (!u.summonCount) u.summonCount = 0;
      if (u.summonCount >= 3) continue;
      const ms = ENEMY_BATTLE_STATS.troll;
      battle.enemyUnits.push({
        type: 'troll', hp: ms.hp, maxHp: ms.hp, atk: ms.atk, range: ms.range,
        aoe: ms.aoe, heavy: ms.heavy, x: u.x + (Math.random()-0.5)*0.5, y: u.y + (Math.random()-0.5)*0.5,
        vx: u.x, vy: u.y, moveSpeed: ms.moveSpeed, attackRate: ms.attackRate, attackCD: 20,
      });
      u.summonCount++;
      const siso = toBattleIso(u.x, u.y);
      for (let i = 0; i < 8; i++) battleParticles.push({ x: siso.x, y: siso.y - 8, vx: (Math.random()-0.5)*3, vy: -Math.random()*2-1, life: 25, maxLife: 25, color: '#76ff03', size: 2.5 });
      battleFloatingTexts.push({ x: siso.x, y: siso.y - 30, text: 'SUMMON!', color: '#76ff03', life: 50 });
    }
  }

  for (const u of allUnits) {
    if (u.hp <= 0) continue;
    if (u.attackCD > 0) u.attackCD -= speedMul;
    const isPlayer = battle.playerUnits.includes(u);
    const enemies = isPlayer ? battle.enemyUnits : battle.playerUnits;
    const allies = isPlayer ? battle.playerUnits : battle.enemyUnits;

    // Healers: heal allies
    if (u.type === 'healers') {
      let healTarget = null, lowestFrac = 1;
      for (const a of allies) {
        if (a === u || a.hp <= 0) continue;
        const f = a.hp / a.maxHp;
        if (f < lowestFrac) { lowestFrac = f; healTarget = a; }
      }
      if (healTarget && lowestFrac < 0.9) {
        const d = getEuclidDist(u, healTarget);
        if (d <= u.range && u.attackCD <= 0) {
          const healAmt = 4;
          healTarget.hp = Math.min(healTarget.maxHp, healTarget.hp + healAmt);
          const hIso = toBattleIso(healTarget.x, healTarget.y);
          for (let i = 0; i < 4; i++) battleParticles.push({ x: hIso.x, y: hIso.y - 10, vx: (Math.random()-0.5)*2, vy: -1-Math.random()*2, life: 20, maxLife: 20, color: '#ffd54f', size: 2 });
          battleFloatingTexts.push({ x: hIso.x, y: hIso.y - 20, text: '+' + healAmt, color: '#ffd54f', life: 40 });
          u.attackCD = u.attackRate;
        } else if (d > u.range) {
          moveToward(u, healTarget, speedMul, allies);
        }
      }
      continue;
    }

    // Find target
    let target = null;
    if (isPlayer) {
      // Smart targeting
      let bestScore = 999;
      for (const e of enemies) {
        if (e.hp <= 0) continue;
        let score = getEuclidDist(u, e);
        if (u.type === 'pikemen' && e.heavy) score -= 8;
        if (e.hp < e.maxHp) score -= 2;
        if (e.hp <= u.atk) score -= 1.5;
        if (score < bestScore) { bestScore = score; target = e; }
      }
    } else {
      // Enemy: nearest
      let nearDist = 999;
      for (const p of enemies) {
        if (p.hp <= 0) continue;
        const d = getEuclidDist(u, p);
        if (d < nearDist) { nearDist = d; target = p; }
      }
    }
    if (!target) continue;

    const dist = getEuclidDist(u, target);
    // Ranged units stop at range, melee close in
    const idealRange = (u.type === 'longbowmen' || u.type === 'catapults' || u.type === 'enemy_archer') ? u.range * 0.8 : u.range * 0.7;

    if (dist <= u.range && u.attackCD <= 0) {
      // Fire projectile
      spawnProjectile(u, target, isPlayer);
      u.attackCD = u.attackRate;
    } else if (dist > idealRange) {
      moveToward(u, target, speedMul, allies);
    }
  }
}

function moveToward(u, target, speedMul, allies) {
  const dx = target.x - u.x, dy = target.y - u.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist < 0.05) return;
  let mx = (dx / dist) * u.moveSpeed * speedMul;
  let my = (dy / dist) * u.moveSpeed * speedMul;
  // Separation from allies to avoid stacking
  for (const a of allies) {
    if (a === u || a.hp <= 0) continue;
    const sd = getEuclidDist(u, a);
    if (sd < 0.6) {
      const sep = 0.005 / Math.max(0.1, sd);
      mx += (u.x - a.x) * sep;
      my += (u.y - a.y) * sep;
    }
  }
  u.x = Math.max(0.2, Math.min(BCOLS - 0.2, u.x + mx));
  u.y = Math.max(0.2, Math.min(BROWS - 0.2, u.y + my));
}

//  PROJECTILE UPDATE 
function updateProjectiles() {
  for (let i = battleProjectiles.length - 1; i >= 0; i--) {
    const p = battleProjectiles[i];
    if (p.delay > 0) { p.delay--; continue; }
    // Move toward target
    const t = p.targetUnit;
    if (t && t.hp > 0) { p.tx = t.x; p.ty = t.y; }
    const dx = p.tx - p.x, dy = p.ty - p.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 0.15 || p.life <= 0) {
      // Impact!
      if (t && t.hp > 0) battleProjectileHit(p);
      battleProjectiles.splice(i, 1);
      continue;
    }
    p.x += (dx / dist) * p.speed * battle.simSpeed;
    p.y += (dy / dist) * p.speed * battle.simSpeed;
    p.life--;
    // Trail particles
    if (p.type === 'pike_thrust' || p.type === 'greek_fire') {
      const iso = toBattleIso(p.x, p.y);
      battleParticles.push({ x: iso.x, y: iso.y - 8, vx: (Math.random()-0.5)*1, vy: -0.5, life: 10, maxLife: 10, color: p.color, size: 1.5 });
    }
  }
}

function battleProjectileHit(proj) {
  const defender = proj.targetUnit;
  const isPlayerUnit = proj.isPlayer;

  let dmg = proj.dmg;
  if (proj.attackerType === 'pikemen' && defender.heavy) dmg = Math.ceil(dmg * 1.6);
  if (defender.type === 'knights') dmg = Math.max(1, dmg - 5);
  if (isPlayerUnit && morale !== 0) dmg = Math.max(1, Math.ceil(dmg * (1 + morale * 0.08)));
  dmg = Math.ceil(dmg * (0.8 + Math.random() * 0.4));
  if (proj.type === 'bolt_volley') dmg = Math.ceil(dmg * 0.4);
  defender.hp -= dmg;

  const diso = toBattleIso(defender.x, defender.y);
  for (let i = 0; i < 5; i++) {
    battleParticles.push({ x: diso.x, y: diso.y - 10, vx: (Math.random()-0.5)*3, vy: -Math.random()*3-1, life: 20, maxLife: 20, color: defender.hp <= 0 ? '#ff4444' : '#ffaa44', size: 2 + Math.random()*2 });
  }
  battleFloatingTexts.push({ x: diso.x, y: diso.y - 25, text: '-' + dmg, color: '#ff4444', life: 50 });

  // Greek fire burn DOT
  if (proj.type === 'greek_fire' && defender.hp > 0) {
    defender.burning = 3;
  }

  // AOE splash
  if (proj.aoe > 0) {
    const targets = isPlayerUnit ? battle.enemyUnits : battle.playerUnits;
    for (const t of targets) {
      if (t === defender || t.hp <= 0) continue;
      if (getEuclidDist(t, defender) <= proj.aoe) {
        let splashDmg = Math.ceil(dmg * 0.5);
        t.hp -= splashDmg;
        const tiso = toBattleIso(t.x, t.y);
        battleFloatingTexts.push({ x: tiso.x, y: tiso.y - 25, text: '-' + splashDmg, color: '#ffaa00', life: 40 });
      }
    }
  }

  // Check for deaths
  battle.enemyUnits = battle.enemyUnits.filter(u => u.hp > 0);
  battle.playerUnits = battle.playerUnits.filter(u => u.hp > 0);
  if (battle.enemyUnits.length === 0) { battleVictory(); return; }
  if (battle.playerUnits.length === 0) { battleDefeat(); return; }
}

//  BATTLE RESOLUTION 
function battleVictory() {
  const ctx2 = battle.enemyContext;
  const def = ctx2.isFort ? ENEMY_TYPES.bandit : ENEMY_TYPES[ctx2.type];

  // Return units to army: survivors keep HP, dead respawn at 50% max, then all heal 50% missing
  for (const t of TROOP_ORDER) {
    if (!Array.isArray(player.army[t])) player.army[t] = [];
    const maxHp = BATTLE_STATS[t].hp + upgrades.reinforced * 3;
    // Add surviving units with their current HP
    for (const u of battle.playerUnits) {
      if (u.type === t) player.army[t].push(u.hp);
    }
    // Add dead units at 50% HP (respawn)
    const deployed = (battle.deployedSnapshot[t] || []).length;
    const survived = battle.playerUnits.filter(u => u.type === t).length;
    const dead = deployed - survived;
    for (let i = 0; i < dead; i++) player.army[t].push(Math.ceil(maxHp * 0.5));
    // Partial heal: all units heal 50% of missing HP
    for (let i = 0; i < player.army[t].length; i++) {
      const hp = player.army[t][i];
      player.army[t][i] = Math.min(maxHp, hp + Math.ceil((maxHp - hp) * 0.5));
    }
  }

  // Morale boost
  morale = Math.min(5, morale + 1);

  // Rewards
  const goldReward = Math.floor(ctx2.str * (def.goldMul || 0.3)) + randInt(2, 6);
  gold += goldReward;
  kills++;

  let capturedText = '';
  if (!ctx2.isFort) {
    const yieldType = def.yields || 'militia';
    const yieldDef = TROOP_TYPES[yieldType];
    const captureRate = Math.max(0.2, 0.4 - getDifficulty() * 0.02);
    const capturedCount = Math.max(1, Math.ceil(ctx2.str * captureRate / yieldDef.str));
    addTroops(player.army, yieldType, capturedCount);
    capturedText = '+' + capturedCount + ' ' + yieldDef.name;
    // Remove enemy from overworld
    const eIdx = ctx2.arr.indexOf(ctx2.arr[ctx2.index]);
    if (eIdx !== -1) ctx2.arr.splice(eIdx, 1);
  } else {
    // Castle capture  convert to player castle
    const maCount = Math.max(1, Math.ceil(ctx2.str * 0.15 / TROOP_TYPES.menatarms.str));
    const milCount = Math.max(1, Math.ceil(ctx2.str * 0.1 / TROOP_TYPES.militia.str));
    addTroops(player.army, 'menatarms', maCount);
    addTroops(player.army, 'militia', milCount);
    capturedText = '+' + maCount + ' Men-at-Arms, +' + milCount + ' Militia\nCastle Captured!';
    const capturedFort = forts[ctx2.index];
    playerForts.push({ gx: capturedFort.x, gy: capturedFort.y, garrison: newArmy(), walls: 0, turrets: 0, mines: 0, isHome: false });
    forts.splice(ctx2.index, 1);
    recalcTerritory();
    if (typeof castlesCaptured !== 'undefined') castlesCaptured++;
  }

  battle.resultMsg = 'VICTORY!\nYour forces are victorious!\n+' + goldReward + ' gold\n' + capturedText +
    '\nAll troops recovered  Morale: ' + (morale > 0 ? '+' : '') + morale;
  gameMode = 'battle_result';

  spawnParticles(player.x, player.y, '#4fc3f7', 20, 5);
  updateHUD();

  // Check game win
  if (forts.length === 0) {
    setTimeout(() => { checkGameWin(); }, 500);
  }
  if (typeof checkMilestones === 'function') checkMilestones();
}

function battleDefeat() {
  const ctx2 = battle.enemyContext;

  // Morale loss
  morale = Math.max(-5, morale - 1);

  // Return units to army: survivors keep HP, dead respawn at 50% max, then all heal 50% missing
  for (const t of TROOP_ORDER) {
    if (!Array.isArray(player.army[t])) player.army[t] = [];
    const maxHp = BATTLE_STATS[t].hp + upgrades.reinforced * 3;
    // Add surviving units with their current HP
    for (const u of battle.playerUnits) {
      if (u.type === t) player.army[t].push(u.hp);
    }
    // Add dead units at 50% HP (respawn)
    const deployed = (battle.deployedSnapshot[t] || []).length;
    const survived = battle.playerUnits.filter(u => u.type === t).length;
    const dead = deployed - survived;
    for (let i = 0; i < dead; i++) player.army[t].push(Math.ceil(maxHp * 0.5));
    // Partial heal: all units heal 50% of missing HP
    for (let i = 0; i < player.army[t].length; i++) {
      const hp = player.army[t][i];
      player.army[t][i] = Math.min(maxHp, hp + Math.ceil((maxHp - hp) * 0.5));
    }
  }

  // Reduce enemy str proportional to damage dealt
  const totalEnemyHp = battle.enemyUnits.reduce((s, u) => s + u.maxHp, 0);
  const remainingHp = battle.enemyUnits.reduce((s, u) => s + u.hp, 0);
  const dmgFraction = 1 - (remainingHp / totalEnemyHp);
  if (!ctx2.isFort) {
    const e = ctx2.arr[ctx2.index];
    if (e) e.str = Math.max(1, Math.ceil(e.str * (1 - dmgFraction)));
  }

  // Check if we lost a castle defense
  if (battle.turretBonus !== undefined) {
    // Was defending a castle  find which castle and destroy it
    const defFort = playerForts.findIndex(f => f.gx === player.x && f.gy === player.y);
    if (defFort !== -1) {
      const lostFort = playerForts[defFort];
      spawnFloatingText(lostFort.gx, lostFort.gy, 'Castle Lost!', '#f44336');
      playerForts.splice(defFort, 1);
      recalcTerritory();
    }
  }
  // Clear pending attacks for this battle
  pendingAttacks = pendingAttacks.filter(pa => !playerForts[pa.fortIndex] || playerForts[pa.fortIndex].gx !== player.x);

  // Push player back (infinite map  just use Math.max(0, ...))
  player.x = Math.max(0, player.x - player.lastDx);
  player.y = Math.max(0, player.y - player.lastDy);
  playerVisual.x = player.x;
  playerVisual.y = player.y;

  let defeatMsg = 'DEFEAT!\nYour troops regroup and recover.\nMorale: ' + (morale > 0 ? '+' : '') + morale;
  if (battle.turretBonus !== undefined) defeatMsg += '\nCastle destroyed by enemy!';
  battle.resultMsg = defeatMsg;
  gameMode = 'battle_result';
  shake = 6;
  updateHUD();
}

function handleResultClick() {
  gameMode = 'overworld';
  battle = null;
}

//  DEPLOY PHASE 
function handleDeployClick(mx, my) {
  const panelY = H - PANEL_H;

  // Check if clicking army panel to select troop type
  if (my >= panelY) {
    const slotW = W / TROOP_ORDER.length;
    const slotIdx = Math.floor(mx / slotW);
    if (slotIdx >= 0 && slotIdx < TROOP_ORDER.length) {
      const type = TROOP_ORDER[slotIdx];
      if (battle.deployArmy[type] && battle.deployArmy[type].length > 0) {
        deploySelectedType = type;
      }
    }
    return;
  }

  // Check "Start Battle" button area (top right)
  if (mx >= W - 160 && mx <= W - 10 && my >= 10 && my <= 45 && battle.playerUnits.length > 0) {
    startBattle();
    return;
  }

  // Convert click to game-space (continuous, not snapped)
  const grid = fromBattleIso(mx, my);
  const gx = Math.round(grid.x * 2) / 2; // snap to 0.5 increments
  const gy = Math.round(grid.y * 2) / 2;
  if (gx < 0 || gx >= BCOLS || gy < 0 || gy >= BROWS) return;

  // Click on existing placed unit -> pick it up (within 0.6 radius)
  const existIdx = battle.playerUnits.findIndex(u => getEuclidDist(u, {x:gx,y:gy}) < 0.6);
  if (existIdx !== -1) {
    const removed = battle.playerUnits.splice(existIdx, 1)[0];
    if (!Array.isArray(battle.deployArmy[removed.type])) battle.deployArmy[removed.type] = [];
    battle.deployArmy[removed.type].push(removed.persistentHp || removed.maxHp);
    return;
  }

  // Place unit in deployment zone (left third: x < 3)
  if (gx < 3 && deploySelectedType && battle.deployArmy[deploySelectedType] && battle.deployArmy[deploySelectedType].length > 0) {
    const gy2 = Math.floor(gy);
    if (gy2 >= 0 && gy2 < BROWS && battle.grid[gy2] && battle.grid[gy2][Math.floor(gx)] === 'wall') return;
    if (battle.playerUnits.some(u => getEuclidDist(u, {x:gx,y:gy}) < 0.5)) return;

    const stats = BATTLE_STATS[deploySelectedType];
    const popped = battle.deployArmy[deploySelectedType].pop();
    const persistHp = (typeof popped === 'object' && popped !== null) ? popped.hp : popped;
    const baseMaxHp = stats.hp + upgrades.reinforced * 3;
    const unitHp = Math.min(persistHp, baseMaxHp);
    battle.playerUnits.push({
      type: deploySelectedType,
      hp: unitHp, maxHp: baseMaxHp, persistentHp: persistHp,
      atk: stats.atk + upgrades.armorPiercing + engineerATKBonus,
      range: stats.range + upgrades.extendedMag,
      aoe: stats.aoe + (['pikemen','crossbowmen','catapults'].includes(deploySelectedType) ? upgrades.explosiveRounds : 0),
      heavy: false,
      x: gx, y: gy, vx: gx, vy: gy,
      moveSpeed: stats.moveSpeed, attackRate: stats.attackRate, attackCD: 0,
    });
    if (battle.deployArmy[deploySelectedType].length <= 0) deploySelectedType = null;
  }
}

//  BATTLE PHASE INPUT (Simulation Controls) 
function handleBattleClick(mx, my) {
  // Speed buttons (top right area)
  // Pause/Play button: x=[W-155, W-100], y=[10, 38]
  if (mx >= W - 155 && mx <= W - 100 && my >= 10 && my <= 38) {
    battle.simPaused = !battle.simPaused;
    return;
  }
  // 1x button: x=[W-95, W-70], y=[10, 38]
  if (mx >= W - 95 && mx <= W - 70 && my >= 10 && my <= 38) {
    battle.simSpeed = 1; battle.simPaused = false;
    return;
  }
  // 2x button: x=[W-65, W-40], y=[10, 38]
  if (mx >= W - 65 && mx <= W - 40 && my >= 10 && my <= 38) {
    battle.simSpeed = 2; battle.simPaused = false;
    return;
  }
  // 4x button: x=[W-35, W-10], y=[10, 38]
  if (mx >= W - 35 && mx <= W - 10 && my >= 10 && my <= 38) {
    battle.simSpeed = 4; battle.simPaused = false;
    return;
  }
}

// (Old turn-based AI removed  replaced by updateRealTimeBattle)

//  BATTLE SMOOTH ANIMATION 
function updateBattleSmooth() {
  if (!battle) return;
  const spd = 0.25;

  // Lerp unit visual positions toward actual positions
  const _allUnits = battle.playerUnits.concat(battle.enemyUnits);
  for (const u of _allUnits) {
    if (u.vx === undefined) { u.vx = u.x; u.vy = u.y; }
    u.vx += (u.x - u.vx) * spd;
    u.vy += (u.y - u.vy) * spd;
    if (Math.abs(u.x - u.vx) < 0.01) u.vx = u.x;
    if (Math.abs(u.y - u.vy) < 0.01) u.vy = u.y;
  }

  // Update battle particles
  for (let i = battleParticles.length - 1; i >= 0; i--) {
    const p = battleParticles[i];
    p.x += p.vx; p.y += p.vy;
    p.vy += 0.15;
    p.vx *= 0.97;
    p.life--;
    if (p.life <= 0) battleParticles.splice(i, 1);
  }

  // Update battle floating texts
  for (let i = battleFloatingTexts.length - 1; i >= 0; i--) {
    const ft = battleFloatingTexts[i];
    ft.y -= 0.6;
    ft.life--;
    if (ft.life <= 0) battleFloatingTexts.splice(i, 1);
  }

  // Shake
  if (shake > 0) shake *= 0.88;
  if (shake < 0.3) shake = 0;

  // Real-time battle simulation (runs every frame when not paused)
  if (gameMode === 'battle') {
    const steps = battle.simSpeed || 1;
    for (let s = 0; s < steps; s++) {
      updateRealTimeBattle();
      updateProjectiles();
    }
  }
}

//  BATTLE RENDERING 
function drawBattle() {
  if (!battle) return;

  const shx = shake > 0.1 ? (Math.random() - 0.5) * shake : 0;
  const shy = shake > 0.1 ? (Math.random() - 0.5) * shake : 0;
  ctx.save();
  ctx.translate(shx, shy);

  ctx.fillStyle = '#0a0e14';
  ctx.fillRect(0, 0, W, H);

  // Draw terrain backdrop (no grid lines, just ground tiles)
  for (let sum = 0; sum < BCOLS + BROWS - 1; sum++) {
    for (let x = Math.max(0, sum - (BROWS - 1)); x <= Math.min(BCOLS - 1, sum); x++) {
      const y = sum - x;
      if (y < 0 || y >= BROWS) continue;
      const iso = toBattleIso(x, y);
      const tileType = battle.grid[y][x];

      if (tileType === 'wall') {
        drawWall(iso.x, iso.y, x, y);
      } else {
        drawGround(iso.x, iso.y, (x * 7 + y * 13) % 100 / 100, x, y);
      }

      // Deployment zone highlight
      if (gameMode === 'deploy' && x < 3 && tileType !== 'wall') {
        ctx.fillStyle = 'rgba(79,195,247,0.1)';
        isoDiamondPath(iso.x, iso.y);
        ctx.fill();
        ctx.strokeStyle = 'rgba(79,195,247,0.25)';
        ctx.lineWidth = 1;
        isoDiamondPath(iso.x, iso.y);
        ctx.stroke();
      }
    }
  }

  // Collect all alive units and sort by vy for painter's algorithm
  const allUnits = [];
  for (const u of battle.playerUnits) {
    if (u.hp > 0) allUnits.push({ unit: u, isPlayer: true });
  }
  for (const u of battle.enemyUnits) {
    if (u.hp > 0) allUnits.push({ unit: u, isPlayer: false });
  }
  allUnits.sort((a, b) => (a.unit.vy + a.unit.vx) - (b.unit.vy + b.unit.vx));

  // Draw projectiles
  for (const p of battleProjectiles) {
    if (p.delay > 0) continue;
    const piso = toBattleIso(p.x, p.y);
    const sx = piso.x, sy = piso.y;
    const alpha = Math.min(1, p.life / 10);
    ctx.globalAlpha = alpha;
    if (p.type === 'greek_fire') {
      // Fire visual  same as original flame
      ctx.fillStyle = '#ff9800';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 4, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ffeb3b';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 2, 0, Math.PI * 2); ctx.fill();
    } else if (p.type === 'heal') {
      // Golden sparkle beam
      const tu = p.targetUnit;
      const tiso = toBattleIso(tu && tu.hp > 0 ? tu.vx : p.tx, tu && tu.hp > 0 ? tu.vy : p.ty);
      ctx.strokeStyle = '#ffd54f'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(sx, sy - 8); ctx.lineTo(tiso.x, tiso.y - 8); ctx.stroke();
      ctx.fillStyle = '#fff8e1';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 2 + Math.random(), 0, Math.PI * 2); ctx.fill();
    } else if (p.type === 'pike_thrust') {
      // Short brown line  pike thrust
      const dx = p.tx - p.x, dy = p.ty - p.y;
      const len = Math.sqrt(dx * dx + dy * dy) || 1;
      ctx.strokeStyle = '#8d6e63'; ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(sx, sy - 8);
      ctx.lineTo(sx - (dx / len) * 6, sy - 8 - (dy / len) * 6);
      ctx.stroke();
      ctx.fillStyle = '#5d4037';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 1.5, 0, Math.PI * 2); ctx.fill();
    } else if (p.type === 'lance_charge') {
      // Silver streak
      const dx = p.tx - p.x, dy = p.ty - p.y;
      const len = Math.sqrt(dx * dx + dy * dy) || 1;
      ctx.strokeStyle = '#c0c0c0'; ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(sx, sy - 8);
      ctx.lineTo(sx - (dx / len) * 8, sy - 8 - (dy / len) * 8);
      ctx.stroke();
      ctx.fillStyle = '#e0e0e0';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 2, 0, Math.PI * 2); ctx.fill();
    } else if (p.type === 'stone') {
      // Gray rock with arc
      const progress = 1 - (p.life / 60);
      const arcHeight = Math.sin(progress * Math.PI) * 30;
      ctx.fillStyle = '#666';
      ctx.beginPath(); ctx.arc(sx, sy - 8 - arcHeight, 4, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#888';
      ctx.beginPath(); ctx.arc(sx - 1, sy - 9 - arcHeight, 2, 0, Math.PI * 2); ctx.fill();
    } else if (p.type === 'bolt_volley') {
      // Short brown bolt
      const dx = p.tx - p.x, dy = p.ty - p.y;
      const len = Math.sqrt(dx * dx + dy * dy) || 1;
      ctx.strokeStyle = '#8d6e63'; ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(sx, sy - 8);
      ctx.lineTo(sx - (dx / len) * 4, sy - 8 - (dy / len) * 4);
      ctx.stroke();
    } else if (p.type === 'magic_bolt') {
      // Purple beam
      ctx.strokeStyle = '#ce93d8'; ctx.lineWidth = 2;
      const tdx = p.tx - p.x, tdy = p.ty - p.y;
      const tlen = Math.sqrt(tdx*tdx + tdy*tdy) || 1;
      ctx.beginPath(); ctx.moveTo(sx, sy - 8);
      ctx.lineTo(sx - (tdx/tlen)*6, sy - 8 - (tdy/tlen)*6); ctx.stroke();
      ctx.fillStyle = '#e1bee7';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 2, 0, Math.PI * 2); ctx.fill();
    } else if (p.type === 'club_smash') {
      // Brown/green impact  club smash
      ctx.fillStyle = '#76ff03';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#33691e';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 1.5, 0, Math.PI * 2); ctx.fill();
    } else if (p.type === 'thrown_dagger') {
      // Small spinning dagger
      const dx = p.tx - p.x, dy = p.ty - p.y;
      const len = Math.sqrt(dx * dx + dy * dy) || 1;
      ctx.strokeStyle = '#b0bec5'; ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(sx, sy - 8);
      ctx.lineTo(sx - (dx / len) * 4, sy - 8 - (dy / len) * 4);
      ctx.stroke();
      ctx.fillStyle = '#cfd8dc';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 1.5, 0, Math.PI * 2); ctx.fill();
    } else if (p.type === 'cannonball') {
      // Dark iron ball
      ctx.fillStyle = '#333';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 3.5, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#555';
      ctx.beginPath(); ctx.arc(sx - 1, sy - 9, 1.5, 0, Math.PI * 2); ctx.fill();
    } else {
      // Default arrow: brown shaft with fletching
      const dx = p.tx - p.x, dy = p.ty - p.y;
      const len = Math.sqrt(dx * dx + dy * dy) || 1;
      ctx.strokeStyle = '#8d6e63'; ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(sx, sy - 8);
      ctx.lineTo(sx - (dx / len) * 6, sy - 8 - (dy / len) * 6);
      ctx.stroke();
      // Fletching (small V at tail)
      const tailX = sx - (dx / len) * 6;
      const tailY = sy - 8 - (dy / len) * 6;
      ctx.strokeStyle = '#a1887f'; ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(tailX - 1.5, tailY - 1.5);
      ctx.lineTo(tailX, tailY);
      ctx.lineTo(tailX - 1.5, tailY + 1.5);
      ctx.stroke();
      // Arrowhead
      ctx.fillStyle = '#555';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 1, 0, Math.PI * 2); ctx.fill();
    }
  }
  ctx.globalAlpha = 1;

  // Draw all units y-sorted
  for (const entry of allUnits) {
    const u = entry.unit;
    const iso = toBattleIso(u.vx, u.vy);
    drawBattleUnit(u, iso.x, iso.y, entry.isPlayer, false);
  }

  // Battle particles
  for (const p of battleParticles) {
    const alpha = p.life / (p.maxLife || 20);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(p.x, p.y, (p.size || 2) * alpha, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Battle floating texts
  for (const ft of battleFloatingTexts) {
    const alpha = Math.min(1, ft.life / 20);
    ctx.globalAlpha = alpha;
    ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillText(ft.text, ft.x + 1, ft.y + 1);
    ctx.fillStyle = ft.color; ctx.fillText(ft.text, ft.x, ft.y);
  }
  ctx.globalAlpha = 1;

  //  TOP UI BAR 
  ctx.fillStyle = 'rgba(10,14,20,0.85)';
  ctx.fillRect(0, 0, W, 50);
  ctx.fillStyle = '#3a4a6a'; ctx.fillRect(0, 50, W, 1);

  ctx.font = 'bold 16px "Segoe UI", sans-serif'; ctx.textAlign = 'center';
  if (gameMode === 'deploy') {
    ctx.fillStyle = '#4fc3f7';
    ctx.fillText('DEPLOY YOUR TROOPS', W / 2, 25);
    ctx.font = '11px sans-serif'; ctx.fillStyle = '#8899aa';
    ctx.fillText('Click troop in panel below, then click deployment zone (blue). Press ESC to cancel.', W / 2, 42);
  } else if (gameMode === 'battle') {
    const pauseText = battle.simPaused ? ' [PAUSED]' : '';
    const pAlive = battle.playerUnits.filter(u => u.hp > 0).length;
    const eAlive = battle.enemyUnits.filter(u => u.hp > 0).length;
    ctx.fillStyle = '#4fc3f7';
    ctx.fillText('BATTLE \u2014 ' + pAlive + ' vs ' + eAlive + pauseText, W / 2, 25);
    ctx.font = '11px sans-serif'; ctx.fillStyle = '#8899aa';
    ctx.fillText('Space = Pause/Resume    1/2/3 = Speed', W / 2, 42);
  } else if (gameMode === 'battle_result') {
    ctx.fillStyle = battle.resultMsg.startsWith('VICTORY') ? '#4caf50' : '#ff5252';
    ctx.fillText(battle.resultMsg.split('\n')[0], W / 2, 25);
    ctx.font = '11px sans-serif'; ctx.fillStyle = '#aabbcc';
    ctx.fillText('Click anywhere to continue', W / 2, 42);
  }

  // Start Battle button
  if (gameMode === 'deploy' && battle.playerUnits.length > 0) {
    const bx = W - 160, bw = 150, bh = 30, by2 = 12;
    ctx.fillStyle = '#2e7d32';
    ctx.fillRect(bx, by2, bw, bh);
    ctx.strokeStyle = '#4caf50'; ctx.lineWidth = 1; ctx.strokeRect(bx, by2, bw, bh);
    ctx.fillStyle = '#fff'; ctx.font = 'bold 13px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('START BATTLE (' + battle.playerUnits.length + ')', bx + bw / 2, by2 + 20);
  }
  if (gameMode === 'battle') {
    // Pause/Play button
    const pbx = W - 155, pbw = 50, pbh = 28, pby = 10;
    ctx.fillStyle = battle.simPaused ? '#e65100' : '#1565c0';
    ctx.fillRect(pbx, pby, pbw, pbh);
    ctx.strokeStyle = battle.simPaused ? '#ff9800' : '#42a5f5'; ctx.lineWidth = 1;
    ctx.strokeRect(pbx, pby, pbw, pbh);
    ctx.fillStyle = '#fff'; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText(battle.simPaused ? '\u25B6' : '\u275A\u275A', pbx + pbw / 2, pby + 19);
    // Speed buttons: 1x, 2x, 4x
    const speeds = [1, 2, 4];
    const labels = ['1x', '2x', '4x'];
    for (let si = 0; si < 3; si++) {
      const sbx = W - 95 + si * 30, sbw = 25;
      const active = battle.simSpeed === speeds[si];
      ctx.fillStyle = active ? '#2e7d32' : '#263238';
      ctx.fillRect(sbx, pby, sbw, pbh);
      ctx.strokeStyle = active ? '#4caf50' : '#455a64'; ctx.lineWidth = 1;
      ctx.strokeRect(sbx, pby, sbw, pbh);
      ctx.fillStyle = active ? '#fff' : '#8899aa'; ctx.font = 'bold 10px sans-serif';
      ctx.fillText(labels[si], sbx + sbw / 2, pby + 19);
    }
  }

  //  BOTTOM PANEL 
  if (gameMode === 'deploy') {
    drawDeployPanel();
  } else if (gameMode === 'battle') {
    drawBattleInfoPanel();
  } else if (gameMode === 'battle_result') {
    drawBattleResultPanel();
  }

  ctx.restore();
}

function drawBattleUnit(unit, sx, sy, isPlayer, selected) {
  const bob = Math.sin(animFrame * 0.1 + unit.x * 3) * 1;
  const cy = sy - 10 + bob;

  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.ellipse(sx + 2, sy + 4, 8, 3, 0.1, 0, Math.PI * 2); ctx.fill();

  // Team base circle
  const baseColor = isPlayer ? 'rgba(30,120,200,0.5)' : 'rgba(200,50,50,0.5)';
  ctx.fillStyle = baseColor;
  ctx.beginPath(); ctx.ellipse(sx, sy + 2, 10, 5, 0, 0, Math.PI * 2); ctx.fill();

  // Selected highlight
  if (selected) {
    const selPulse = 0.4 + Math.sin(animFrame * 0.12) * 0.2;
    ctx.strokeStyle = 'rgba(79,195,247,' + selPulse + ')';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.ellipse(sx, sy + 2, 12, 6, 0, 0, Math.PI * 2); ctx.stroke();
  }

  // Unit attacking glow (fires when attackCD is low)
  if (battle && unit.attackCD !== undefined && unit.attackCD <= 5) {
    const glowPulse = 0.4 + Math.sin(animFrame * 0.2) * 0.3;
    const glowColor = isPlayer ? 'rgba(79,195,247,' : 'rgba(255,80,80,';
    ctx.strokeStyle = glowColor + glowPulse + ')';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.ellipse(sx, sy + 2, 13, 6, 0, 0, Math.PI * 2); ctx.stroke();
  }

  // Draw unit body (simplified sprites based on type)
  const def = isPlayer ? BATTLE_STATS[unit.type] : ENEMY_BATTLE_STATS[unit.type];
  const enemyDef = !isPlayer ? ENEMY_TYPES[unit.type] : null;
  const color = isPlayer ? '#4caf50' : (enemyDef ? enemyDef.color : '#e53935');
  const dark = isPlayer ? '#2e7d32' : (enemyDef ? enemyDef.dark : '#b71c1c');

  if (unit.type === 'troll') {
    // Large green hulk with club and fangs
    // Legs
    ctx.fillStyle = dark; ctx.fillRect(sx - 5, cy + 2, 4, 6); ctx.fillRect(sx + 1, cy + 2, 4, 6);
    // Body  large green torso
    ctx.fillStyle = color; ctx.fillRect(sx - 7, cy - 6, 14, 10);
    // Arms  thick
    ctx.fillStyle = dark; ctx.fillRect(sx - 10, cy - 4, 5, 8); ctx.fillRect(sx + 5, cy - 4, 5, 8);
    // Head  large with green skin
    ctx.fillStyle = '#689f38'; ctx.beginPath(); ctx.arc(sx, cy - 9, 3.5, 0, Math.PI * 2); ctx.fill();
    // Fangs
    ctx.fillStyle = '#fff';
    ctx.fillRect(sx - 2, cy - 6.5, 1.5, 2);
    ctx.fillRect(sx + 0.5, cy - 6.5, 1.5, 2);
    // Eyes  glowing yellow
    ctx.fillStyle = '#ffff00';
    ctx.beginPath(); ctx.arc(sx - 1.5, cy - 9, 1, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(sx + 1.5, cy - 9, 1, 0, Math.PI * 2); ctx.fill();
    // Club in right hand
    ctx.fillStyle = '#5d4037'; ctx.fillRect(sx + 8, cy - 8, 3, 12);
    ctx.fillStyle = '#4e342e'; ctx.fillRect(sx + 7, cy - 10, 5, 4);
    // Glow effect
    const gp = 0.2 + Math.sin(animFrame * 0.15) * 0.15;
    ctx.fillStyle = 'rgba(255,255,0,' + gp + ')';
    ctx.beginPath(); ctx.arc(sx, cy - 9, 5, 0, Math.PI * 2); ctx.fill();
  } else if (unit.type === 'dark_mage') {
    // Purple robes, glowing staff, arcane symbols
    // Legs (hidden under robes, just show robe bottom)
    ctx.fillStyle = '#4a148c'; ctx.fillRect(sx - 3, cy + 3, 2.5, 5); ctx.fillRect(sx + 0.5, cy + 3, 2.5, 5);
    // Body  purple robes
    ctx.fillStyle = '#6a1b9a'; ctx.fillRect(sx - 5, cy - 4, 10, 9);
    // Robe flare at bottom
    ctx.fillStyle = '#4a148c';
    ctx.beginPath(); ctx.moveTo(sx - 6, cy + 5); ctx.lineTo(sx - 8, cy + 8);
    ctx.lineTo(sx + 8, cy + 8); ctx.lineTo(sx + 6, cy + 5); ctx.closePath(); ctx.fill();
    // Sleeves
    ctx.fillStyle = '#7b1fa2'; ctx.fillRect(sx - 8, cy - 2, 4, 7); ctx.fillRect(sx + 4, cy - 2, 4, 7);
    // Head  hooded
    ctx.fillStyle = '#4a148c';
    ctx.beginPath(); ctx.arc(sx, cy - 7, 4, 0, Math.PI * 2); ctx.fill();
    // Face inside hood
    ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(sx, cy - 7, 2.5, 0, Math.PI * 2); ctx.fill();
    // Glowing eyes
    ctx.fillStyle = '#76ff03';
    ctx.beginPath(); ctx.arc(sx - 1.5, cy - 7.5, 1.3, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(sx + 1.5, cy - 7.5, 1.3, 0, Math.PI * 2); ctx.fill();
    // Staff with glowing orb
    ctx.fillStyle = '#5d4037'; ctx.fillRect(sx + 6, cy - 14, 2, 22);
    ctx.fillStyle = '#ce93d8'; ctx.beginPath(); ctx.arc(sx + 7, cy - 15, 3, 0, Math.PI * 2); ctx.fill();
    // Arcane glow around orb
    const gp = 0.3 + Math.sin(animFrame * 0.12) * 0.2;
    ctx.fillStyle = 'rgba(206,147,216,' + gp + ')';
    ctx.beginPath(); ctx.arc(sx + 7, cy - 15, 5, 0, Math.PI * 2); ctx.fill();
    // Arcane symbols floating
    ctx.fillStyle = 'rgba(206,147,216,' + (gp * 0.6) + ')';
    ctx.font = '6px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('\u2726', sx - 4, cy - 12 + Math.sin(animFrame * 0.08) * 2);
    ctx.fillText('\u2727', sx + 2, cy - 14 + Math.cos(animFrame * 0.08) * 2);
  } else if (unit.type === 'war_elephant') {
    // Large gray elephant with howdah
    // Legs  four thick pillars
    ctx.fillStyle = '#616161';
    ctx.fillRect(sx - 10, cy + 1, 4, 7);
    ctx.fillRect(sx - 4, cy + 1, 4, 7);
    ctx.fillRect(sx + 2, cy + 1, 4, 7);
    ctx.fillRect(sx + 7, cy + 1, 4, 7);
    // Body  large oval
    ctx.fillStyle = '#9e9e9e';
    ctx.beginPath(); ctx.ellipse(sx, cy - 2, 14, 7, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#bdbdbd';
    ctx.beginPath(); ctx.ellipse(sx, cy - 3, 12, 5, 0, 0, Math.PI * 2); ctx.fill();
    // Head
    ctx.fillStyle = '#9e9e9e'; ctx.beginPath(); ctx.arc(sx + 12, cy - 4, 5, 0, Math.PI * 2); ctx.fill();
    // Trunk
    ctx.strokeStyle = '#757575'; ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.moveTo(sx + 16, cy - 2); ctx.quadraticCurveTo(sx + 20, cy + 4, sx + 17, cy + 7); ctx.stroke();
    // Tusks
    ctx.fillStyle = '#fff9c4';
    ctx.beginPath(); ctx.moveTo(sx + 14, cy - 2); ctx.lineTo(sx + 20, cy - 5); ctx.lineTo(sx + 15, cy); ctx.closePath(); ctx.fill();
    // Eye
    ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(sx + 14, cy - 5, 1, 0, Math.PI * 2); ctx.fill();
    // Howdah (platform on top)
    ctx.fillStyle = '#5d4037'; ctx.fillRect(sx - 6, cy - 11, 12, 5);
    ctx.fillStyle = '#8d6e63'; ctx.fillRect(sx - 5, cy - 10, 10, 3);
    // Archer in howdah
    ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(sx, cy - 14, 2, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#f44336'; ctx.fillRect(sx - 2, cy - 12, 4, 3);
  } else if (unit.type === 'dragon_rider') {
    // Winged beast with rider
    // Body  serpentine
    ctx.fillStyle = dark;
    ctx.beginPath(); ctx.moveTo(sx - 10, cy); ctx.lineTo(sx - 5, cy - 6);
    ctx.lineTo(sx + 6, cy - 6); ctx.lineTo(sx + 8, cy);
    ctx.lineTo(sx + 6, cy + 4); ctx.lineTo(sx - 8, cy + 4); ctx.closePath(); ctx.fill();
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.moveTo(sx - 8, cy + 1); ctx.lineTo(sx - 3, cy - 4);
    ctx.lineTo(sx + 4, cy - 4); ctx.lineTo(sx + 6, cy + 1);
    ctx.lineTo(sx + 4, cy + 3); ctx.lineTo(sx - 6, cy + 3); ctx.closePath(); ctx.fill();
    // Wings (flapping)
    const wingAngle = Math.sin(animFrame * 0.15) * 0.3;
    ctx.fillStyle = 'rgba(100,100,100,0.7)';
    ctx.beginPath();
    ctx.moveTo(sx - 2, cy - 4);
    ctx.lineTo(sx - 14, cy - 12 + wingAngle * 10);
    ctx.lineTo(sx - 8, cy - 2);
    ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(sx + 2, cy - 4);
    ctx.lineTo(sx + 14, cy - 12 + wingAngle * 10);
    ctx.lineTo(sx + 8, cy - 2);
    ctx.closePath(); ctx.fill();
    // Dragon head
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.arc(sx + 8, cy - 4, 3, 0, Math.PI * 2); ctx.fill();
    // Dragon eye
    ctx.fillStyle = '#ff0'; ctx.beginPath(); ctx.arc(sx + 9, cy - 5, 1, 0, Math.PI * 2); ctx.fill();
    // Rider on top
    ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(sx, cy - 10, 2.5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#333'; ctx.fillRect(sx - 2, cy - 8, 4, 4);
    // Tail
    ctx.strokeStyle = dark; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(sx - 8, cy + 2); ctx.quadraticCurveTo(sx - 14, cy + 6, sx - 16, cy + 2); ctx.stroke();
  } else if (unit.type === 'knights') {
    // Mounted knight on horse with lance
    // Horse legs
    ctx.fillStyle = '#5d4037';
    ctx.fillRect(sx - 8, cy + 2, 2, 6);
    ctx.fillRect(sx - 4, cy + 2, 2, 6);
    ctx.fillRect(sx + 3, cy + 2, 2, 6);
    ctx.fillRect(sx + 7, cy + 2, 2, 6);
    // Horse body
    ctx.fillStyle = '#795548';
    ctx.beginPath(); ctx.ellipse(sx, cy, 11, 5, 0, 0, Math.PI * 2); ctx.fill();
    // Horse head
    ctx.fillStyle = '#6d4c41'; ctx.beginPath(); ctx.arc(sx + 10, cy - 3, 3.5, 0, Math.PI * 2); ctx.fill();
    // Horse eye
    ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(sx + 11, cy - 4, 0.8, 0, Math.PI * 2); ctx.fill();
    // Barding (horse armor)
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.ellipse(sx, cy - 1, 10, 3, 0, 0, Math.PI * 2); ctx.fill();
    // Knight body on horse
    ctx.fillStyle = dark; ctx.fillRect(sx - 3, cy - 10, 6, 7);
    // Knight helmet
    ctx.fillStyle = '#9e9e9e'; ctx.beginPath(); ctx.arc(sx, cy - 13, 3, 0, Math.PI * 2); ctx.fill();
    // Visor slit
    ctx.fillStyle = '#333'; ctx.fillRect(sx - 2, cy - 13.5, 4, 1);
    // Lance
    ctx.fillStyle = '#8d6e63'; ctx.fillRect(sx + 3, cy - 18, 1.5, 22);
    // Lance tip
    ctx.fillStyle = '#bdbdbd';
    ctx.beginPath(); ctx.moveTo(sx + 3, cy - 18); ctx.lineTo(sx + 3.75, cy - 22); ctx.lineTo(sx + 4.5, cy - 18); ctx.closePath(); ctx.fill();
    // Shield
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.moveTo(sx - 5, cy - 10); ctx.lineTo(sx - 8, cy - 8);
    ctx.lineTo(sx - 5, cy - 4); ctx.closePath(); ctx.fill();
  } else if (unit.type === 'catapults') {
    // Wooden siege frame
    // Base frame
    ctx.fillStyle = '#5d4037'; ctx.fillRect(sx - 10, cy + 2, 20, 4);
    // Wheels
    ctx.fillStyle = '#4e342e';
    ctx.beginPath(); ctx.arc(sx - 7, cy + 7, 3, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(sx + 7, cy + 7, 3, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#3e2723';
    ctx.beginPath(); ctx.arc(sx - 7, cy + 7, 1.5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(sx + 7, cy + 7, 1.5, 0, Math.PI * 2); ctx.fill();
    // Upright frame
    ctx.fillStyle = '#6d4c41'; ctx.fillRect(sx - 2, cy - 10, 4, 14);
    // Throwing arm (animated)
    const armAngle = Math.sin(animFrame * 0.08) * 0.2 - 0.3;
    ctx.save();
    ctx.translate(sx, cy - 6);
    ctx.rotate(armAngle);
    ctx.fillStyle = '#795548'; ctx.fillRect(-1, -12, 2, 14);
    // Sling/bucket at end
    ctx.fillStyle = '#4e342e'; ctx.fillRect(-2, -14, 4, 3);
    ctx.restore();
    // Counterweight
    ctx.fillStyle = '#757575'; ctx.fillRect(sx - 4, cy - 2, 3, 3);
  } else {
    //  HUMANOID TYPES 
    // (militia, longbowmen, crossbowmen, menatarms, pikemen, healers, firelancers, assassins,
    //  bandit, raider, enemy_archer, cannons)

    if (unit.type === 'healers') {
      // White robes, golden cross, staff
      // Legs
      ctx.fillStyle = '#bdbdbd';
      ctx.fillRect(sx - 3, cy + 2, 2.5, 6); ctx.fillRect(sx + 0.5, cy + 2, 2.5, 6);
      // Body  white robes
      ctx.fillStyle = '#f5f5f5'; ctx.fillRect(sx - 5, cy - 4, 10, 8);
      // Head
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(sx, cy - 8, 4, 0, Math.PI * 2); ctx.fill();
      // Hood/cowl
      ctx.fillStyle = '#e0e0e0';
      ctx.beginPath(); ctx.arc(sx, cy - 10, 4, Math.PI, 0); ctx.fill();
      ctx.fillRect(sx - 4, cy - 11, 8, 3);
      // Golden cross on body
      ctx.fillStyle = '#ffd54f'; ctx.fillRect(sx - 1, cy - 4, 2, 6); ctx.fillRect(sx - 3, cy - 2, 6, 2);
      // Staff in right hand
      ctx.fillStyle = '#8d6e63'; ctx.fillRect(sx + 5, cy - 12, 1.5, 18);
      ctx.fillStyle = '#ffd54f'; ctx.beginPath(); ctx.arc(sx + 5.75, cy - 13, 2, 0, Math.PI * 2); ctx.fill();
      // Eyes
      ctx.fillStyle = '#111';
      ctx.fillRect(sx - 2, cy - 9, 1.5, 1.5); ctx.fillRect(sx + 1, cy - 9, 1.5, 1.5);
    } else if (unit.type === 'firelancers') {
      // Byzantine soldier with fire siphon
      // Legs
      ctx.fillStyle = dark;
      ctx.fillRect(sx - 3, cy + 2, 2.5, 6); ctx.fillRect(sx + 0.5, cy + 2, 2.5, 6);
      // Body
      ctx.fillStyle = color; ctx.fillRect(sx - 5, cy - 4, 10, 8);
      // Head
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(sx, cy - 8, 4, 0, Math.PI * 2); ctx.fill();
      // Helmet
      ctx.fillStyle = '#ff6f00';
      ctx.beginPath(); ctx.arc(sx, cy - 10, 4, Math.PI, 0); ctx.fill();
      ctx.fillRect(sx - 4, cy - 11, 8, 3);
      // Fuel tank on back
      ctx.fillStyle = '#4e342e'; ctx.fillRect(sx - 8, cy - 3, 4, 7);
      // Fire siphon nozzle
      ctx.fillStyle = '#333'; ctx.fillRect(sx + 4, cy - 3, 8, 2);
      // Flame at end
      ctx.fillStyle = '#ff9800'; ctx.beginPath(); ctx.arc(sx + 13, cy - 2, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ffeb3b'; ctx.beginPath(); ctx.arc(sx + 13, cy - 2, 1.5, 0, Math.PI * 2); ctx.fill();
      // Eyes
      ctx.fillStyle = '#111';
      ctx.fillRect(sx - 2, cy - 9, 1.5, 1.5); ctx.fillRect(sx + 1, cy - 9, 1.5, 1.5);
    } else if (unit.type === 'assassins') {
      // Dark cloak, daggers
      // Legs
      ctx.fillStyle = '#263238';
      ctx.fillRect(sx - 3, cy + 2, 2.5, 6); ctx.fillRect(sx + 0.5, cy + 2, 2.5, 6);
      // Body  dark cloak
      ctx.fillStyle = '#37474f'; ctx.fillRect(sx - 5, cy - 4, 10, 8);
      // Cloak flare
      ctx.fillStyle = '#263238';
      ctx.beginPath(); ctx.moveTo(sx - 6, cy + 4); ctx.lineTo(sx - 8, cy + 8);
      ctx.lineTo(sx + 8, cy + 8); ctx.lineTo(sx + 6, cy + 4); ctx.closePath(); ctx.fill();
      // Head  hooded
      ctx.fillStyle = '#37474f';
      ctx.beginPath(); ctx.arc(sx, cy - 8, 4, 0, Math.PI * 2); ctx.fill();
      // Face (partially hidden)
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(sx, cy - 7, 2.5, 0, Math.PI); ctx.fill();
      // Eyes (glinting)
      ctx.fillStyle = '#b0bec5';
      ctx.beginPath(); ctx.arc(sx - 1.5, cy - 8, 0.8, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(sx + 1.5, cy - 8, 0.8, 0, Math.PI * 2); ctx.fill();
      // Daggers  one in each hand
      ctx.fillStyle = '#b0bec5';
      ctx.fillRect(sx + 5, cy - 4, 6, 1.2);
      ctx.fillRect(sx - 11, cy - 4, 6, 1.2);
      // Dagger guards
      ctx.fillStyle = '#5d4037';
      ctx.fillRect(sx + 4, cy - 5, 2, 3);
      ctx.fillRect(sx - 6, cy - 5, 2, 3);
    } else if (unit.type === 'longbowmen' || unit.type === 'enemy_archer') {
      // Longbow/bow
      // Legs
      ctx.fillStyle = dark;
      ctx.fillRect(sx - 3, cy + 2, 2.5, 6); ctx.fillRect(sx + 0.5, cy + 2, 2.5, 6);
      // Body
      ctx.fillStyle = color; ctx.fillRect(sx - 5, cy - 4, 10, 8);
      // Head
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(sx, cy - 8, 4, 0, Math.PI * 2); ctx.fill();
      // Hat/hood
      ctx.fillStyle = dark;
      ctx.beginPath(); ctx.arc(sx, cy - 10, 4, Math.PI, 0); ctx.fill();
      ctx.fillRect(sx - 4, cy - 11, 8, 3);
      // Longbow (arc shape)
      ctx.strokeStyle = '#8d6e63'; ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(sx + 8, cy - 2, 10, -Math.PI * 0.4, Math.PI * 0.4);
      ctx.stroke();
      // Bowstring
      ctx.strokeStyle = '#e0e0e0'; ctx.lineWidth = 0.8;
      ctx.beginPath();
      ctx.moveTo(sx + 8 + Math.cos(-Math.PI * 0.4) * 10, cy - 2 + Math.sin(-Math.PI * 0.4) * 10);
      ctx.lineTo(sx + 8 + Math.cos(Math.PI * 0.4) * 10, cy - 2 + Math.sin(Math.PI * 0.4) * 10);
      ctx.stroke();
      // Quiver on back
      ctx.fillStyle = '#5d4037'; ctx.fillRect(sx - 8, cy - 6, 3, 10);
      // Arrow tips sticking out of quiver
      ctx.fillStyle = '#9e9e9e';
      ctx.fillRect(sx - 8, cy - 8, 1, 3);
      ctx.fillRect(sx - 6.5, cy - 7, 1, 2);
      // Eyes
      ctx.fillStyle = '#111';
      ctx.fillRect(sx - 2, cy - 9, 1.5, 1.5); ctx.fillRect(sx + 1, cy - 9, 1.5, 1.5);
    } else if (unit.type === 'crossbowmen') {
      // Crossbow
      // Legs
      ctx.fillStyle = dark;
      ctx.fillRect(sx - 3, cy + 2, 2.5, 6); ctx.fillRect(sx + 0.5, cy + 2, 2.5, 6);
      // Body
      ctx.fillStyle = color; ctx.fillRect(sx - 5, cy - 4, 10, 8);
      // Head
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(sx, cy - 8, 4, 0, Math.PI * 2); ctx.fill();
      // Helmet
      ctx.fillStyle = dark;
      ctx.beginPath(); ctx.arc(sx, cy - 10, 4, Math.PI, 0); ctx.fill();
      ctx.fillRect(sx - 4, cy - 11, 8, 3);
      // Crossbow stock
      ctx.fillStyle = '#5d4037'; ctx.fillRect(sx + 4, cy - 3, 10, 2);
      // Crossbow prod (cross piece)
      ctx.fillStyle = '#333'; ctx.fillRect(sx + 10, cy - 6, 2, 8);
      // Bolt loaded
      ctx.fillStyle = '#8d6e63'; ctx.fillRect(sx + 4, cy - 3.5, 8, 1);
      // Bolt quiver
      ctx.fillStyle = '#444'; ctx.fillRect(sx + 2, cy + 1, 3, 4);
      // Eyes
      ctx.fillStyle = '#111';
      ctx.fillRect(sx - 2, cy - 9, 1.5, 1.5); ctx.fillRect(sx + 1, cy - 9, 1.5, 1.5);
    } else if (unit.type === 'pikemen') {
      // Long pike
      // Legs
      ctx.fillStyle = dark;
      ctx.fillRect(sx - 3, cy + 2, 2.5, 6); ctx.fillRect(sx + 0.5, cy + 2, 2.5, 6);
      // Body
      ctx.fillStyle = color; ctx.fillRect(sx - 5, cy - 4, 10, 8);
      // Head
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(sx, cy - 8, 4, 0, Math.PI * 2); ctx.fill();
      // Helmet with nose guard
      ctx.fillStyle = '#9e9e9e';
      ctx.beginPath(); ctx.arc(sx, cy - 10, 4, Math.PI, 0); ctx.fill();
      ctx.fillRect(sx - 4, cy - 11, 8, 3);
      ctx.fillRect(sx - 0.5, cy - 9, 1, 3); // nose guard
      // Long pike (tall)
      ctx.fillStyle = '#8d6e63'; ctx.fillRect(sx + 4, cy - 20, 1.5, 26);
      // Pike head
      ctx.fillStyle = '#bdbdbd';
      ctx.beginPath(); ctx.moveTo(sx + 3.5, cy - 20); ctx.lineTo(sx + 4.75, cy - 25); ctx.lineTo(sx + 6, cy - 20); ctx.closePath(); ctx.fill();
      // Small shield
      ctx.fillStyle = dark;
      ctx.beginPath(); ctx.arc(sx - 5, cy - 1, 4, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = color;
      ctx.beginPath(); ctx.arc(sx - 5, cy - 1, 3, 0, Math.PI * 2); ctx.fill();
      // Eyes
      ctx.fillStyle = '#111';
      ctx.fillRect(sx - 2, cy - 9, 1.5, 1.5); ctx.fillRect(sx + 1, cy - 9, 1.5, 1.5);
    } else if (unit.type === 'cannons') {
      // Cannon on wheels (player version)
      // Wheels
      ctx.fillStyle = '#4e342e';
      ctx.beginPath(); ctx.arc(sx - 6, cy + 5, 3, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(sx + 6, cy + 5, 3, 0, Math.PI * 2); ctx.fill();
      // Axle
      ctx.fillStyle = '#5d4037'; ctx.fillRect(sx - 6, cy + 3, 12, 2);
      // Cannon barrel
      ctx.fillStyle = '#555'; ctx.fillRect(sx - 3, cy - 4, 14, 5);
      ctx.fillStyle = '#444'; ctx.fillRect(sx - 2, cy - 3, 12, 3);
      // Muzzle
      ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(sx + 11, cy - 1.5, 3, 0, Math.PI * 2); ctx.fill();
      // Operator behind
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(sx - 6, cy - 6, 2.5, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = color; ctx.fillRect(sx - 8, cy - 4, 4, 5);
    } else {
      // Default medieval soldier with sword and shield
      // Legs
      ctx.fillStyle = dark;
      ctx.fillRect(sx - 3, cy + 2, 2.5, 6); ctx.fillRect(sx + 0.5, cy + 2, 2.5, 6);
      // Body  chainmail/tunic
      ctx.fillStyle = color; ctx.fillRect(sx - 5, cy - 4, 10, 8);
      // Head
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(sx, cy - 8, 4, 0, Math.PI * 2); ctx.fill();
      // Helmet
      ctx.fillStyle = '#9e9e9e';
      ctx.beginPath(); ctx.arc(sx, cy - 10, 4, Math.PI, 0); ctx.fill();
      ctx.fillRect(sx - 4, cy - 11, 8, 3);
      // Shield on left arm
      ctx.fillStyle = dark;
      ctx.beginPath(); ctx.moveTo(sx - 8, cy - 5); ctx.lineTo(sx - 12, cy - 2);
      ctx.lineTo(sx - 8, cy + 3); ctx.lineTo(sx - 5, cy - 1); ctx.closePath(); ctx.fill();
      ctx.fillStyle = color;
      ctx.beginPath(); ctx.moveTo(sx - 8, cy - 4); ctx.lineTo(sx - 11, cy - 2);
      ctx.lineTo(sx - 8, cy + 2); ctx.lineTo(sx - 6, cy - 1); ctx.closePath(); ctx.fill();
      // Sword in right hand
      ctx.fillStyle = '#bdbdbd'; ctx.fillRect(sx + 4, cy - 6, 1.5, 10);
      // Sword guard
      ctx.fillStyle = '#795548'; ctx.fillRect(sx + 2, cy - 2, 6, 1.5);
      // Sword pommel
      ctx.fillStyle = '#8d6e63'; ctx.beginPath(); ctx.arc(sx + 4.75, cy + 4.5, 1, 0, Math.PI * 2); ctx.fill();
      // Eyes
      ctx.fillStyle = '#111';
      ctx.fillRect(sx - 2, cy - 9, 1.5, 1.5); ctx.fillRect(sx + 1, cy - 9, 1.5, 1.5);
    }
  }

  ctx.globalAlpha = 1;

  // Burning effect
  if (unit.burning && unit.burning > 0) {
    for (let fi = 0; fi < 2; fi++) {
      const fx = sx + (Math.random() - 0.5) * 12;
      const fy = cy - 2 + (Math.random() - 0.5) * 10;
      const fs = 2 + Math.random() * 2;
      ctx.fillStyle = Math.random() > 0.5 ? '#ff9800' : '#ffeb3b';
      ctx.globalAlpha = 0.5 + Math.random() * 0.4;
      ctx.beginPath(); ctx.arc(fx, fy, fs, 0, Math.PI * 2); ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // Health bar
  const hpFrac = unit.hp / unit.maxHp;
  const barW = 16, barH = 3;
  const barX = sx - barW / 2, barY = cy - 16;
  ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(barX - 1, barY - 1, barW + 2, barH + 2);
  ctx.fillStyle = hpFrac > 0.5 ? '#4caf50' : (hpFrac > 0.25 ? '#ff9800' : '#f44336');
  ctx.fillRect(barX, barY, barW * hpFrac, barH);
  ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 0.5;
  ctx.strokeRect(barX, barY, barW, barH);

  // Type label
  const typeName = (isPlayer ? BATTLE_STATS[unit.type]?.name : ENEMY_TYPES[unit.type]?.name) || unit.type;
  ctx.font = '7px sans-serif'; ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.fillText(typeName, sx, cy + 16);
}

function drawDeployPanel() {
  const panelY = H - PANEL_H;
  const panelGrad = ctx.createLinearGradient(0, panelY, 0, panelY + PANEL_H);
  panelGrad.addColorStop(0, '#161e30'); panelGrad.addColorStop(1, '#0a1018');
  ctx.fillStyle = panelGrad;
  ctx.fillRect(0, panelY, W, PANEL_H);
  ctx.fillStyle = '#3a4a6a'; ctx.fillRect(0, panelY, W, 1);

  const slotW = W / TROOP_ORDER.length;
  for (let i = 0; i < TROOP_ORDER.length; i++) {
    const type = TROOP_ORDER[i];
    const td = TROOP_TYPES[type];
    const count = Array.isArray(battle.deployArmy[type]) ? battle.deployArmy[type].length : 0;
    const cx = slotW * i + slotW / 2;
    const cy = panelY + PANEL_H / 2;

    // Selected highlight
    if (deploySelectedType === type) {
      ctx.fillStyle = 'rgba(79,195,247,0.15)';
      ctx.fillRect(slotW * i, panelY + 2, slotW, PANEL_H - 2);
      ctx.strokeStyle = '#4fc3f7'; ctx.lineWidth = 1;
      ctx.strokeRect(slotW * i + 1, panelY + 3, slotW - 2, PANEL_H - 4);
    }

    // Draw mini troop
    drawMiniTroop(slotW * i + 18, cy - 6, type, td);

    // Count
    ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center';
    ctx.fillStyle = count > 0 ? td.color : '#555';
    ctx.fillText(count, cx + 15, cy - 4);

    // Name
    ctx.font = '8px sans-serif'; ctx.fillStyle = '#8899aa';
    ctx.fillText(td.name, cx, cy + 16);

    // Divider
    if (i < TROOP_ORDER.length - 1) {
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      ctx.fillRect(slotW * (i + 1), panelY + 6, 1, PANEL_H - 12);
    }
  }
}

function drawBattleInfoPanel() {
  const panelY = H - PANEL_H;
  const panelGrad = ctx.createLinearGradient(0, panelY, 0, panelY + PANEL_H);
  panelGrad.addColorStop(0, '#161e30'); panelGrad.addColorStop(1, '#0a1018');
  ctx.fillStyle = panelGrad;
  ctx.fillRect(0, panelY, W, PANEL_H);
  ctx.fillStyle = '#3a4a6a'; ctx.fillRect(0, panelY, W, 1);

  ctx.textAlign = 'left';
  // Show alive unit counts
  const pAlive = battle.playerUnits.filter(u => u.hp > 0).length;
  const eAlive = battle.enemyUnits.filter(u => u.hp > 0).length;
  ctx.font = '11px sans-serif'; ctx.fillStyle = '#4fc3f7';
  ctx.fillText('Allies: ' + pAlive + '/' + battle.playerUnits.length, 15, panelY + 18);
  ctx.fillStyle = '#ff5252';
  ctx.fillText('Enemies: ' + eAlive + '/' + battle.enemyUnits.length, 15, panelY + 35);

  // Total HP bars
  const pHP = battle.playerUnits.reduce((s, u) => s + Math.max(0, u.hp), 0);
  const pMaxHP = battle.playerUnits.reduce((s, u) => s + u.maxHp, 0);
  const eHP = battle.enemyUnits.reduce((s, u) => s + Math.max(0, u.hp), 0);
  const eMaxHP = battle.enemyUnits.reduce((s, u) => s + u.maxHp, 0);
  // Player HP bar
  const barX = 130, barW = 120, barH = 6;
  ctx.fillStyle = '#1a1a2e'; ctx.fillRect(barX, panelY + 12, barW, barH);
  ctx.fillStyle = '#4fc3f7'; ctx.fillRect(barX, panelY + 12, barW * (pMaxHP > 0 ? pHP / pMaxHP : 0), barH);
  ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 0.5; ctx.strokeRect(barX, panelY + 12, barW, barH);
  // Enemy HP bar
  ctx.fillStyle = '#1a1a2e'; ctx.fillRect(barX, panelY + 29, barW, barH);
  ctx.fillStyle = '#ff5252'; ctx.fillRect(barX, panelY + 29, barW * (eMaxHP > 0 ? eHP / eMaxHP : 0), barH);
  ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.strokeRect(barX, panelY + 29, barW, barH);

  // Morale on center-right
  ctx.textAlign = 'center'; ctx.font = '10px sans-serif';
  const moralePct = Math.round(morale * 8);
  const moraleColor = morale > 0 ? '#4caf50' : (morale < 0 ? '#f44336' : '#888');
  ctx.fillStyle = moraleColor;
  ctx.fillText('Morale: ' + (morale > 0 ? '+' : '') + morale +
    (morale !== 0 ? ' (' + (moralePct > 0 ? '+' : '') + moralePct + '% DMG)' : ''), W / 2 + 100, panelY + 25);

  // Speed info on right (no turns)
  ctx.textAlign = 'right'; ctx.font = '11px sans-serif'; ctx.fillStyle = '#8899aa';
  ctx.fillText('Speed: ' + battle.simSpeed + 'x' +
    (battle.simPaused ? '  PAUSED' : ''), W - 15, panelY + 25);
  ctx.textAlign = 'left';
}

function drawBattleResultPanel() {
  const panelY = H - PANEL_H;
  ctx.fillStyle = '#0a1018';
  ctx.fillRect(0, panelY, W, PANEL_H);
  ctx.fillStyle = '#3a4a6a'; ctx.fillRect(0, panelY, W, 1);

  // Result text
  const lines = battle.resultMsg.split('\n');
  ctx.textAlign = 'center';
  for (let i = 0; i < lines.length; i++) {
    ctx.font = i === 0 ? 'bold 14px sans-serif' : '11px sans-serif';
    ctx.fillStyle = i === 0 ? (battle.resultMsg.startsWith('VICTORY') ? '#4caf50' : '#ff5252') : '#aabbcc';
    ctx.fillText(lines[i], W / 2, panelY + 15 + i * 14);
  }
}
// ===============================================
//  PART 6: GAME LOOP, INPUT, HUD, STARTUP
// ===============================================

// Variable for milestone tracking (not declared in earlier parts)
let castlesCaptured = 0;

// -----------------------------------------------
//  UPDATE HUD
// -----------------------------------------------
function updateHUD() {
  const pw = armyPower(player.army);
  const bon = armyBonus(player.army);

  const nameEl = document.getElementById('nameVal');
  if (nameEl) nameEl.textContent = playerName || 'Lord';

  const armyEl = document.getElementById('armyVal');
  if (armyEl) armyEl.textContent = pw + (bon > 0 ? ' [+' + bon + ']' : '');

  const castlesEl = document.getElementById('castlesVal');
  if (castlesEl) castlesEl.textContent = forts.length;

  const goldEl = document.getElementById('goldVal');
  if (goldEl) goldEl.textContent = gold;

  // Resources
  const woodEl = document.getElementById('woodVal');
  if (woodEl) woodEl.textContent = Math.floor(resources.wood || 0);
  const stoneEl = document.getElementById('stoneVal');
  if (stoneEl) stoneEl.textContent = Math.floor(resources.stone || 0);
  const ironEl = document.getElementById('ironVal');
  if (ironEl) ironEl.textContent = Math.floor(resources.iron || 0);
  const cropsEl = document.getElementById('cropsVal');
  if (cropsEl) cropsEl.textContent = Math.floor(resources.crops || 0);
  const meatEl = document.getElementById('meatVal');
  if (meatEl) meatEl.textContent = Math.floor(resources.meat || 0);

  // Population
  const popEl = document.getElementById('popVal');
  if (popEl) popEl.textContent = population + '/' + popCap + ' (Idle: ' + idleWorkers + ')';

  // Kills
  const killsEl = document.getElementById('killsVal');
  if (killsEl) killsEl.textContent = kills;

  // Morale
  const moraleEl = document.getElementById('moraleVal');
  if (moraleEl) {
    moraleEl.textContent = (morale > 0 ? '+' : '') + morale;
    moraleEl.style.color = morale > 0 ? '#4caf50' : (morale < 0 ? '#f44336' : '#888');
  }

  // Smiths (engineers)
  const engEl = document.getElementById('engVal');
  if (engEl) engEl.textContent = recruitedEngineers + (engineerATKBonus > 0 ? ' (+' + engineerATKBonus + ' ATK)' : '');

  // Income
  const incEl = document.getElementById('incomeVal');
  if (incEl) incEl.textContent = goldPerTurn > 0 ? '+' + goldPerTurn + '/turn' : 'none';

  // Update shop buttons with scaled prices
  for (const btn of document.querySelectorAll('#shop button')) {
    const onclick = btn.getAttribute('onclick') || '';
    const type = (onclick.match(/shopBuy\('(\w+)'\)/) || [])[1];
    if (type && TROOP_TYPES[type]) {
      const def = TROOP_TYPES[type];
      const cost = shopCost(type);
      btn.disabled = gold < cost;
      btn.textContent = def.name + ' x' + def.qty + ' (' + cost + 'g)';
    }
    if (onclick.includes('shopHealAll')) {
      const cost = healCost();
      btn.disabled = gold < cost;
      btn.textContent = 'Heal All (' + cost + 'g)';
    }
    if (onclick.includes('shopScout')) {
      btn.disabled = gold < 15 || scouted;
    }
  }

  // Update blacksmith / upgrade buttons
  updateBlacksmithButtons();
}

// -----------------------------------------------
//  SMOOTH UPDATE (overworld)
// -----------------------------------------------
function updateSmooth() {
  // Update camera
  updateCamera();

  // Smooth player position
  const spd = MOVE_SPEED;
  playerVisual.x += (player.x - playerVisual.x) * spd;
  playerVisual.y += (player.y - playerVisual.y) * spd;
  // Snap when close enough
  if (Math.abs(player.x - playerVisual.x) < 0.01 && Math.abs(player.y - playerVisual.y) < 0.01) {
    playerVisual.x = player.x;
    playerVisual.y = player.y;
  }

  // Smooth enemy positions
  for (const e of enemies) {
    if (e.vx === undefined) { e.vx = e.x; e.vy = e.y; }
    e.vx += (e.x - e.vx) * spd;
    e.vy += (e.y - e.vy) * spd;
    if (Math.abs(e.x - e.vx) < 0.01 && Math.abs(e.y - e.vy) < 0.01) {
      e.vx = e.x; e.vy = e.y;
    }
  }

  // Smooth follower positions
  for (let i = 0; i < followerTrail.length; i++) {
    if (!followerVisuals[i]) followerVisuals[i] = { x: followerTrail[i].x, y: followerTrail[i].y };
    const fv = followerVisuals[i];
    const ft = followerTrail[i];
    fv.x += (ft.x - fv.x) * (spd * 0.7);
    fv.y += (ft.y - fv.y) * (spd * 0.7);
    if (Math.abs(ft.x - fv.x) < 0.01 && Math.abs(ft.y - fv.y) < 0.01) {
      fv.x = ft.x; fv.y = ft.y;
    }
  }

  // Smooth shake decay
  if (shake > 0) shake *= 0.88;
  if (shake < 0.3) shake = 0;

  // Check if player animation is done, process next queued move
  const animDone = Math.abs(player.x - playerVisual.x) < 0.15 && Math.abs(player.y - playerVisual.y) < 0.15;
  if (isAnimating && animDone) {
    isAnimating = false;
    if (moveQueue.length > 0) {
      const next = moveQueue.shift();
      tryMove(next.dx, next.dy);
    }
  }
}

// -----------------------------------------------
//  GAME LOOP
// -----------------------------------------------
function gameLoop() {
  animFrame++;

  // Smith (engineer) passive crafting timer (every 5 min per smith -> +1 ATK, cap 10)
  if (recruitedEngineers > 0 && engineerATKBonus < 10) {
    engineerTimer++;
    const interval = Math.floor(18000 / recruitedEngineers); // 5 min / num smiths
    if (engineerTimer >= interval) {
      engineerTimer = 0;
      engineerATKBonus = Math.min(10, engineerATKBonus + 1);
      if (gameMode === 'overworld') {
        spawnFloatingText(player.x, player.y, 'SMITH +1 ATK', '#ff9800');
        msg('Smiths forged a weapon upgrade! (ATK +' + engineerATKBonus + ')');
        updateHUD();
      }
    }
  }

  try {
    if (gameMode === 'overworld') {
      updateSmooth();
      draw();
    } else {
      updateBattleSmooth();
      drawBattle();
    }
  } catch (err) {
    console.error('Game loop error:', err);
  }
  requestAnimationFrame(gameLoop);
}

// -----------------------------------------------
//  KEYBOARD INPUT
// -----------------------------------------------
document.addEventListener('keydown', e => {
  if (document.getElementById('overlay').classList.contains('show')) return;

  if (gameMode === 'overworld') {
    switch (e.key) {
      case 'ArrowUp': case 'w': case 'W':
        e.preventDefault(); tryMove(0, -1); break;
      case 'ArrowDown': case 's': case 'S':
        e.preventDefault(); tryMove(0, 1); break;
      case 'ArrowLeft': case 'a': case 'A':
        e.preventDefault(); tryMove(-1, 0); break;
      case 'ArrowRight': case 'd': case 'D':
        e.preventDefault(); tryMove(1, 0); break;
      case 'Escape':
        if (buildMode) {
          buildMode = false;
          buildSelected = null;
          buildGhost = null;
          msg('');
        }
        break;
      case 'b': case 'B':
        toggleBuildMenu();
        break;
      case 'h': case 'H':
        harvest();
        break;
    }
  } else if (gameMode === 'battle') {
    if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); battle.simPaused = !battle.simPaused; }
    if (e.key === '1') { battle.simSpeed = 1; battle.simPaused = false; }
    if (e.key === '2') { battle.simSpeed = 2; battle.simPaused = false; }
    if (e.key === '3') { battle.simSpeed = 4; battle.simPaused = false; }
  } else if (gameMode === 'deploy') {
    if (e.key === 'Escape') { e.preventDefault(); cancelDeploy(); }
  }
});

// -----------------------------------------------
//  MOUSE / CLICK INPUT
// -----------------------------------------------
canvas.addEventListener('mousemove', e => {
  if (!buildMode) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width, scaleY = H / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;
  const grid = fromIso(mx, my);
  buildGhost = { gx: grid.x, gy: grid.y };
});

canvas.addEventListener('click', e => {
  if (document.getElementById('overlay').classList.contains('show')) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width, scaleY = H / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;

  if (gameMode === 'overworld') {
    if (my >= H - PANEL_H) return;
    const grid = fromIso(mx, my);
    // No COLS/ROWS bounds check (infinite map)
    if (!grassMap[grid.y] || grassMap[grid.y][grid.x] === undefined) return;

    // Build placement (stays in build mode until ESC or B or can't afford)
    if (buildMode && buildSelected) {
      if (canBuild(buildSelected, grid.x, grid.y)) {
        placeBuilding(buildSelected, grid.x, grid.y);
        updateHUD();
        // Check if can still afford another
        const def = BUILDING_DEFS[buildSelected];
        const canStillAfford = def && Object.entries(def.levels[0].cost).every(([r, a]) => (resources[r] || 0) >= a);
        if (!canStillAfford) {
          buildMode = false;
          buildSelected = null;
          buildGhost = null;
          msg('');
        }
      } else {
        msg('Cannot build here!');
      }
      return;
    }

    // Check if clicking on own building
    const clickedBld = buildings.find(b => b.gx === grid.x && b.gy === grid.y && b.built);
    if (clickedBld) {
      showBuildingInfo(clickedBld.id);
      return;
    }

    // Click to move toward that tile
    const dx = Math.sign(grid.x - player.x), dy = Math.sign(grid.y - player.y);
    if (dx === 0 && dy === 0) return;
    if (Math.abs(grid.x - player.x) >= Math.abs(grid.y - player.y)) tryMove(dx, 0);
    else tryMove(0, dy);

  } else if (gameMode === 'deploy') {
    handleDeployClick(mx, my);
  } else if (gameMode === 'battle') {
    handleBattleClick(mx, my);
  } else if (gameMode === 'battle_result') {
    handleResultClick();
  }
});

// -----------------------------------------------
//  MILESTONE / VICTORY SYSTEM
// -----------------------------------------------
function checkMilestones() {
  const milestones = [5, 10, 25, 50, 100];
  for (const m of milestones) {
    if (castlesCaptured === m) {
      showOverlay('MILESTONE!', 'You have captured ' + m + ' castles! Your kingdom grows, my Lord!', 'Continue', () => {
        document.getElementById('overlay').classList.remove('show');
      }, false);
      break;
    }
  }
}

function declareVictory() {
  showOverlay('VICTORY!', 'Lord ' + playerName + ' has conquered the realm with ' + castlesCaptured + ' castles, ' + kills + ' kills, and a kingdom of ' + buildings.length + ' buildings!', 'New Game', () => {
    document.getElementById('overlay').classList.remove('show');
    showStartScreen();
  }, false);
}

// -----------------------------------------------
//  RESTART GAME
// -----------------------------------------------
function restartGame() {
  showOverlay('RESTART', 'Are you sure? Unsaved progress will be lost.', 'Restart', () => {
    document.getElementById('overlay').classList.remove('show');
    castlesCaptured = 0;
    showStartScreen();
  }, false);
}

// -----------------------------------------------
//  START SCREEN
// -----------------------------------------------
function showStartScreen() {
  const saves = getSaves();
  const hasSaves = Object.keys(saves).length > 0;

  if (hasSaves) {
    let html = '<div style="text-align:center;font-family:sans-serif;">';
    html += '<p style="color:#aaa;margin:4px 0">Welcome, my Lord!</p>';
    html += '<button onclick="showSaveLoadUI()" style="padding:6px 16px;margin:4px;font-size:13px">Load Kingdom</button>';
    html += '<button onclick="document.getElementById(\'overlay\').classList.remove(\'show\');showOverlay(\'CONQUERERS\',\'Enter your name, my Lord.\',\'Begin\',()=>newGame(),true)" style="padding:6px 16px;margin:4px;font-size:13px">New Kingdom</button>';
    html += '</div>';
    document.getElementById('overlayTitle').textContent = 'CONQUERERS';
    document.getElementById('overlayTitle').style.color = '#f0c040';
    document.getElementById('overlayMsg').innerHTML = html;
    document.getElementById('overlayBtn').style.display = 'none';
    document.getElementById('overlayInput').style.display = 'none';
    document.getElementById('overlay').classList.add('show');
    overlayCallback = () => {
      document.getElementById('overlayBtn').style.display = '';
      document.getElementById('overlayMsg').innerHTML = '';
    };
  } else {
    showOverlay('CONQUERERS', 'Enter your name, my Lord.', 'Begin', () => newGame(), true);
    document.getElementById('overlayTitle').style.color = '#f0c040';
  }
}

// -----------------------------------------------
//  OVERLAY INPUT ENTER KEY
// -----------------------------------------------
document.getElementById('overlayInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') { e.preventDefault(); overlayAction(); }
});

// -----------------------------------------------
//  INITIAL STARTUP
// -----------------------------------------------
showStartScreen();
gameLoop();
</script>
</body>
</html>
