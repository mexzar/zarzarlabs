<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Conquerers</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap');
* { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

body {
  background: linear-gradient(180deg, #0a0a1a 0%, #1a1a2e 40%, #16213e 100%);
  color: #e0e0e0;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  overflow-x: hidden;
}

h1 {
  font-family: 'MedievalSharp', cursive, serif;
  font-size: 2.8rem;
  margin: 10px 0 2px;
  letter-spacing: 5px;
  color: #f0c040;
  text-shadow: 0 0 30px rgba(240,192,64,0.5), 0 2px 4px rgba(0,0,0,0.6);
}

#subtitle { font-size: 0.85rem; color: #8888aa; margin-bottom: 6px; letter-spacing: 2px; }

#hud {
  display: flex; gap: 10px; margin-bottom: 4px; font-size: 0.9rem;
  flex-wrap: wrap; justify-content: center;
}
#hud span {
  background: linear-gradient(180deg, #1a2744 0%, #0f1b30 100%);
  padding: 4px 12px; border-radius: 6px; border: 1px solid #2a3a5a;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}
#hud .label { color: #778; font-size: 0.8rem; }
#hud .val { font-weight: bold; }
#army-str .val { color: #4fc3f7; }
#forts-left .val { color: #ff8a65; }
#level-num .val { color: #aed581; }
#gold-num .val { color: #ffd54f; }
#kills-num .val { color: #ef9a9a; }

#message {
  height: 22px; font-size: 0.9rem; color: #ce93d8; margin-bottom: 2px;
  text-align: center; text-shadow: 0 0 10px rgba(206,147,216,0.3);
}

canvas {
  border: 2px solid #2a3a5a; border-radius: 8px; cursor: pointer;
  box-shadow: 0 4px 30px rgba(0,0,0,0.5);
  max-width: 98vw;
}

#controls {
  margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap; justify-content: center;
}
#controls button {
  background: linear-gradient(180deg, #1e2d4a 0%, #121e33 100%);
  color: #ccd; border: 1px solid #3a4a6a; padding: 5px 14px; border-radius: 6px;
  cursor: pointer; font-size: 0.82rem; transition: all 0.2s;
}
#controls button:hover { background: linear-gradient(180deg, #2a3d5a 0%, #1a2a44 100%); }

#shop {
  margin-top: 6px; display: flex; gap: 6px; flex-wrap: wrap; justify-content: center;
}
#shop button {
  background: linear-gradient(180deg, #1a2a1e 0%, #0e1a10 100%);
  color: #81c784; border: 1px solid #2e5a32; padding: 4px 10px; border-radius: 6px;
  cursor: pointer; font-size: 0.78rem; transition: all 0.2s;
}
#shop button:hover { background: linear-gradient(180deg, #2a3a2e 0%, #1a2a1e 100%); }
#shop button:disabled { opacity: 0.35; cursor: default; }

#legend {
  margin-top: 8px; font-size: 0.72rem; color: #556; text-align: center;
  max-width: 1100px; line-height: 1.7;
}
#legend b { color: #889; }

#overlay {
  display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.82);
  justify-content: center; align-items: center; flex-direction: column;
  z-index: 10; backdrop-filter: blur(4px);
}
#overlay.show { display: flex; }
#overlay h2 {
  font-family: 'MedievalSharp', cursive, serif; font-size: 3rem;
  margin-bottom: 10px; text-shadow: 0 0 40px currentColor;
}
#overlay p { font-size: 1rem; margin-bottom: 16px; color: #bbc; text-align: center; white-space: pre-line; }
#overlay button {
  background: linear-gradient(180deg, #f0c040 0%, #c89020 100%);
  color: #1a1a2e; border: none; padding: 10px 28px; border-radius: 8px;
  font-size: 1rem; cursor: pointer; font-weight: bold;
  box-shadow: 0 4px 20px rgba(240,192,64,0.4); transition: transform 0.15s;
}
#overlay button:hover { transform: scale(1.05); }
</style>
</head>
<body>

<h1>CONQUERERS</h1>
<p id="subtitle">CAPTURE FORTS & TROOPS TO STRENGTHEN YOUR ARMY</p>

<div id="hud">
  <span id="player-name"><span class="val" id="nameVal" style="color:#f0c040;"></span></span>
  <span id="army-str"><span class="label">Power </span><span class="val" id="armyVal">10</span></span>
  <span id="forts-left"><span class="label">Forts Left </span><span class="val" id="fortsVal">0</span></span>
  <span id="gold-num"><span class="label">Gold </span><span class="val" id="goldVal">0</span></span>
  <span id="kills-num"><span class="label">Kills </span><span class="val" id="killsVal">0</span></span>
  <span id="morale-num"><span class="label">Morale </span><span class="val" id="moraleVal">0</span></span>
  <span id="eng-num"><span class="label">Eng </span><span class="val" id="engVal" style="color:#ff9800">0</span></span>
  <span id="income-num"><span class="label">Income </span><span class="val" id="incomeVal" style="color:#ffd54f">none</span></span>
</div>

<div id="sett-hud" style="display:none;gap:6px;margin-bottom:4px;font-size:0.85rem;flex-wrap:wrap;justify-content:center;">
</div>

<div id="message">&nbsp;</div>

<canvas id="game"></canvas>

<div id="controls">
  <button onclick="newGame()">Restart Game</button>
  <button onclick="showSaveLoadUI()">Save/Load</button>
  <button onclick="tryBuildFort()" id="buildFortBtn">Build Fort</button>
</div>

<div id="shop">
  <button onclick="shopBuy('riflemen')">Riflemen x3 (10g)</button>
  <button onclick="shopBuy('snipers')">Snipers x2 (25g)</button>
  <button onclick="shopBuy('machinegun')">MG x1 (30g)</button>
  <button onclick="shopBuy('gunners')">Gunners x1 (40g)</button>
  <button onclick="shopBuy('rpg')">RPG x1 (35g)</button>
  <button onclick="shopBuy('tanks')">Tanks x1 (50g)</button>
  <button onclick="shopBuy('bombers')">Bombers x1 (50g)</button>
  <button onclick="shopBuy('medic')">Medic x1 (45g)</button>
  <button onclick="shopBuy('flamethrower')">Flamer x1 (50g)</button>
  <button onclick="shopBuy('operative')">Operative x1 (55g)</button>
  <button onclick="shopBuy('helicopter')">Helicopter x1 (55g)</button>
  <button onclick="shopHealAll()">Heal All (20g)</button>
  <button onclick="shopScout()">Scout Map (15g)</button>
</div>
<div id="engineer-shop" style="margin-top:4px; display:flex; gap:6px; flex-wrap:wrap; justify-content:center;">
  <button onclick="engineerBuy('armorPiercing')" style="background:linear-gradient(180deg,#2a1a1a 0%,#1a0e0e 100%); color:#ff8a65; border:1px solid #5a2e2e; padding:4px 10px; border-radius:6px; cursor:pointer; font-size:0.78rem;">AP Rounds Lv0 (30g)</button>
  <button onclick="engineerBuy('extendedMag')" style="background:linear-gradient(180deg,#2a1a1a 0%,#1a0e0e 100%); color:#ff8a65; border:1px solid #5a2e2e; padding:4px 10px; border-radius:6px; cursor:pointer; font-size:0.78rem;">Ext. Barrels Lv0 (40g)</button>
  <button onclick="engineerBuy('reinforced')" style="background:linear-gradient(180deg,#2a1a1a 0%,#1a0e0e 100%); color:#ff8a65; border:1px solid #5a2e2e; padding:4px 10px; border-radius:6px; cursor:pointer; font-size:0.78rem;">Reinforced Lv0 (25g)</button>
  <button onclick="engineerBuy('explosiveRounds')" style="background:linear-gradient(180deg,#2a1a1a 0%,#1a0e0e 100%); color:#ff8a65; border:1px solid #5a2e2e; padding:4px 10px; border-radius:6px; cursor:pointer; font-size:0.78rem;">Explosive Rds Lv0 (50g)</button>
</div>

<div id="legend">
  <b>Arrow keys / WASD / Click</b> to move |
  <b>Units:</b>
  <span style="color:#78909c">Riflemen</span> -
  <span style="color:#26a69a">Snipers</span> -
  <span style="color:#7e57c2">MG</span> -
  <span style="color:#5c6bc0">Gunners</span> -
  <span style="color:#ef6c00">RPG</span> -
  <span style="color:#546e7a">Tanks</span> -
  <span style="color:#e64a19">Bombers</span> -
  <span style="color:#66bb6a">Medic</span> -
  <span style="color:#ff7043">Flamer</span> -
  <span style="color:#ab47bc">Operative</span>
</div>

<div id="overlay">
  <h2 id="overlayTitle"></h2>
  <p id="overlayMsg"></p>
  <input id="overlayInput" type="text" maxlength="16" placeholder="Enter your name..."
    style="display:none; background:#1a1a2e; color:#f0c040; border:2px solid #f0c040; padding:8px 16px;
    border-radius:8px; font-size:1.1rem; text-align:center; margin-bottom:12px; outline:none;
    font-family:'MedievalSharp',cursive,serif; letter-spacing:2px; width:220px;">
  <button id="overlayBtn" onclick="overlayAction()">Continue</button>
</div>

<script>
// ═══════════════════════════════════════════
//  CONSTANTS
// ═══════════════════════════════════════════
const TILE_W = 64;
const TILE_H = 32;
const TILE = 44; // legacy for army panel mini-troop sizing
const COLS = 100;
const ROWS = 100;
const PANEL_H = 54;
const W = 1100;
const H = 750;
const WALL_HEIGHT = 18;
const MINIMAP_SIZE = 150;
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = W;
canvas.height = H;

// Camera state (grid coords, follows player smoothly)
let camX = 50, camY = 50;
const CAM_SPEED = 0.12; // lerp speed

// Minimap offscreen canvas
const minimapCanvas = document.createElement('canvas');
minimapCanvas.width = MINIMAP_SIZE;
minimapCanvas.height = MINIMAP_SIZE;
const mmCtx = minimapCanvas.getContext('2d');
let minimapDirty = true; // flag to re-render minimap

// ═══════════════════════════════════════════
//  ISOMETRIC TRANSFORMS (camera-relative)
// ═══════════════════════════════════════════
function toIso(gx, gy) {
  const relX = gx - camX;
  const relY = gy - camY;
  return {
    x: (relX - relY) * (TILE_W / 2) + W / 2,
    y: (relX + relY) * (TILE_H / 2) + (H - PANEL_H) / 2
  };
}
function fromIso(sx, sy) {
  const rx = sx - W / 2;
  const ry = sy - (H - PANEL_H) / 2;
  const relX = (rx / (TILE_W / 2) + ry / (TILE_H / 2)) / 2;
  const relY = (ry / (TILE_H / 2) - rx / (TILE_W / 2)) / 2;
  return { x: Math.round(relX + camX), y: Math.round(relY + camY) };
}
function isoMapHeight() {
  return (COLS + ROWS) * (TILE_H / 2) + WALL_HEIGHT + 40;
}

function updateCamera() {
  camX += (player.x - camX) * CAM_SPEED;
  camY += (player.y - camY) * CAM_SPEED;
  // Clamp so we don't scroll too far off the map edge
  camX = Math.max(5, Math.min(COLS - 5, camX));
  camY = Math.max(5, Math.min(ROWS - 5, camY));
}

// Get visible tile range for viewport culling
function getVisibleRange() {
  const margin = 3;
  // Approximate: center of view is at (camX, camY). Visible area is ~20 tiles wide, ~15 tall in iso.
  const halfW = Math.ceil(W / TILE_W) + margin;
  const halfH = Math.ceil((H - PANEL_H) / TILE_H) + margin;
  return {
    minX: Math.max(0, Math.floor(camX - halfW)),
    maxX: Math.min(COLS - 1, Math.ceil(camX + halfW)),
    minY: Math.max(0, Math.floor(camY - halfH)),
    maxY: Math.min(ROWS - 1, Math.ceil(camY + halfH))
  };
}

// ═══════════════════════════════════════════
//  TROOP TYPE DEFINITIONS (player army)
// ═══════════════════════════════════════════
const TROOP_TYPES = {
  riflemen: { name:'Riflemen', str:3,   color:'#78909c', dark:'#37474f', cost:10, qty:3, desc:'Standard infantry' },
  snipers:  { name:'Snipers',  str:2.5, color:'#26a69a', dark:'#00695c', cost:25, qty:2, desc:'Heavy ranged pre-combat dmg' },
  machinegun:{ name:'MG',      str:4.5, color:'#7e57c2', dark:'#4527a0', cost:30, qty:1, desc:'Splash dmg to nearby enemies' },
  gunners:  { name:'Gunners',  str:5,   color:'#5c6bc0', dark:'#283593', cost:40, qty:1, desc:'Heavy suppression fire' },
  rpg:      { name:'RPG',      str:4,   color:'#ef6c00', dark:'#bf360c', cost:35, qty:1, desc:'+60% vs heavy enemies' },
  tanks:    { name:'Tanks',    str:10,  color:'#546e7a', dark:'#263238', cost:50, qty:1, desc:'+5 armor each' },
  bombers:  { name:'Bombers',  str:12,  color:'#e64a19', dark:'#bf360c', cost:50, qty:1, desc:'Massive airstrike +fort bonus' },
  medic:       { name:'Medic',      str:2,  color:'#66bb6a', dark:'#2e7d32', cost:45, qty:1, desc:'Heals allies in battle' },
  flamethrower:{ name:'Flamer',     str:6,  color:'#ff7043', dark:'#d84315', cost:50, qty:1, desc:'Short range massive AOE' },
  operative:   { name:'Operative',  str:5,  color:'#ab47bc', dark:'#6a1b9a', cost:55, qty:1, desc:'Fast stealth attacker' },
  helicopter:  { name:'Helicopter', str:9,  color:'#42a5f5', dark:'#1565c0', cost:55, qty:1, desc:'Fast aerial assault' },
};
const TROOP_ORDER = ['riflemen','snipers','machinegun','gunners','rpg','tanks','bombers','medic','flamethrower','operative','helicopter'];

// ═══════════════════════════════════════════
//  ENEMY TYPE DEFINITIONS
// ═══════════════════════════════════════════
const ENEMY_TYPES = {
  militant: { name:'Militant',  color:'#8d6e63', dark:'#4e342e', speed:2, detectRange:7, strMul:0.6,  goldMul:0.25, yields:'riflemen', heavy:false },
  commando: { name:'Commando',  color:'#455a64', dark:'#263238', speed:2, detectRange:8, strMul:1.2,  goldMul:0.4,  yields:'riflemen', heavy:false },
  sniper_e: { name:'Sniper',    color:'#00897b', dark:'#004d40', speed:1, detectRange:9, strMul:0.9,  goldMul:0.4,  ranged:true, yields:'snipers', heavy:false },
  apc:      { name:'APC',       color:'#607d8b', dark:'#37474f', speed:1, detectRange:5, strMul:2.0,  goldMul:0.6,  yields:'gunners', heavy:true },
  helicopter:{ name:'Helicopter',color:'#42a5f5', dark:'#1565c0', speed:3, detectRange:10,strMul:1.8,  goldMul:0.5,  charge:true, yields:'rpg', heavy:true },
  mad_scientist:{ name:'Mad Scientist',color:'#ab47bc',dark:'#6a1b9a',speed:1,detectRange:6,strMul:0.8,goldMul:0.5,yields:'operative',heavy:false },
  mutant:     { name:'Mutant',    color:'#76ff03', dark:'#33691e', speed:2, detectRange:5, strMul:1.5,  goldMul:0.35, yields:'gunners', heavy:true },
};

// ═══════════════════════════════════════════
//  GAME STATE
// ═══════════════════════════════════════════
let player, enemies, forts, allies, chests, walls, gold, scouted, kills, mercCamps;
let playerName = '';
let particles = [], floatingTexts = [], grassMap = [], treeMap = [], waterMap = [], pathMap = [];
let ambientParticles = [];
let turnCount = 0, animFrame = 0, shake = 0, tensionTimer = 0;
let morale = 0; // -5 to +5, win/loss streaks
let upgrades = { armorPiercing: 0, extendedMag: 0, reinforced: 0, explosiveRounds: 0 };
let followerTrail = []; // recent player positions for follower sprites
let overworldEngineers = [];
let recruitedEngineers = 0, engineerATKBonus = 0, engineerTimer = 0;
let playerForts = [];       // [{gx,gy,garrison:{},walls:0,turrets:0,mines:0,isHome}]
let territoryMap = [];      // 2D [ROWS][COLS] = 'player'|'enemy'|null
let pendingAttacks = [];    // [{fortIndex,enemyForce,strength}]
let goldPerTurn = 0;
let fortMenuOpen = false, fortMenuIndex = -1;
let fogMap = [];            // 2D [ROWS][COLS] = 0(hidden)|1(revealed/dim)|2(visible)

// ═══════════════════════════════════════════
//  SMOOTH ANIMATION STATE
// ═══════════════════════════════════════════
const MOVE_SPEED = 0.18; // interpolation speed per frame (0-1, higher=faster)
let moveQueue = []; // queued moves during animation
let isAnimating = false;

// Smooth position tracking for player
let playerVisual = { x: 1, y: 1 }; // rendered position (float)

// ═══════════════════════════════════════════
//  GAME MODE & TACTICAL BATTLE STATE
// ═══════════════════════════════════════════
let gameMode = 'overworld'; // 'overworld' | 'deploy' | 'battle' | 'battle_result'
let appMode = 'conquerers'; // 'conquerers' | 'settlers'
let sett = null; // settlers mode state (null when in conquerers mode)

const BATTLE_STATS = {
  riflemen:   { hp: 8,  atk: 3,  range: 3, moveRange: 3, aoe: 0, name: 'Rifleman', moveSpeed: 0.03, attackRate: 45 },
  snipers:    { hp: 5,  atk: 5,  range: 6, moveRange: 2, aoe: 0, name: 'Sniper', moveSpeed: 0.02, attackRate: 80 },
  machinegun: { hp: 10, atk: 4,  range: 3, moveRange: 2, aoe: 1, name: 'MG', moveSpeed: 0.02, attackRate: 20 },
  gunners:    { hp: 12, atk: 5,  range: 3, moveRange: 2, aoe: 0, name: 'Gunner', moveSpeed: 0.02, attackRate: 35 },
  rpg:        { hp: 8,  atk: 6,  range: 4, moveRange: 2, aoe: 0, name: 'RPG', moveSpeed: 0.02, attackRate: 60 },
  tanks:      { hp: 25, atk: 8,  range: 3, moveRange: 2, aoe: 0, name: 'Tank', moveSpeed: 0.015, attackRate: 50 },
  bombers:    { hp: 6,  atk: 12, range: 5, moveRange: 3, aoe: 2, name: 'Bomber', moveSpeed: 0.035, attackRate: 70 },
  medic:       { hp: 10, atk: 1,  range: 2, moveRange: 3, aoe: 0, name: 'Medic', moveSpeed: 0.03, attackRate: 50 },
  flamethrower:{ hp: 7,  atk: 7,  range: 2, moveRange: 2, aoe: 2, name: 'Flamer', moveSpeed: 0.02, attackRate: 30 },
  operative:   { hp: 6,  atk: 8,  range: 3, moveRange: 4, aoe: 0, name: 'Operative', moveSpeed: 0.04, attackRate: 40 },
  helicopter:  { hp: 18, atk: 7,  range: 4, moveRange: 4, aoe: 0, name: 'Helicopter', moveSpeed: 0.04, attackRate: 50 },
};

const ENEMY_BATTLE_STATS = {
  militant:   { hp: 6,  atk: 2,  range: 2, moveRange: 3, aoe: 0, heavy: false, moveSpeed: 0.03, attackRate: 45 },
  commando:   { hp: 10, atk: 4,  range: 3, moveRange: 3, aoe: 0, heavy: false, moveSpeed: 0.025, attackRate: 40 },
  sniper_e:   { hp: 5,  atk: 4,  range: 6, moveRange: 2, aoe: 0, heavy: false, moveSpeed: 0.02, attackRate: 70 },
  apc:        { hp: 30, atk: 6,  range: 3, moveRange: 2, aoe: 1, heavy: true, moveSpeed: 0.015, attackRate: 45 },
  helicopter: { hp: 20, atk: 7,  range: 4, moveRange: 4, aoe: 0, heavy: true, moveSpeed: 0.04, attackRate: 50 },
  mad_scientist:{ hp: 8, atk: 2, range: 3, moveRange: 2, aoe: 0, heavy: false, moveSpeed: 0.015, attackRate: 60 },
  mutant:       { hp: 18, atk: 6, range: 1, moveRange: 3, aoe: 0, heavy: true, moveSpeed: 0.025, attackRate: 40 },
};

const BCOLS = 12, BROWS = 8;
let battle = null;
let battleParticles = [], battleFloatingTexts = [];
let battleProjectiles = [];
let deploySelectedType = null; // troop type selected for placement during deploy

// Each enemy gets a visual position for smooth lerp
function initEnemyVisuals() {
  for (const e of enemies) {
    e.vx = e.x; e.vy = e.y;
  }
}

// Follower visual positions
let followerVisuals = []; // [{x,y}, ...]

// ═══════════════════════════════════════════
//  ARMY HELPERS
// ═══════════════════════════════════════════
// Army is stored as HP arrays: army[type] = [hp1, hp2, ...] where each entry is one unit's current HP
function newArmy() {
  const a = {};
  for (const t of TROOP_ORDER) a[t] = [];
  return a;
}

// Get count of units of a type
function armyCount(army, type) {
  const v = army[type];
  if (Array.isArray(v)) return v.length;
  return v || 0;
}

function armyTotal(army) {
  let n = 0;
  for (const t of TROOP_ORDER) n += armyCount(army, t);
  return n;
}

function armyPower(army) {
  let p = 0;
  for (const t of TROOP_ORDER) p += armyCount(army, t) * TROOP_TYPES[t].str;
  return Math.ceil(p);
}

function armyBonus(army) {
  return armyCount(army, 'tanks') * 5; // tanks +5 armor
}

function effectivePower(army, attacking, vsType) {
  let p = armyPower(army) + armyBonus(army);
  const vsHeavy = vsType && ENEMY_TYPES[vsType] && ENEMY_TYPES[vsType].heavy;
  const rpgCount = armyCount(army, 'rpg');
  if (vsHeavy && rpgCount > 0) p += Math.ceil(rpgCount * TROOP_TYPES.rpg.str * 0.6);
  return p;
}

function archerPreDamage(army, vsFort) {
  let dmg = 0;
  const sniperCount = armyCount(army, 'snipers');
  dmg += Math.ceil(sniperCount * TROOP_TYPES.snipers.str * 0.6);
  const bCount = armyCount(army, 'bombers');
  if (bCount > 0) {
    dmg += Math.ceil(bCount * TROOP_TYPES.bombers.str * 0.5);
    if (vsFort) dmg += Math.ceil(bCount * TROOP_TYPES.bombers.str * 0.3);
  }
  return dmg;
}

function loseTroops(army, amount) {
  let remaining = amount;
  for (const t of TROOP_ORDER) {
    if (remaining <= 0) break;
    const strPer = TROOP_TYPES[t].str;
    const arr = army[t];
    const canLose = Math.min(arr.length, Math.ceil(remaining / strPer));
    arr.splice(arr.length - canLose, canLose);
    remaining -= canLose * strPer;
  }
}

function addTroops(army, type, count) {
  const maxHp = BATTLE_STATS[type].hp + upgrades.reinforced * 3;
  if (!Array.isArray(army[type])) army[type] = [];
  for (let i = 0; i < count; i++) army[type].push(maxHp);
}

function armySummary(army) {
  const parts = [];
  for (const t of TROOP_ORDER) {
    const c = armyCount(army, t);
    if (c > 0) parts.push(c + ' ' + TROOP_TYPES[t].name);
  }
  return parts.join(', ') || 'None';
}

// ═══════════════════════════════════════════
//  GAME INIT
// ═══════════════════════════════════════════
function newGame() {
  gold = 0; kills = 0; morale = 0;
  upgrades = { armorPiercing: 0, extendedMag: 0, reinforced: 0, explosiveRounds: 0 };
  recruitedEngineers = 0; engineerATKBonus = 0; engineerTimer = 0;
  playerForts = []; territoryMap = []; pendingAttacks = []; goldPerTurn = 0;
  fortMenuOpen = false; fortMenuIndex = -1;
  const army = newArmy();
  addTroops(army, 'riflemen', 5);
  addTroops(army, 'gunners', 3);
  if (!playerName) {
    showOverlay('CONQUERERS', 'Enter your name, commander.', 'Start Game', () => {
      initWorld(army);
    }, true);
  } else {
    initWorld(army);
  }
}

// Difficulty based on player fort count (replaces level system)
function getDifficulty() {
  return Math.max(1, playerForts.length);
}

// Regional difficulty: harder far from home
function getRegionalDifficulty(gx, gy) {
  const home = playerForts.find(f => f.isHome);
  if (!home) return getDifficulty();
  const d = Math.abs(gx - home.gx) + Math.abs(gy - home.gy);
  return getDifficulty() + Math.floor(d / 15);
}

function initWorld(startArmy, isLoad) {
  player = { x: 50, y: 50, army: {}, lastDx: 1, lastDy: 0 };
  // Copy army (HP arrays)
  for (const t of TROOP_ORDER) player.army[t] = Array.isArray(startArmy[t]) ? startArmy[t].slice() : [];

  if (!isLoad) {
    enemies = []; forts = []; allies = []; chests = []; mercCamps = []; overworldEngineers = [];
    walls = new Set();
  }
  scouted = false;
  particles = []; floatingTexts = [];
  if (!isLoad) turnCount = 0;

  if (!isLoad) {
    grassMap = []; treeMap = []; waterMap = []; pathMap = []; fogMap = [];
    for (let y = 0; y < ROWS; y++) {
      grassMap[y] = []; treeMap[y] = []; waterMap[y] = []; pathMap[y] = []; fogMap[y] = [];
      for (let x = 0; x < COLS; x++) {
        grassMap[y][x] = Math.random();
        treeMap[y][x] = Math.random() < 0.12;
        waterMap[y][x] = false;
        pathMap[y][x] = false;
        fogMap[y][x] = 0; // hidden
      }
    }
  }

  ambientParticles = [];
  tensionTimer = 0;
  followerTrail = [];
  moveQueue = [];
  isAnimating = false;
  playerVisual = { x: player.x, y: player.y };
  followerVisuals = [];

  // Seed ambient dust particles
  for (let i = 0; i < 30; i++) {
    ambientParticles.push({
      x: Math.random() * W, y: Math.random() * (H - PANEL_H),
      vx: (Math.random() - 0.5) * 0.3, vy: -0.1 - Math.random() * 0.2,
      size: 1 + Math.random() * 1.5, alpha: 0.2 + Math.random() * 0.3,
      life: 200 + randInt(0, 200), maxLife: 400,
    });
  }

  if (!isLoad) {
    generateMap();

    // Set up home fortress: pick the fort closest to player start
    if (playerForts.length === 0 && forts.length > 0) {
      let bestIdx = 0, bestDist = 9999;
      for (let i = 0; i < forts.length; i++) {
        const d = Math.abs(forts[i].x - player.x) + Math.abs(forts[i].y - player.y);
        if (d < bestDist) { bestDist = d; bestIdx = i; }
      }
      const hf = forts.splice(bestIdx, 1)[0];
      const garrison = newArmy();
      addTroops(garrison, 'riflemen', 3);
      playerForts.push({ gx: hf.x, gy: hf.y, garrison, walls: 0, turrets: 0, mines: 0, isHome: true });
      player.x = hf.x; player.y = hf.y;
      playerVisual = { x: hf.x, y: hf.y };
    }
    recalcTerritory();
  } else if (playerForts.length > 0) {
    const home = playerForts.find(f => f.isHome) || playerForts[0];
    if (home) { player.x = home.gx; player.y = home.gy; playerVisual = { x: home.gx, y: home.gy }; }
  }

  // Initialize camera
  camX = player.x; camY = player.y;

  // Initial fog reveal around player and forts
  revealAround(player.x, player.y, 5);
  for (const pf of playerForts) revealAround(pf.gx, pf.gy, 3 + (pf.walls || 0));

  initEnemyVisuals();
  minimapDirty = true;
  gameMode = 'overworld';
  updateHUD();
  msg('Conquer all enemy forts to win!');
  draw();
}

// ═══════════════════════════════════════════
//  MAP GENERATION
// ═══════════════════════════════════════════
function generateMap() {
  // Border walls
  for (let x = 0; x < COLS; x++) { walls.add(k(x, 0)); walls.add(k(x, ROWS - 1)); }
  for (let y = 0; y < ROWS; y++) { walls.add(k(0, y)); walls.add(k(COLS - 1, y)); }

  // Internal walls: 200-300 with clustering
  const wallCount = 200 + randInt(0, 100);
  for (let i = 0; i < wallCount; i++) {
    const x = randInt(2, COLS - 3), y = randInt(2, ROWS - 3);
    if (Math.abs(x - 50) <= 3 && Math.abs(y - 50) <= 3) continue; // keep center clear
    walls.add(k(x, y));
    // Cluster: add 1-3 neighbors
    const clusterSize = Math.random() < 0.4 ? randInt(1, 3) : 0;
    for (let c = 0; c < clusterSize; c++) {
      const dx = randInt(-1, 1), dy = randInt(-1, 1);
      const nx = x + dx, ny = y + dy;
      if (nx > 1 && nx < COLS - 2 && ny > 1 && ny < ROWS - 2 && !(Math.abs(nx - 50) <= 3 && Math.abs(ny - 50) <= 3))
        walls.add(k(nx, ny));
    }
  }

  // Place 8-10 enemy forts with Poisson-disk spacing (min 20 tiles apart)
  const fortCount = 8 + randInt(0, 2);
  const fortPositions = [];
  for (let i = 0; i < fortCount; i++) {
    for (let attempt = 0; attempt < 200; attempt++) {
      const fx = randInt(5, COLS - 6), fy = randInt(5, ROWS - 6);
      if (Math.abs(fx - 50) <= 8 && Math.abs(fy - 50) <= 8) continue; // not too close to center
      const tooClose = fortPositions.some(fp => Math.abs(fp.x - fx) + Math.abs(fp.y - fy) < 20);
      if (tooClose) continue;
      if (walls.has(k(fx, fy))) { walls.delete(k(fx, fy)); }
      const d = Math.abs(fx - 50) + Math.abs(fy - 50);
      const regionDiff = 1 + Math.floor(d / 15);
      forts.push({ x: fx, y: fy, str: 15 + regionDiff * 8 + randInt(0, regionDiff * 4), garrisoned: false });
      fortPositions.push({ x: fx, y: fy });
      // Clear area around fort
      for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) walls.delete(k(fx + dx, fy + dy));
      break;
    }
  }

  // Enemies: 60-80 clustered near forts
  const enemyCount = 60 + randInt(0, 20);
  for (let i = 0; i < enemyCount; i++) {
    // Pick a random fort to cluster near
    const fort = fortPositions[randInt(0, fortPositions.length - 1)];
    const p = freeSpotNear(fort.x, fort.y, 10);
    if (!p) continue;
    const regionDiff = getRegionalDifficulty(p.x, p.y);
    const type = pickEnemyType(regionDiff);
    const def = ENEMY_TYPES[type];
    const baseStr = 4 + randInt(0, regionDiff * 4);
    enemies.push({
      x: p.x, y: p.y, str: Math.ceil(baseStr * def.strMul),
      type, patrol: randInt(0, 3), charged: false, arrowCooldown: 0,
    });
  }

  // Allies: 8-12 scattered
  const allyCount = 8 + randInt(0, 4);
  for (let i = 0; i < allyCount; i++) {
    const p = freeSpot();
    const diff = getDifficulty();
    const pool = ['riflemen','riflemen','snipers','machinegun'];
    pool.push('gunners','rpg','medic');
    pool.push('tanks','flamethrower');
    pool.push('bombers','operative');
    const aType = pool[randInt(0, pool.length - 1)];
    const count = aType === 'riflemen' ? randInt(2, 5) : randInt(1, 2);
    allies.push({ x: p.x, y: p.y, troopType: aType, count });
  }

  // Chests: 15-25
  const chestCount = 15 + randInt(0, 10);
  for (let i = 0; i < chestCount; i++) {
    const p = freeSpot();
    chests.push({ x: p.x, y: p.y, gold: 10 + randInt(0, 15) });
  }

  // Mercenary camps: 5-8
  const campCount = 5 + randInt(0, 3);
  for (let i = 0; i < campCount; i++) {
    const p = freeSpot();
    const pool = ['riflemen','medic','flamethrower','snipers','operative','gunners','rpg','tanks'];
    const mType = pool[randInt(0, pool.length - 1)];
    const count = randInt(1, 2);
    const cost = Math.ceil(TROOP_TYPES[mType].cost * count * 0.7);
    mercCamps.push({ x: p.x, y: p.y, troopType: mType, count, cost });
  }

  // Engineers: 3-5
  const engCount = 3 + randInt(0, 2);
  for (let i = 0; i < engCount; i++) {
    const p = freeSpot();
    if (p) overworldEngineers.push({ x: p.x, y: p.y });
  }

  // Ensure forts are reachable from center
  for (const f of forts) {
    if (!canReach({ x: 50, y: 50 }, f)) carvePath({ x: 50, y: 50 }, f);
  }

  // Water pools: 10-15 clusters
  const waterCount = 10 + randInt(0, 5);
  for (let w = 0; w < waterCount; w++) {
    const wx = randInt(4, COLS - 5), wy = randInt(4, ROWS - 5);
    if (Math.abs(wx - 50) <= 4 && Math.abs(wy - 50) <= 4) continue;
    const occupied = forts.some(f => Math.abs(f.x - wx) <= 2 && Math.abs(f.y - wy) <= 2);
    if (occupied) continue;
    const poolSize = randInt(1, 2); // radius
    for (let dy = -poolSize; dy <= poolSize; dy++) {
      for (let dx = -poolSize; dx <= poolSize; dx++) {
        if (Math.random() < 0.6) {
          const nx = wx + dx, ny = wy + dy;
          if (nx > 1 && nx < COLS - 2 && ny > 1 && ny < ROWS - 2 && !walls.has(k(nx, ny)) &&
              !forts.some(f => f.x === nx && f.y === ny) &&
              !playerForts.some(f => f.gx === nx && f.gy === ny)) {
            waterMap[ny][nx] = true;
            walls.add(k(nx, ny));
          }
        }
      }
    }
  }

  // Paths near forts
  for (const f of forts) {
    for (let dy = -3; dy <= 3; dy++) {
      for (let dx = -3; dx <= 3; dx++) {
        const nx = f.x + dx, ny = f.y + dy;
        if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS && !walls.has(k(nx, ny)) && Math.random() < 0.5) {
          pathMap[ny][nx] = true;
        }
      }
    }
  }

  // Clear trees from walls and player spawn
  for (let y = 0; y < ROWS; y++)
    for (let x = 0; x < COLS; x++)
      if (walls.has(k(x, y)) || (Math.abs(x - 50) <= 3 && Math.abs(y - 50) <= 3)) treeMap[y][x] = false;
}

function pickEnemyType(diff) {
  const d = diff || getDifficulty();
  const pool = ['militant', 'militant'];
  if (d >= 2) pool.push('commando', 'sniper_e');
  if (d >= 3) pool.push('commando', 'apc', 'mad_scientist');
  if (d >= 4) pool.push('helicopter', 'apc', 'sniper_e');
  if (d >= 5) pool.push('helicopter', 'helicopter', 'apc');
  return pool[randInt(0, pool.length - 1)];
}

function ensureReachable() {
  // Only ensure forts are reachable from player (not every entity on 100x100)
  for (const f of forts) {
    if (!canReach(player, f)) carvePath(player, f);
  }
}

function canReach(from, to) {
  const visited = new Set();
  const queue = [{ x: from.x, y: from.y }];
  visited.add(k(from.x, from.y));
  while (queue.length) {
    const c = queue.shift();
    if (c.x === to.x && c.y === to.y) return true;
    for (const [dx, dy] of [[0,1],[0,-1],[1,0],[-1,0]]) {
      const nx = c.x + dx, ny = c.y + dy;
      const key = k(nx, ny);
      if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS && !visited.has(key) && !walls.has(key)) {
        visited.add(key); queue.push({ x: nx, y: ny });
      }
    }
  }
  return false;
}

function carvePath(from, to) {
  let x = from.x, y = from.y;
  while (x !== to.x || y !== to.y) {
    if (Math.abs(x - to.x) > Math.abs(y - to.y)) x += x < to.x ? 1 : -1;
    else y += y < to.y ? 1 : -1;
    walls.delete(k(x, y)); treeMap[y][x] = false;
  }
}

function recalcTerritory() {
  territoryMap = [];
  for (let y = 0; y < ROWS; y++) {
    territoryMap[y] = [];
    for (let x = 0; x < COLS; x++) territoryMap[y][x] = null;
  }
  // BFS from player forts
  for (const pf of playerForts) {
    const maxR = 3 + (pf.walls || 0);
    const queue = [{x: pf.gx, y: pf.gy, d: 0}];
    const visited = new Set();
    visited.add(k(pf.gx, pf.gy));
    territoryMap[pf.gy][pf.gx] = 'player';
    while (queue.length) {
      const c = queue.shift();
      if (c.d >= maxR) continue;
      for (const [dx, dy] of [[0,1],[0,-1],[1,0],[-1,0]]) {
        const nx = c.x + dx, ny = c.y + dy;
        if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) continue;
        if (visited.has(k(nx, ny))) continue;
        if (walls.has(k(nx, ny)) && !playerForts.some(f => f.gx === nx && f.gy === ny)) continue;
        if (waterMap[ny] && waterMap[ny][nx]) continue;
        visited.add(k(nx, ny));
        territoryMap[ny][nx] = 'player';
        queue.push({x: nx, y: ny, d: c.d + 1});
      }
    }
  }
  // BFS from enemy forts
  for (const ef of forts) {
    const maxR = 3;
    const queue = [{x: ef.x, y: ef.y, d: 0}];
    const visited = new Set();
    visited.add(k(ef.x, ef.y));
    if (!territoryMap[ef.y][ef.x]) territoryMap[ef.y][ef.x] = 'enemy';
    while (queue.length) {
      const c = queue.shift();
      if (c.d >= maxR) continue;
      for (const [dx, dy] of [[0,1],[0,-1],[1,0],[-1,0]]) {
        const nx = c.x + dx, ny = c.y + dy;
        if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) continue;
        if (visited.has(k(nx, ny))) continue;
        if (walls.has(k(nx, ny))) continue;
        if (waterMap[ny] && waterMap[ny][nx]) continue;
        if (territoryMap[ny][nx] === 'player') continue; // player territory takes priority
        visited.add(k(nx, ny));
        territoryMap[ny][nx] = 'enemy';
        queue.push({x: nx, y: ny, d: c.d + 1});
      }
    }
  }
  // Recalculate gold income
  goldPerTurn = 0;
  for (const pf of playerForts) {
    if (pf.mines > 0) goldPerTurn += FORT_UPGRADE_DEFS.mines[pf.mines - 1].income;
  }
  minimapDirty = true;
}

// ═══════════════════════════════════════════
//  HELPERS
// ═══════════════════════════════════════════
function k(x, y) { return x + ',' + y; }
function randInt(a, b) { return a + Math.floor(Math.random() * (b - a + 1)); }
function lerp(a, b, t) { return a + (b - a) * t; }
function dist(a, b) { return Math.abs(a.x - b.x) + Math.abs(a.y - b.y); }

function freeSpot() {
  for (let i = 0; i < 500; i++) {
    const x = randInt(2, COLS - 3), y = randInt(2, ROWS - 3);
    if (walls.has(k(x, y))) continue;
    if (waterMap[y] && waterMap[y][x]) continue;
    if (player && x === player.x && y === player.y) continue;
    if (enemies.some(e => e.x === x && e.y === y)) continue;
    if (forts.some(f => f.x === x && f.y === y)) continue;
    if (playerForts.some(f => f.gx === x && f.gy === y)) continue;
    if (allies.some(a => a.x === x && a.y === y)) continue;
    if (chests.some(c => c.x === x && c.y === y)) continue;
    return { x, y };
  }
  return { x: COLS - 2, y: ROWS - 2 };
}

function freeSpotNear(nearX, nearY, radius) {
  for (let i = 0; i < 200; i++) {
    const x = nearX + randInt(-radius, radius), y = nearY + randInt(-radius, radius);
    if (x < 1 || x >= COLS - 1 || y < 1 || y >= ROWS - 1) continue;
    if (walls.has(k(x, y))) continue;
    if (waterMap[y] && waterMap[y][x]) continue;
    if (player && x === player.x && y === player.y) continue;
    if (enemies.some(e => e.x === x && e.y === y)) continue;
    if (forts.some(f => f.x === x && f.y === y)) continue;
    if (playerForts.some(f => f.gx === x && f.gy === y)) continue;
    return { x, y };
  }
  return null;
}

function revealAround(cx, cy, r) {
  for (let dy = -r; dy <= r; dy++) {
    for (let dx = -r; dx <= r; dx++) {
      if (dx * dx + dy * dy > r * r) continue;
      const nx = cx + dx, ny = cy + dy;
      if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
        fogMap[ny][nx] = 2;
      }
    }
  }
  minimapDirty = true;
}

function dimFog() {
  // Dim all visible tiles to revealed, then re-reveal around player and forts
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      if (fogMap[y][x] === 2) fogMap[y][x] = 1;
    }
  }
  revealAround(player.x, player.y, 5);
  for (const pf of playerForts) revealAround(pf.gx, pf.gy, 3 + (pf.walls || 0));
}

function msg(t) { document.getElementById('message').textContent = t; }

function updateHUD() {
  const pw = armyPower(player.army);
  const bon = armyBonus(player.army);
  document.getElementById('nameVal').textContent = playerName;
  document.getElementById('armyVal').textContent = pw + (bon > 0 ? ' [+' + bon + ']' : '');
  document.getElementById('fortsVal').textContent = forts.length;
  // Income display
  const incEl = document.getElementById('incomeVal');
  if (incEl) incEl.textContent = goldPerTurn > 0 ? '+' + goldPerTurn + '/turn' : 'none';
  document.getElementById('goldVal').textContent = gold;
  document.getElementById('killsVal').textContent = kills;
  // Morale display
  const moraleEl = document.getElementById('moraleVal');
  moraleEl.textContent = (morale > 0 ? '+' : '') + morale;
  moraleEl.style.color = morale > 0 ? '#4caf50' : (morale < 0 ? '#f44336' : '#888');
  // Engineer display
  const engEl = document.getElementById('engVal');
  if (engEl) engEl.textContent = recruitedEngineers + (engineerATKBonus > 0 ? ' (+' + engineerATKBonus + ' ATK)' : '');
  // Update shop buttons with scaled prices
  for (const btn of document.querySelectorAll('#shop button')) {
    const onclick = btn.getAttribute('onclick') || '';
    const type = onclick.match(/shopBuy\('(\w+)'\)/)?.[1];
    if (type && TROOP_TYPES[type]) {
      const def = TROOP_TYPES[type];
      const cost = shopCost(type);
      btn.disabled = gold < cost;
      btn.textContent = def.name + ' x' + def.qty + ' (' + cost + 'g)';
    }
    if (onclick.includes('shopHealAll')) {
      const cost = healCost();
      btn.disabled = gold < cost;
      btn.textContent = 'Heal All (' + cost + 'g)';
    }
    if (onclick.includes('shopScout')) {
      btn.disabled = gold < 15 || scouted;
    }
  }
  // Update engineer buttons
  for (const btn of document.querySelectorAll('#engineer-shop button')) {
    const key = (btn.getAttribute('onclick') || '').match(/engineerBuy\('(\w+)'\)/)?.[1];
    if (key && UPGRADE_DEFS[key]) {
      const def = UPGRADE_DEFS[key];
      const lvl = upgrades[key];
      if (lvl >= def.maxLvl) {
        btn.disabled = true;
        btn.textContent = def.name + ' MAX (' + def.desc + ')';
      } else {
        const cost = def.costs[lvl];
        btn.disabled = gold < cost;
        btn.textContent = def.name + ' Lv' + lvl + '\u2192' + (lvl + 1) + ': ' + def.desc + ' (' + cost + 'g)';
      }
    }
  }
}

function spawnParticles(x, y, color, count, speed) {
  for (let i = 0; i < count; i++) {
    particles.push({
      gx: x, gy: y, // world coords
      ox: (Math.random() - 0.5) * 10, oy: (Math.random() - 0.5) * 10, // pixel offset
      vx: (Math.random() - 0.5) * speed, vy: (Math.random() - 0.5) * speed - 1,
      life: 30 + randInt(0, 20), maxLife: 50, color, size: 2 + Math.random() * 3,
    });
  }
}

function spawnFloatingText(x, y, text, color) {
  floatingTexts.push({ gx: x, gy: y, oy: -20, text, color, life: 60 });
}

// ═══════════════════════════════════════════
//  MOVEMENT & COMBAT
// ═══════════════════════════════════════════
function tryMove(dx, dy) {
  // Queue the move if still animating
  if (isAnimating) {
    if (moveQueue.length < 2) moveQueue.push({ dx, dy });
    return;
  }

  const nx = player.x + dx, ny = player.y + dy;
  if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) return;
  if (walls.has(k(nx, ny))) return;

  isAnimating = true;
  player.lastDx = dx; player.lastDy = dy;
  // Track follower trail
  followerTrail.unshift({ x: player.x, y: player.y });
  if (followerTrail.length > 3) followerTrail.length = 3;
  player.x = nx; player.y = ny;
  turnCount++;

  // Ally
  const ai = allies.findIndex(a => a.x === nx && a.y === ny);
  if (ai !== -1) {
    const a = allies[ai];
    addTroops(player.army, a.troopType, a.count);
    const td = TROOP_TYPES[a.troopType];
    spawnParticles(nx, ny, td.color, 12, 3);
    spawnFloatingText(nx, ny, '+' + a.count + ' ' + td.name, td.color);
    msg('Recruited ' + a.count + ' ' + td.name + '!');
    allies.splice(ai, 1);
  }

  // Mercenary camp
  const mi = mercCamps.findIndex(m => m.x === nx && m.y === ny);
  if (mi !== -1) {
    const m = mercCamps[mi];
    if (gold >= m.cost) {
      gold -= m.cost;
      addTroops(player.army, m.troopType, m.count);
      const td = TROOP_TYPES[m.troopType];
      spawnParticles(nx, ny, td.color, 12, 3);
      spawnFloatingText(nx, ny, '+' + m.count + ' ' + td.name, td.color);
      msg('Hired ' + m.count + ' ' + td.name + ' for ' + m.cost + 'g!');
      mercCamps.splice(mi, 1);
    } else {
      msg('Need ' + m.cost + 'g to hire ' + m.count + ' ' + TROOP_TYPES[m.troopType].name);
      // Block movement — stay on current tile
      player.x -= dx; player.y -= dy;
      isAnimating = false;
      followerTrail.shift();
      turnCount--;
      return;
    }
  }

  // Overworld engineer (FREE to recruit)
  const egi = overworldEngineers.findIndex(eg => eg.x === nx && eg.y === ny);
  if (egi !== -1) {
    recruitedEngineers++;
    overworldEngineers.splice(egi, 1);
    spawnParticles(nx, ny, '#ff9800', 12, 3);
    spawnFloatingText(nx, ny, '+1 Engineer', '#ff9800');
    msg('Engineer recruited! (' + recruitedEngineers + ' total) They craft +1 ATK every 5 min.');
  }

  // Chest (some are trapped!)
  const ci = chests.findIndex(c => c.x === nx && c.y === ny);
  if (ci !== -1) {
    const c = chests[ci];
    gold += c.gold;
    spawnParticles(nx, ny, '#ffd54f', 15, 4);
    spawnFloatingText(nx, ny, '+' + c.gold + 'g', '#ffd54f');
    chests.splice(ci, 1);
    // Trap chance: 25%, spawns an ambush enemy nearby
    if (Math.random() < 0.25) {
      const diff = getRegionalDifficulty(nx, ny);
      const trapType = pickEnemyType(diff);
      const trapDef = ENEMY_TYPES[trapType];
      const trapSpots = [[nx+1,ny],[nx-1,ny],[nx,ny+1],[nx,ny-1]].filter(
        ([tx,ty]) => tx > 0 && tx < COLS-1 && ty > 0 && ty < ROWS-1 && !walls.has(k(tx,ty)) &&
                     !(tx === player.x && ty === player.y) && !enemies.some(e => e.x === tx && e.y === ty)
      );
      if (trapSpots.length > 0) {
        const [tx, ty] = trapSpots[randInt(0, trapSpots.length - 1)];
        enemies.push({
          x: tx, y: ty, str: Math.ceil((3 + diff * 2) * trapDef.strMul),
          type: trapType, patrol: 0, charged: false, arrowCooldown: 0,
        });
        spawnParticles(tx, ty, '#ef5350', 12, 4);
        spawnFloatingText(tx, ty, 'TRAP!', '#ef5350');
        msg('Trapped chest! +' + c.gold + 'g but an enemy appears!');
        shake = 4;
      } else {
        msg('Treasure! +' + c.gold + ' gold');
      }
    } else {
      msg('Treasure! +' + c.gold + ' gold');
    }
  }

  // Enemy — enter tactical battle
  const ei = enemies.findIndex(e => e.x === nx && e.y === ny);
  if (ei !== -1) { enterBattle(enemies, ei, false); return; }

  // Player fort — open fort menu
  const pfi = playerForts.findIndex(pf => pf.gx === nx && pf.gy === ny);
  if (pfi !== -1) { showFortMenu(pfi); }

  // Fort — enter tactical battle
  const fi = forts.findIndex(f => f.x === nx && f.y === ny);
  if (fi !== -1) { enterBattle(forts, fi, true); return; }

  // Gold mine income (every turn)
  if (goldPerTurn > 0) {
    gold += goldPerTurn;
    spawnFloatingText(player.x, player.y, '+' + goldPerTurn + 'g', '#ffd54f');
  }

  // Tension timer: every 6 turns, nearby enemies get stronger
  tensionTimer++;
  if (tensionTimer % 6 === 0 && enemies.length > 0) {
    let strengthened = 0;
    for (const e of enemies) {
      if (Math.abs(e.x - player.x) + Math.abs(e.y - player.y) <= 30) { e.str += 1; strengthened++; }
    }
    if (strengthened > 0) {
      msg('Nearby enemies grow stronger...');
      spawnFloatingText(player.x, player.y, 'TENSION!', '#ff5252');
    }
  }

  // Fort garrison: spawn defenders when player is near a fort
  for (const f of forts) {
    if (!f.garrisoned && dist(player, f) <= 3) {
      f.garrisoned = true;
      const regionDiff = getRegionalDifficulty(f.x, f.y);
      const guardCount = 1 + Math.floor(regionDiff / 3);
      for (let g = 0; g < guardCount; g++) {
        const gx = f.x + randInt(-1, 1), gy = f.y + randInt(-1, 1);
        if (gx > 0 && gx < COLS - 1 && gy > 0 && gy < ROWS - 1 && !walls.has(k(gx, gy)) &&
            !(gx === player.x && gy === player.y) && !enemies.some(e => e.x === gx && e.y === gy)) {
          const gType = regionDiff >= 3 ? (Math.random() < 0.5 ? 'commando' : 'militant') : 'militant';
          const gDef = ENEMY_TYPES[gType];
          enemies.push({
            x: gx, y: gy, str: Math.ceil((3 + regionDiff * 2) * gDef.strMul),
            type: gType, patrol: 0, charged: false, arrowCooldown: 0,
          });
          spawnParticles(gx, gy, gDef.color, 10, 3);
        }
      }
      spawnFloatingText(f.x, f.y, 'GARRISON!', '#ffa726');
      msg('Fort garrison deploys defenders!');
    }
  }

  // Enemy reinforcements: every 20 turns, spawn 2-5 near random enemy forts (in fog)
  if (turnCount % 20 === 0 && turnCount > 0 && enemies.length < 80 && forts.length > 0) {
    const spawnCount = randInt(2, 5);
    for (let s = 0; s < spawnCount; s++) {
      const fort = forts[randInt(0, forts.length - 1)];
      const sp = freeSpotNear(fort.x, fort.y, 8);
      if (!sp) continue;
      if (fogMap[sp.y] && fogMap[sp.y][sp.x] === 2) continue; // don't spawn in player view
      const regionDiff = getRegionalDifficulty(sp.x, sp.y);
      const rType = pickEnemyType(regionDiff);
      const rDef = ENEMY_TYPES[rType];
      enemies.push({
        x: sp.x, y: sp.y, str: Math.ceil((3 + regionDiff * 2) * rDef.strMul),
        type: rType, patrol: 0, charged: false, arrowCooldown: 0,
      });
      initEnemyVisuals();
    }
  }

  // Chest respawning: if chests < 15, spawn 1-3 in non-visible areas
  if (turnCount % 25 === 0 && turnCount > 0 && chests.length < 15) {
    const newChests = randInt(1, 3);
    for (let i = 0; i < newChests; i++) {
      const p = freeSpot();
      if (fogMap[p.y] && fogMap[p.y][p.x] === 2) continue;
      chests.push({ x: p.x, y: p.y, gold: 10 + randInt(0, 15) });
    }
  }

  // Mad scientists spawn mutants every 9 turns
  if (turnCount % 9 === 0 && turnCount > 0 && enemies.length < 80) {
    for (const sci of enemies.filter(e => e.type === 'mad_scientist')) {
      const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
      const validSpots = dirs.map(([dx,dy]) => ({x: sci.x+dx, y: sci.y+dy}))
        .filter(s => s.x >= 0 && s.x < COLS && s.y >= 0 && s.y < ROWS && !walls.has(k(s.x,s.y)) && !enemies.some(e => e.x === s.x && e.y === s.y));
      if (validSpots.length > 0 && enemies.length < 80) {
        const sp = validSpots[randInt(0, validSpots.length - 1)];
        const mDef = ENEMY_TYPES.mutant;
        const regionDiff = getRegionalDifficulty(sp.x, sp.y);
        enemies.push({
          x: sp.x, y: sp.y, str: Math.ceil((3 + regionDiff * 2) * mDef.strMul),
          type: 'mutant', patrol: 0, charged: false, arrowCooldown: 0,
        });
        initEnemyVisuals();
        spawnParticles(sp.x, sp.y, '#76ff03', 10, 4);
        spawnFloatingText(sp.x, sp.y, 'MUTANT!', '#76ff03');
      }
    }
  }

  // Enemy attacks on player forts every 8 turns
  if (turnCount % 8 === 0 && turnCount > 0 && playerForts.length > 0) {
    checkEnemyAttacks();
  }

  // Fog of war update on move
  dimFog();

  updateHUD();
  draw();

  if (forts.length === 0) checkGameWin();
}

function checkEnemyAttacks() {
  // Find enemies near player territory that can launch attacks
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    if (!territoryMap[e.y] || territoryMap[e.y][e.x] !== 'player') continue; // only enemies IN player territory attack
    // Find closest player fort
    let bestFort = -1, bestDist = 9999;
    for (let fi = 0; fi < playerForts.length; fi++) {
      const pf = playerForts[fi];
      const d = Math.abs(e.x - pf.gx) + Math.abs(e.y - pf.gy);
      if (d < bestDist) { bestDist = d; bestFort = fi; }
    }
    if (bestFort === -1 || bestDist > 5) continue;

    const pf = playerForts[bestFort];
    const eDef = ENEMY_TYPES[e.type];
    const attackStr = e.str;

    // Fort defense = garrison power + walls defense + turret damage
    let garPower = 0;
    for (const t of TROOP_ORDER) {
      if (pf.garrison[t]) garPower += pf.garrison[t].length * TROOP_TYPES[t].str;
    }
    const wallDef = pf.walls > 0 ? FORT_UPGRADE_DEFS.walls[pf.walls - 1].def : 0;
    const turretDmg = pf.turrets > 0 ? FORT_UPGRADE_DEFS.turrets[pf.turrets - 1].dmg : 0;
    const fortDefense = garPower + wallDef + turretDmg;

    if (fortDefense >= attackStr * 0.7) {
      // Auto-resolve: fort wins
      // Garrison takes some losses
      for (const t of TROOP_ORDER) {
        if (pf.garrison[t] && pf.garrison[t].length > 0) {
          for (let h = 0; h < pf.garrison[t].length; h++) {
            pf.garrison[t][h] = Math.max(1, pf.garrison[t][h] - Math.ceil(attackStr * 0.1));
          }
        }
      }
      spawnFloatingText(pf.gx, pf.gy, 'Defended!', '#4caf50');
      msg('Fort defended against ' + eDef.name + '!');
      enemies.splice(i, 1);
    } else {
      // Strong attack — pending manual defense
      pendingAttacks.push({ fortIndex: bestFort, enemyIndex: i, strength: attackStr, type: e.type });
      const fname = pf.isHome ? 'Home Fort' : 'Fort #' + (bestFort + 1);
      // Show attack dialog with Defend and Abandon options
      const atkHtml = '<div style="text-align:center;font-family:sans-serif;">' +
        '<h3 style="color:#ef5350;margin:0 0 8px">FORT UNDER ATTACK!</h3>' +
        '<p style="color:#ccc;font-size:12px;margin:4px 0">' + fname + ' is being attacked by ' + eDef.name + ' (Str ' + attackStr + ')!</p>' +
        '<div style="margin-top:10px;display:flex;gap:8px;justify-content:center">' +
        '<button onclick="document.getElementById(\'overlay\').classList.remove(\'show\');defendFort(' + bestFort + ',' + i + ')" style="padding:6px 18px;font-size:13px;background:#1e88e5;color:#fff;border:none;border-radius:4px;cursor:pointer">Defend</button>' +
        '<button onclick="abandonFort(' + bestFort + ',' + i + ')" style="padding:6px 18px;font-size:13px;background:#555;color:#fff;border:none;border-radius:4px;cursor:pointer">Abandon</button>' +
        '</div></div>';
      document.getElementById('overlayTitle').textContent = '';
      document.getElementById('overlayMsg').innerHTML = atkHtml;
      document.getElementById('overlayBtn').style.display = 'none';
      document.getElementById('overlayInput').style.display = 'none';
      document.getElementById('overlay').classList.add('show');
      overlayCallback = null;
      return; // only one pending attack at a time
    }
  }
}

function defendFort(fortIdx, enemyIdx) {
  const pf = playerForts[fortIdx];
  const e = enemies[enemyIdx];
  if (!e) return;
  // Move player to fort
  player.x = pf.gx; player.y = pf.gy;
  playerVisual = { x: pf.gx, y: pf.gy };
  // Enter battle with the attacking enemy
  enterBattle(enemies, enemyIdx, false);
  // Add turret bonus to battle as extra damage ticks
  if (pf.turrets > 0) {
    battle.turretBonus = FORT_UPGRADE_DEFS.turrets[pf.turrets - 1].dmg;
  }
  // Auto-deploy garrison units
  for (const t of TROOP_ORDER) {
    if (pf.garrison[t] && pf.garrison[t].length > 0) {
      if (!battle.deployArmy[t]) battle.deployArmy[t] = [];
      for (const hp of pf.garrison[t]) battle.deployArmy[t].push(hp);
    }
  }
}

function abandonFort(fortIdx, enemyIdx) {
  document.getElementById('overlay').classList.remove('show');
  document.getElementById('overlayBtn').style.display = '';
  document.getElementById('overlayMsg').innerHTML = '';
  if (fortIdx >= 0 && fortIdx < playerForts.length) {
    const lostFort = playerForts[fortIdx];
    spawnFloatingText(lostFort.gx, lostFort.gy, 'Fort Abandoned!', '#f44336');
    msg('Fort abandoned to the enemy!');
    playerForts.splice(fortIdx, 1);
    // Enemy that attacked stays alive
    recalcTerritory();
  }
  pendingAttacks = [];
  updateHUD(); draw();
}

function combat(arr, idx, isAttacking) {
  const e = arr[idx];
  const def = ENEMY_TYPES[e.type];
  let eStr = e.str;

  if (def.charge && !e.charged) { eStr = Math.ceil(eStr * 1.4); e.charged = true; }

  // Player's snipers/bombers deal pre-combat damage
  const preDmg = archerPreDamage(player.army, false);
  if (preDmg > 0) eStr = Math.max(1, eStr - preDmg);

  const myPower = effectivePower(player.army, isAttacking, e.type);

  if (myPower >= eStr) {
    // Victory - capture troops of the type this enemy yields
    const yieldType = def.yields;
    const yieldDef = TROOP_TYPES[yieldType];
    const captureRate = Math.max(0.2, 0.4 - getDifficulty() * 0.02); // diminishing returns
    const capturedCount = Math.max(1, Math.ceil(e.str * captureRate / yieldDef.str));
    const goldReward = Math.floor(e.str * def.goldMul) + randInt(2, 6);
    addTroops(player.army, yieldType, capturedCount);
    gold += goldReward;
    kills++;
    spawnParticles(e.x, e.y, def.color, 20, 5);
    spawnFloatingText(e.x, e.y, '+' + capturedCount + ' ' + yieldDef.name, yieldDef.color);
    msg('Defeated ' + def.name + '! +' + capturedCount + ' ' + yieldDef.name + ', +' + goldReward + 'g');
    // Machine gunner splash: damage nearby enemies
    const mgCount = armyCount(player.army, 'machinegun');
    if (mgCount > 0) {
      const splashDmg = Math.ceil(mgCount * 2);
      for (const other of enemies) {
        if (other !== e && dist(other, e) <= 2) {
          other.str = Math.max(1, other.str - splashDmg);
          spawnParticles(other.x, other.y, '#7e57c2', 6, 3);
          spawnFloatingText(other.x, other.y, '-' + splashDmg + ' MG', '#7e57c2');
        }
      }
    }
    arr.splice(idx, 1);
  } else {
    const loss = Math.ceil((eStr - myPower) * 0.6);
    loseTroops(player.army, loss);
    shake = 8;
    spawnParticles(player.x, player.y, '#ef5350', 15, 4);
    spawnFloatingText(player.x, player.y, '-' + loss + ' power', '#ef5350');
    msg('Repelled by ' + def.name + '! (str ' + eStr + ')');
    const bx = player.x - (Math.sign(e.x - player.x) || 1);
    const by = player.y - (Math.sign(e.y - player.y) || 0);
    player.x = Math.max(1, Math.min(COLS - 2, bx));
    player.y = Math.max(1, Math.min(ROWS - 2, by));
    if (walls.has(k(player.x, player.y))) player.x += 1;
    if (armyTotal(player.army) <= 0) gameOver();
  }
}

function combatFort(idx) {
  const f = forts[idx];
  const preDmg = archerPreDamage(player.army, true);
  let fStr = Math.max(1, f.str - preDmg);
  const myPower = effectivePower(player.army, true, null);

  if (myPower >= fStr) {
    // Forts yield a mix of gunners and riflemen
    const gunGain = Math.max(1, Math.ceil(f.str * 0.15));
    const rifGain = Math.max(1, Math.ceil(f.str * 0.1));
    const goldReward = Math.floor(f.str * 0.4) + randInt(5, 15);
    addTroops(player.army, 'gunners', gunGain);
    addTroops(player.army, 'riflemen', rifGain);
    gold += goldReward;
    kills++;
    spawnParticles(f.x, f.y, '#ffd54f', 30, 6);
    spawnFloatingText(f.x, f.y, 'FORT CAPTURED!', '#ffd54f');
    msg('Fort captured! +' + gunGain + ' Gunners, +' + rifGain + ' Riflemen, +' + goldReward + 'g');
    forts.splice(idx, 1);
  } else {
    const loss = Math.ceil((fStr - myPower) * 0.5);
    loseTroops(player.army, loss);
    shake = 10;
    spawnParticles(player.x, player.y, '#ff8a65', 20, 5);
    spawnFloatingText(player.x, player.y, '-' + loss + ' power', '#ef5350');
    msg('Fort too strong! (str ' + f.str + ')');
    player.x = Math.max(1, player.x - 1);
    if (armyTotal(player.army) <= 0) gameOver();
  }
}

// ═══════════════════════════════════════════
//  ENEMY AI
// ═══════════════════════════════════════════
function moveEnemies() {
  // Enemies are stationary encounter points on overworld — no movement
}

function enemyArcherAttacks() {
  // Disabled on overworld — combat happens in tactical battle screen
  return;
  for (const e of enemies) {
    if (e.type !== 'sniper_e') continue;
    const d = dist(e, player);
    if (d >= 2 && d <= 4) {
      e.arrowCooldown = (e.arrowCooldown || 0) + 1;
      if (e.arrowCooldown >= 2) {
        const dmg = Math.max(1, Math.ceil(e.str * 0.25));
        loseTroops(player.army, dmg);
        e.arrowCooldown = 0;
        const col = ENEMY_TYPES[e.type].color;
        spawnParticles(player.x, player.y, col, 8, 3);
        spawnFloatingText(player.x, player.y, '-' + dmg + ' (sniper)', col);
        msg('Enemy Sniper fires! Lost troops.');
        if (armyTotal(player.army) <= 0) gameOver();
      }
    }
  }
}


// ═══════════════════════════════════════════
//  SHOP
// ═══════════════════════════════════════════
function shopCost(type) {
  return TROOP_TYPES[type].cost + Math.floor((getDifficulty() - 1) * 3);
}

function shopBuy(type) {
  const def = TROOP_TYPES[type];
  const cost = shopCost(type);
  if (gold >= cost) {
    gold -= cost;
    addTroops(player.army, type, def.qty);
    spawnFloatingText(player.x, player.y, '+' + def.qty + ' ' + def.name, def.color);
    msg('Recruited ' + def.qty + ' ' + def.name + '!');
    updateHUD(); draw();
  }
}

function shopScout() {
  if (gold < 15 || scouted) return;
  gold -= 15;
  scouted = true;
  // Reveal all enemy fort locations (set fog=1 around them so they show on minimap)
  for (const f of forts) {
    for (let dy = -2; dy <= 2; dy++) {
      for (let dx = -2; dx <= 2; dx++) {
        const nx = f.x + dx, ny = f.y + dy;
        if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS && fogMap[ny][nx] === 0) {
          fogMap[ny][nx] = 1;
        }
      }
    }
  }
  minimapDirty = true;
  msg('Scout reveals all enemy fort locations!');
  updateHUD(); draw();
}

function healCost() { return 20 + Math.floor((getDifficulty() - 1) * 2); }

function shopHealAll() {
  const cost = healCost();
  if (gold >= cost) {
    gold -= cost;
    // Heal all units to full HP
    for (const t of TROOP_ORDER) {
      const maxHp = BATTLE_STATS[t].hp + upgrades.reinforced * 3;
      const arr = player.army[t];
      if (Array.isArray(arr)) {
        for (let i = 0; i < arr.length; i++) arr[i] = maxHp;
      }
    }
    spawnFloatingText(player.x, player.y, 'HEALED!', '#4caf50');
    msg('All troops healed to full HP!');
    updateHUD(); draw();
  }
}

const UPGRADE_DEFS = {
  armorPiercing:   { name: 'AP Rounds',      maxLvl: 3, costs: [30, 60, 100], desc: '+1 ATK all' },
  extendedMag:     { name: 'Ext. Barrels',    maxLvl: 2, costs: [40, 80],      desc: '+1 Range all' },
  reinforced:      { name: 'Reinforced',      maxLvl: 3, costs: [25, 50, 85],  desc: '+3 HP all' },
  explosiveRounds: { name: 'Explosive Rds',   maxLvl: 2, costs: [50, 90],      desc: '+1 AOE RPG/MG/Bomb' },
};

const FORT_UPGRADE_DEFS = {
  walls:   [{cost:80, def:2, name:'Wood Walls'},{cost:160, def:5, name:'Stone Walls'},{cost:300, def:10, name:'Iron Walls'}],
  turrets: [{cost:100, dmg:3, name:'Watchtower'},{cost:200, dmg:7, name:'Gun Tower'},{cost:350, dmg:12, name:'Missile Tower'}],
  mines:   [{cost:120, income:5, name:'Prospector'},{cost:250, income:12, name:'Mine Shaft'},{cost:400, income:20, name:'Deep Drill'}],
};

function engineerBuy(key) {
  const def = UPGRADE_DEFS[key];
  const lvl = upgrades[key];
  if (lvl >= def.maxLvl) return;
  const cost = def.costs[lvl];
  if (gold >= cost) {
    gold -= cost;
    upgrades[key]++;
    // If reinforced upgrade, heal existing units' HP arrays to account for new max
    if (key === 'reinforced') {
      for (const t of TROOP_ORDER) {
        const arr = player.army[t];
        if (Array.isArray(arr)) {
          for (let i = 0; i < arr.length; i++) arr[i] += 3;
        }
      }
    }
    spawnFloatingText(player.x, player.y, def.name + ' Lv' + upgrades[key], '#ff8a65');
    msg('Engineer upgrade: ' + def.name + ' Lv' + upgrades[key] + '!');
    updateHUD(); draw();
  }
}

// ═══════════════════════════════════════════
//  WIN / LOSE
// ═══════════════════════════════════════════
function checkGameWin() {
  const summary = armySummary(player.army);
  showOverlay('CONQUEST COMPLETE!',
    'Well fought, ' + playerName + '!\nAll enemy forts conquered!\nForts owned: ' + playerForts.length +
    '\nArmy: ' + summary + '\nKills: ' + kills + '\nGold: ' + gold,
    'New Game', () => { playerName = ''; newGame(); });
  autoSave();
}

function gameOver() {
  showOverlay('DEFEATED',
    playerName + ', your army was destroyed.\nForts captured: ' + playerForts.length + '\nKills: ' + kills,
    'Try Again', () => { playerName = ''; newGame(); });
}

let overlayCallback = null;
function showOverlay(title, message, btnText, cb, showInput) {
  document.getElementById('overlayTitle').textContent = title;
  document.getElementById('overlayTitle').style.color = (title === 'VICTORY!' || title === 'CONQUEST COMPLETE!') ? '#aed581' : (title === 'CONQUERERS' ? '#f0c040' : '#ef5350');
  document.getElementById('overlayMsg').textContent = message;
  document.getElementById('overlayBtn').textContent = btnText;
  const input = document.getElementById('overlayInput');
  input.style.display = showInput ? 'block' : 'none';
  if (showInput) { input.value = ''; setTimeout(() => input.focus(), 100); }
  document.getElementById('overlay').classList.add('show');
  overlayCallback = cb;
}
function overlayAction() {
  const input = document.getElementById('overlayInput');
  if (input.style.display !== 'none') {
    const name = input.value.trim();
    if (!name) { input.focus(); return; }
    playerName = name;
  }
  document.getElementById('overlay').classList.remove('show');
  if (overlayCallback) overlayCallback();
}

// ═══════════════════════════════════════════
//  SAVE / LOAD SYSTEM
// ═══════════════════════════════════════════
const SAVE_KEY = 'conquerers_saves';
const MAX_SLOTS = 5; // slot 0 = auto, slots 1-4 = manual

function getSaves() {
  try { return JSON.parse(localStorage.getItem(SAVE_KEY)) || {}; } catch { return {}; }
}

function saveGame(slot) {
  if (!player) return;
  const saves = getSaves();
  saves['slot' + slot] = {
    playerName, gold, kills, morale,
    playerX: player.x, playerY: player.y,
    army: player.army,
    upgrades: { ...upgrades },
    recruitedEngineers, engineerATKBonus,
    playerForts: playerForts.map(f => ({...f, garrison: {...f.garrison}})),
    goldPerTurn, turnCount,
    // Full world state
    enemies: enemies.map(e => ({ x: e.x, y: e.y, str: e.str, type: e.type, patrol: e.patrol, charged: e.charged, garrisoned: e.garrisoned || false })),
    forts: forts.map(f => ({ x: f.x, y: f.y, str: f.str, garrisoned: f.garrisoned || false })),
    allies: allies.slice(),
    chests: chests.slice(),
    mercCamps: mercCamps ? mercCamps.slice() : [],
    overworldEngineers: overworldEngineers ? overworldEngineers.slice() : [],
    walls: [...walls],
    fogMap: fogMap.map(row => row.slice()),
    grassMap: grassMap.map(row => row.slice()),
    treeMap: treeMap.map(row => row.slice()),
    waterMap: waterMap.map(row => row.slice()),
    pathMap: pathMap.map(row => row.slice()),
    scouted,
    timestamp: Date.now(),
  };
  localStorage.setItem(SAVE_KEY, JSON.stringify(saves));
}

function loadGame(slot) {
  const saves = getSaves();
  const data = saves['slot' + slot];
  if (!data) return false;
  playerName = data.playerName || 'Commander';
  gold = data.gold || 0;
  kills = data.kills || 0;
  morale = data.morale || 0;
  upgrades = data.upgrades || { armorPiercing: 0, extendedMag: 0, reinforced: 0, explosiveRounds: 0 };
  recruitedEngineers = data.recruitedEngineers || 0;
  engineerATKBonus = data.engineerATKBonus || 0;
  engineerTimer = 0;
  turnCount = data.turnCount || 0;
  scouted = data.scouted || false;
  // Restore fort data
  if (data.playerForts) {
    playerForts = data.playerForts.map(f => {
      const garrison = newArmy();
      if (f.garrison) { for (const t of TROOP_ORDER) { if (Array.isArray(f.garrison[t])) garrison[t] = f.garrison[t].slice(); } }
      return { gx: f.gx, gy: f.gy, garrison, walls: f.walls || 0, turrets: f.turrets || 0, mines: f.mines || 0, isHome: f.isHome || false };
    });
  } else {
    playerForts = [];
  }
  goldPerTurn = data.goldPerTurn || 0;
  pendingAttacks = [];

  // Restore full world state
  if (data.enemies) enemies = data.enemies.map(e => ({ ...e, vx: e.x, vy: e.y, arrowCooldown: 0 }));
  else enemies = [];
  if (data.forts) forts = data.forts.slice();
  else forts = [];
  allies = data.allies || [];
  chests = data.chests || [];
  mercCamps = data.mercCamps || [];
  overworldEngineers = data.overworldEngineers || [];
  walls = new Set(data.walls || []);

  // Restore terrain maps
  grassMap = []; treeMap = []; waterMap = []; pathMap = []; fogMap = [];
  for (let y = 0; y < ROWS; y++) {
    grassMap[y] = data.grassMap ? data.grassMap[y] || [] : [];
    treeMap[y] = data.treeMap ? data.treeMap[y] || [] : [];
    waterMap[y] = data.waterMap ? data.waterMap[y] || [] : [];
    pathMap[y] = data.pathMap ? data.pathMap[y] || [] : [];
    fogMap[y] = data.fogMap ? data.fogMap[y] || [] : [];
    // Fill any missing columns
    for (let x = grassMap[y].length; x < COLS; x++) {
      grassMap[y][x] = Math.random();
      treeMap[y][x] = false;
      waterMap[y][x] = false;
      pathMap[y][x] = false;
      fogMap[y][x] = 0;
    }
  }

  const army = newArmy();
  if (data.army) {
    for (const t of TROOP_ORDER) {
      if (Array.isArray(data.army[t])) army[t] = data.army[t].slice();
    }
  }

  // Use initWorld with isLoad=true to skip map regeneration
  initWorld(army, true);
  // Restore player position from save
  if (data.playerX !== undefined) {
    player.x = data.playerX; player.y = data.playerY;
    playerVisual = { x: player.x, y: player.y };
    camX = player.x; camY = player.y;
  }
  recalcTerritory();
  updateHUD();
  return true;
}

function deleteSave(slot) {
  const saves = getSaves();
  delete saves['slot' + slot];
  localStorage.setItem(SAVE_KEY, JSON.stringify(saves));
}

function autoSave() {
  saveGame(0);
}

function showSaveLoadUI() {
  const saves = getSaves();
  let html = '<div style="text-align:center;font-family:sans-serif;">';
  html += '<h3 style="color:#f0c040;margin:0 0 8px">SAVE / LOAD</h3>';
  for (let s = 0; s < MAX_SLOTS; s++) {
    const data = saves['slot' + s];
    const label = s === 0 ? 'Auto' : 'Slot ' + s;
    if (data) {
      const date = new Date(data.timestamp).toLocaleString();
      const info = data.playerName + ' | ' + (data.forts ? data.forts.length : '?') + ' forts | ' + data.gold + 'g | ' + date;
      html += '<div style="margin:4px 0;display:flex;gap:4px;justify-content:center;align-items:center;">';
      html += '<span style="color:#aaa;width:40px;text-align:right;font-size:11px">' + label + '</span>';
      html += '<span style="color:#ccc;font-size:10px;width:180px;text-align:left;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">' + info + '</span>';
      html += '<button onclick="loadGame(' + s + ');document.getElementById(\'overlay\').classList.remove(\'show\')" style="font-size:10px;padding:2px 6px">Load</button>';
      if (s > 0) html += '<button onclick="saveGame(' + s + ');showSaveLoadUI()" style="font-size:10px;padding:2px 6px">Save</button>';
      html += '<button onclick="deleteSave(' + s + ');showSaveLoadUI()" style="font-size:10px;padding:2px 6px;color:#f44336">Del</button>';
      html += '</div>';
    } else {
      html += '<div style="margin:4px 0;display:flex;gap:4px;justify-content:center;align-items:center;">';
      html += '<span style="color:#aaa;width:40px;text-align:right;font-size:11px">' + label + '</span>';
      html += '<span style="color:#666;font-size:10px;width:180px;text-align:left">Empty</span>';
      if (s > 0) html += '<button onclick="saveGame(' + s + ');showSaveLoadUI()" style="font-size:10px;padding:2px 6px">Save</button>';
      html += '</div>';
    }
  }
  html += '<button onclick="document.getElementById(\'overlay\').classList.remove(\'show\')" style="margin-top:8px;padding:4px 16px">Close</button>';
  html += '</div>';
  document.getElementById('overlayTitle').textContent = '';
  document.getElementById('overlayMsg').innerHTML = html;
  document.getElementById('overlayBtn').style.display = 'none';
  document.getElementById('overlayInput').style.display = 'none';
  document.getElementById('overlay').classList.add('show');
  overlayCallback = () => { document.getElementById('overlayBtn').style.display = ''; document.getElementById('overlayMsg').innerHTML = ''; };
}

function showFortMenu(idx) {
  fortMenuOpen = true; fortMenuIndex = idx;
  const pf = playerForts[idx];
  let html = '<div style="text-align:center;font-family:sans-serif;max-width:380px;margin:auto;">';
  html += '<h3 style="color:#64b5f6;margin:0 0 6px">' + (pf.isHome ? 'HOME FORTRESS' : 'FORT #' + (idx + 1)) + '</h3>';

  // Garrison display
  html += '<div style="color:#aaa;font-size:11px;margin-bottom:6px">Garrison:</div>';
  html += '<div style="display:flex;flex-wrap:wrap;gap:2px;justify-content:center;margin-bottom:8px">';
  let hasGarrison = false;
  for (const t of TROOP_ORDER) {
    const count = pf.garrison[t] ? pf.garrison[t].length : 0;
    const armyCount2 = player.army[t] ? player.army[t].length : 0;
    if (count > 0 || armyCount2 > 0) {
      hasGarrison = hasGarrison || count > 0;
      html += '<div style="background:#1a1a2e;padding:2px 4px;border-radius:3px;font-size:10px">';
      html += '<span style="color:' + TROOP_TYPES[t].color + '">' + TROOP_TYPES[t].name + '</span>';
      html += ' <span style="color:#888">' + count + '</span>';
      html += ' <button onclick="garrisonTransfer(' + idx + ',\'' + t + '\',\'toFort\')" style="font-size:9px;padding:0 3px" title="Move to garrison">+</button>';
      html += ' <button onclick="garrisonTransfer(' + idx + ',\'' + t + '\',\'toArmy\')" style="font-size:9px;padding:0 3px" title="Move to army">-</button>';
      html += '</div>';
    }
  }
  if (!hasGarrison) html += '<span style="color:#666;font-size:10px">Empty</span>';
  html += '</div>';

  // Upgrades
  html += '<div style="color:#aaa;font-size:11px;margin-bottom:4px">Upgrades:</div>';
  for (const uType of ['walls','turrets','mines']) {
    const lvl = pf[uType] || 0;
    const defs = FORT_UPGRADE_DEFS[uType];
    const maxed = lvl >= defs.length;
    const nextDef = maxed ? null : defs[lvl];
    const icons = {walls:'\u{1F9F1}',turrets:'\u{1F3EF}',mines:'\u{26CF}'};
    html += '<div style="margin:3px 0;font-size:11px;color:#ccc">';
    html += icons[uType] + ' ' + uType.charAt(0).toUpperCase() + uType.slice(1) + ': ';
    if (lvl > 0) html += '<span style="color:#4fc3f7">' + defs[lvl - 1].name + '</span>';
    else html += '<span style="color:#666">None</span>';
    if (!maxed) {
      html += ' <button onclick="fortUpgrade(' + idx + ',\'' + uType + '\')" style="font-size:10px;padding:1px 6px">';
      html += nextDef.name + ' (' + nextDef.cost + 'g)</button>';
    } else {
      html += ' <span style="color:#4caf50;font-size:10px">MAX</span>';
    }
    html += '</div>';
  }

  html += '<button onclick="closeFortMenu()" style="margin-top:8px;padding:4px 16px">Close</button>';
  html += '</div>';
  document.getElementById('overlayTitle').textContent = '';
  document.getElementById('overlayMsg').innerHTML = html;
  document.getElementById('overlayBtn').style.display = 'none';
  document.getElementById('overlayInput').style.display = 'none';
  document.getElementById('overlay').classList.add('show');
  overlayCallback = closeFortMenu;
}

function tryBuildFort() {
  const px = player.x, py = player.y;
  // Check we're on player territory
  if (!territoryMap[py] || territoryMap[py][px] !== 'player') {
    msg('Must be in your territory to build a fort!'); return;
  }
  // Check not on existing fort
  if (playerForts.some(f => f.gx === px && f.gy === py)) { msg('Already a fort here!'); return; }
  if (forts.some(f => f.x === px && f.y === py)) { msg('Enemy fort here!'); return; }
  // Cost scales with number of forts
  const cost = 100 + 30 * (playerForts.length - 1);
  if (gold < cost) { msg('Need ' + cost + 'g to build a fort'); return; }
  gold -= cost;
  playerForts.push({ gx: px, gy: py, garrison: newArmy(), walls: 0, turrets: 0, mines: 0, isHome: false });
  recalcTerritory();
  spawnParticles(px, py, '#64b5f6', 15, 5);
  spawnFloatingText(px, py, 'Fort Built!', '#64b5f6');
  msg('Fort built! (-' + cost + 'g)');
  updateHUD(); draw();
}

function closeFortMenu() {
  fortMenuOpen = false; fortMenuIndex = -1;
  document.getElementById('overlay').classList.remove('show');
  document.getElementById('overlayBtn').style.display = '';
  document.getElementById('overlayMsg').innerHTML = '';
  updateHUD(); draw();
}

function fortUpgrade(idx, type) {
  const pf = playerForts[idx];
  const lvl = pf[type] || 0;
  const defs = FORT_UPGRADE_DEFS[type];
  if (lvl >= defs.length) return;
  const cost = defs[lvl].cost;
  if (gold < cost) { msg('Need ' + cost + 'g for ' + defs[lvl].name); return; }
  gold -= cost;
  pf[type] = lvl + 1;
  if (type === 'walls') recalcTerritory();
  if (type === 'mines') {
    goldPerTurn = 0;
    for (const f of playerForts) {
      if (f.mines > 0) goldPerTurn += FORT_UPGRADE_DEFS.mines[f.mines - 1].income;
    }
  }
  spawnFloatingText(pf.gx, pf.gy, defs[lvl].name + '!', '#64b5f6');
  showFortMenu(idx); // refresh
}

function garrisonTransfer(idx, troopType, direction) {
  const pf = playerForts[idx];
  if (!pf.garrison[troopType]) pf.garrison[troopType] = [];
  if (direction === 'toFort') {
    if (!player.army[troopType] || player.army[troopType].length === 0) return;
    const garTotal = TROOP_ORDER.reduce((s, t) => s + (pf.garrison[t] ? pf.garrison[t].length : 0), 0);
    if (garTotal >= 10) { msg('Garrison full (10 max)'); return; }
    pf.garrison[troopType].push(player.army[troopType].pop());
  } else {
    if (pf.garrison[troopType].length === 0) return;
    if (!player.army[troopType]) player.army[troopType] = [];
    player.army[troopType].push(pf.garrison[troopType].pop());
  }
  showFortMenu(idx); // refresh
}

// ═══════════════════════════════════════════
//  DRAWING - ISO HELPERS
// ═══════════════════════════════════════════
function drawIsoDiamond(sx, sy, fill) {
  ctx.fillStyle = fill;
  ctx.beginPath();
  ctx.moveTo(sx, sy - TILE_H / 2);
  ctx.lineTo(sx + TILE_W / 2, sy);
  ctx.lineTo(sx, sy + TILE_H / 2);
  ctx.lineTo(sx - TILE_W / 2, sy);
  ctx.closePath();
  ctx.fill();
}

function isoDiamondPath(sx, sy) {
  ctx.beginPath();
  ctx.moveTo(sx, sy - TILE_H / 2);
  ctx.lineTo(sx + TILE_W / 2, sy);
  ctx.lineTo(sx, sy + TILE_H / 2);
  ctx.lineTo(sx - TILE_W / 2, sy);
  ctx.closePath();
}

function drawIsoBox(sx, sy, h, topCol, leftCol, rightCol) {
  // Top face
  ctx.fillStyle = topCol;
  ctx.beginPath();
  ctx.moveTo(sx, sy - h - TILE_H / 2);
  ctx.lineTo(sx + TILE_W / 2, sy - h);
  ctx.lineTo(sx, sy - h + TILE_H / 2);
  ctx.lineTo(sx - TILE_W / 2, sy - h);
  ctx.closePath();
  ctx.fill();
  // Left face
  ctx.fillStyle = leftCol;
  ctx.beginPath();
  ctx.moveTo(sx - TILE_W / 2, sy - h);
  ctx.lineTo(sx, sy - h + TILE_H / 2);
  ctx.lineTo(sx, sy + TILE_H / 2);
  ctx.lineTo(sx - TILE_W / 2, sy);
  ctx.closePath();
  ctx.fill();
  // Right face
  ctx.fillStyle = rightCol;
  ctx.beginPath();
  ctx.moveTo(sx + TILE_W / 2, sy - h);
  ctx.lineTo(sx, sy - h + TILE_H / 2);
  ctx.lineTo(sx, sy + TILE_H / 2);
  ctx.lineTo(sx + TILE_W / 2, sy);
  ctx.closePath();
  ctx.fill();
}

// ═══════════════════════════════════════════
//  DRAWING - MAIN
// ═══════════════════════════════════════════
function draw() {
  const sx = shake > 0.1 ? (Math.random() - 0.5) * shake : 0;
  const sy = shake > 0.1 ? (Math.random() - 0.5) * shake : 0;
  // shake decay handled in updateSmooth()

  ctx.save();
  ctx.translate(sx, sy);

  ctx.fillStyle = '#0d1117';
  ctx.fillRect(0, 0, W, H);

  const panelTop = H - PANEL_H;

  // Viewport culling
  const vr = getVisibleRange();

  // Build entity lookup maps for O(1) per-tile checks
  const _chestMap = new Map(), _allyMap = new Map(), _fortMap = new Map(), _enemyMap = new Map(), _mercMap = new Map(), _engMap = new Map();
  for (const c of chests) _chestMap.set(k(c.x, c.y), c);
  for (const a of allies) _allyMap.set(k(a.x, a.y), a);
  for (const f of forts)  _fortMap.set(k(f.x, f.y), f);
  for (const e of enemies) _enemyMap.set(k(e.x, e.y), e);
  if (mercCamps) for (const m of mercCamps) _mercMap.set(k(m.x, m.y), m);
  if (overworldEngineers) for (const eg of overworldEngineers) _engMap.set(k(eg.x, eg.y), eg);
  const _pFortMap = new Map();
  for (const pf of playerForts) _pFortMap.set(k(pf.gx, pf.gy), pf);
  const topTypes = getTopTroopTypes();
  const _followerMap = new Map();
  for (let fi = 0; fi < Math.min(topTypes.length, followerTrail.length); fi++) {
    const fpos = followerTrail[fi];
    if (!walls.has(k(fpos.x, fpos.y))) _followerMap.set(k(fpos.x, fpos.y), fi);
  }

  // Z-sorted render: iterate visible tiles in painter's algorithm order
  const minSum = vr.minX + vr.minY;
  const maxSum = vr.maxX + vr.maxY;
  for (let sum = minSum; sum <= maxSum; sum++) {
    for (let x = Math.max(vr.minX, sum - vr.maxY); x <= Math.min(vr.maxX, sum - vr.minY); x++) {
      const y = sum - x;
      if (y < 0 || y >= ROWS || x < 0 || x >= COLS) continue;
      const iso = toIso(x, y);
      // Skip tiles completely offscreen
      if (iso.x < -TILE_W || iso.x > W + TILE_W || iso.y < -80 || iso.y > H) continue;
      const tKey = k(x, y);
      const fog = fogMap[y] ? fogMap[y][x] : 0;

      // fog=0: dark tile
      if (fog === 0) {
        drawFogTile(iso.x, iso.y, x, y);
        continue;
      }

      // fog=1 or fog=2: draw terrain
      if (waterMap[y][x]) drawWater(iso.x, iso.y, x, y);
      else if (walls.has(tKey)) drawWall(iso.x, iso.y, x, y);
      else {
        drawGround(iso.x, iso.y, grassMap[y][x], x, y);
        if (treeMap[y][x]) drawTree(iso.x, iso.y, x, y);
      }

      // fog=1: show static entities (forts, chests) but dim
      if (fog === 1) {
        const fo = _fortMap.get(tKey); if (fo) drawFort(iso.x, iso.y, fo.str);
        const pfo = _pFortMap.get(tKey); if (pfo) drawPlayerFort(iso.x, iso.y, pfo);
        const ch = _chestMap.get(tKey); if (ch) drawChest(iso.x, iso.y, ch.gold);
        // Dim overlay
        ctx.fillStyle = 'rgba(8,12,18,0.45)';
        isoDiamondPath(iso.x, iso.y);
        ctx.fill();
        continue;
      }

      // fog=2: draw everything
      const ch = _chestMap.get(tKey); if (ch) drawChest(iso.x, iso.y, ch.gold);
      const al = _allyMap.get(tKey);  if (al) drawAllyUnit(al, iso.x, iso.y);
      const mc = _mercMap.get(tKey);  if (mc) drawMercCamp(mc, iso.x, iso.y);
      const eg = _engMap.get(tKey);   if (eg) drawOverworldEngineer(eg, iso.x, iso.y);
      const fo = _fortMap.get(tKey);  if (fo) drawFort(iso.x, iso.y, fo.str);
      const pfo = _pFortMap.get(tKey); if (pfo) drawPlayerFort(iso.x, iso.y, pfo);
      const en = _enemyMap.get(tKey);
      if (en) {
        const eiso = toIso(en.vx !== undefined ? en.vx : en.x, en.vy !== undefined ? en.vy : en.y);
        drawEnemy(en, eiso.x, eiso.y);
      }

      // Followers — O(1) lookup
      const fli = _followerMap.get(tKey);
      if (fli !== undefined) {
        const fv = followerVisuals[fli] || followerTrail[fli];
        const fiso = toIso(fv.x, fv.y);
        drawFollowerAt(fiso.x, fiso.y, topTypes[fli], fli);
      }

      // Player uses smooth visual position
      if (player.x === x && player.y === y) {
        const piso = toIso(playerVisual.x, playerVisual.y);
        drawPlayer(piso.x, piso.y);
      }
    }
  }

  // Movement hints (above terrain, below UI)
  drawMovementHints();

  // Ambient particles
  updateAmbientParticles();
  updateParticles();
  updateFloatingTexts();

  // Dynamic lighting pass - warm glow from visible forts
  for (const f of forts) {
    const fiso = toIso(f.x, f.y);
    if (fiso.x < -100 || fiso.x > W + 100 || fiso.y < -100 || fiso.y > H + 100) continue;
    if (fogMap[f.y] && fogMap[f.y][f.x] < 2) continue;
    const flGrad = ctx.createRadialGradient(fiso.x, fiso.y, 10, fiso.x, fiso.y, 100);
    flGrad.addColorStop(0, 'rgba(255,160,60,0.06)');
    flGrad.addColorStop(0.5, 'rgba(255,120,40,0.03)');
    flGrad.addColorStop(1, 'rgba(255,100,30,0)');
    ctx.fillStyle = flGrad;
    ctx.fillRect(fiso.x - 100, fiso.y - 100, 200, 200);
  }

  // Minimap
  drawMinimap();

  // Vignette overlay (elliptical, centered on iso map)
  const mapCX = W / 2, mapCY = (H - PANEL_H) / 2;
  const vigGrad = ctx.createRadialGradient(mapCX, mapCY, W * 0.22, mapCX, mapCY, W * 0.65);
  vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
  vigGrad.addColorStop(0.7, 'rgba(0,0,0,0.15)');
  vigGrad.addColorStop(1, 'rgba(0,0,0,0.45)');
  ctx.fillStyle = vigGrad;
  ctx.fillRect(0, 0, W, panelTop);

  // Army panel at bottom
  drawArmyPanel();

  ctx.restore();
}

function drawFogTile(sx, sy, tx, ty) {
  const gv = grassMap[ty][tx];
  ctx.save();
  isoDiamondPath(sx, sy);
  ctx.clip();
  const fogGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, TILE_W * 0.4);
  fogGrad.addColorStop(0, 'rgb(' + Math.floor(12+gv*6) + ',' + Math.floor(14+gv*4) + ',' + Math.floor(22+gv*5) + ')');
  fogGrad.addColorStop(1, '#080c12');
  ctx.fillStyle = fogGrad;
  ctx.fillRect(sx - TILE_W/2, sy - TILE_H/2, TILE_W, TILE_H);
  if (gv > 0.9) {
    const twinkle = Math.sin(animFrame * 0.08 + tx * 5 + ty * 3) * 0.3 + 0.3;
    ctx.fillStyle = 'rgba(180,200,255,' + twinkle + ')';
    ctx.fillRect(sx - 10 + gv * 20, sy - 5 + gv * 8, 1, 1);
  }
  ctx.restore();
}

function drawFogEdge(x, y, sx, sy) {
  return; // Fog handled in main draw loop
  for (const [dx, dy] of [[0,1],[0,-1],[1,0],[-1,0]]) {
    const nx = x + dx, ny = y + dy;
    if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
      ctx.save();
      isoDiamondPath(sx, sy);
      ctx.clip();
      const niso = toIso(nx, ny);
      const dirX = niso.x - sx, dirY = niso.y - sy;
      const fromX = sx + dirX * 0.5, fromY = sy + dirY * 0.5;
      const grad = ctx.createRadialGradient(sx + dirX * 0.4, sy + dirY * 0.4, 0, sx + dirX * 0.4, sy + dirY * 0.4, TILE_W * 0.35);
      grad.addColorStop(0, 'rgba(8,12,18,0.5)');
      grad.addColorStop(1, 'rgba(8,12,18,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(sx - TILE_W/2, sy - TILE_H/2, TILE_W, TILE_H);
      ctx.restore();
    }
  }
}

function drawMovementHints() {
  const hintPulse = 0.08 + Math.sin(animFrame * 0.08) * 0.05;
  for (const [dx, dy] of [[0,1],[0,-1],[1,0],[-1,0]]) {
    const hx = player.x + dx, hy = player.y + dy;
    if (hx >= 0 && hx < COLS && hy >= 0 && hy < ROWS && !walls.has(k(hx, hy))) {
      const hiso = toIso(hx, hy);
      if (hiso.x < -TILE_W || hiso.x > W + TILE_W || hiso.y < -40 || hiso.y > H) continue;
      const hasEnemy = enemies.some(e => e.x === hx && e.y === hy);
      const hasFort = forts.some(f => f.x === hx && f.y === hy);
      const hasAlly = allies.some(a => a.x === hx && a.y === hy);
      const hasChest = chests.some(c => c.x === hx && c.y === hy);
      let hCol = '79,195,247';
      if (hasEnemy || hasFort) hCol = '255,100,100';
      else if (hasAlly) hCol = '100,255,100';
      else if (hasChest) hCol = '255,213,79';
      ctx.fillStyle = 'rgba(' + hCol + ',' + (hintPulse + 0.06) + ')';
      isoDiamondPath(hiso.x, hiso.y);
      ctx.fill();
      ctx.strokeStyle = 'rgba(' + hCol + ',' + (hintPulse + 0.1) + ')';
      ctx.lineWidth = 1.5;
      isoDiamondPath(hiso.x, hiso.y);
      ctx.stroke();
    }
  }
}

// ═══════════════════════════════════════════
//  DRAWING - ARMY PANEL
// ═══════════════════════════════════════════
function drawArmyPanel() {
  const panelY = H - PANEL_H;

  // Panel background with gradient
  const panelGrad = ctx.createLinearGradient(0, panelY, 0, panelY + PANEL_H);
  panelGrad.addColorStop(0, '#161e30');
  panelGrad.addColorStop(0.3, '#121a2a');
  panelGrad.addColorStop(1, '#0a1018');
  ctx.fillStyle = panelGrad;
  ctx.fillRect(0, panelY, W, PANEL_H);
  // Top emboss line
  ctx.fillStyle = '#3a4a6a';
  ctx.fillRect(0, panelY, W, 1);
  ctx.fillStyle = '#1a2a44';
  ctx.fillRect(0, panelY + 1, W, 1);

  drawPanelRow(panelY + 3, TROOP_ORDER, 0);
}

function drawPanelRow(rowY, types, startIdx) {
  const slotW = W / types.length;
  for (let i = 0; i < types.length; i++) {
    const type = types[i];
    const def = TROOP_TYPES[type];
    const hpArr = Array.isArray(player.army[type]) ? player.army[type] : [];
    const count = hpArr.length;
    const sx = i * slotW;
    const cx = sx + slotW / 2;
    const cy = rowY + 16;

    if (count > 0) {
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      ctx.fillRect(sx + 2, rowY + 1, slotW - 4, 44);
    }

    drawMiniTroop(cx - 12, cy - 8, type, def);

    ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
    ctx.fillStyle = count > 0 ? def.color : '#334';
    ctx.fillText(count, cx + 10, cy - 1);

    ctx.font = '8px sans-serif';
    ctx.fillStyle = count > 0 ? '#aab' : '#334';
    ctx.fillText(def.name, cx, cy + 14);

    // Health bar (average HP)
    if (count > 0) {
      const maxHp = BATTLE_STATS[type].hp + upgrades.reinforced * 3;
      const avgHp = hpArr.reduce((s, h) => s + h, 0) / count;
      const hpFrac = avgHp / maxHp;
      const barW = slotW - 20, barH = 3;
      const barX = sx + 10, barY = cy + 20;
      ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.fillRect(barX, barY, barW, barH);
      ctx.fillStyle = hpFrac > 0.5 ? '#4caf50' : (hpFrac > 0.25 ? '#ff9800' : '#f44336');
      ctx.fillRect(barX, barY, barW * hpFrac, barH);
      ctx.font = '6px sans-serif'; ctx.fillStyle = '#778';
      ctx.fillText(Math.round(avgHp) + '/' + maxHp, cx, barY + 10);
    }

    if (i < types.length - 1) {
      ctx.fillStyle = '#1a2a3a';
      ctx.fillRect(sx + slotW - 1, rowY + 3, 1, 32);
    }
  }
}

function drawMinimap() {
  const mmX = W - MINIMAP_SIZE - 8, mmY = 8;
  const scale = MINIMAP_SIZE / COLS;

  // Render terrain/fog to offscreen canvas when dirty
  if (minimapDirty) {
    mmCtx.fillStyle = '#0a0a1a';
    mmCtx.fillRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const fog = fogMap[y] ? fogMap[y][x] : 0;
        if (fog === 0) continue; // dark
        const px = x * scale, py = y * scale;
        if (waterMap[y] && waterMap[y][x]) { mmCtx.fillStyle = fog === 2 ? '#1a3050' : '#101828'; }
        else if (walls.has(k(x, y))) { mmCtx.fillStyle = fog === 2 ? '#2a2a3a' : '#1a1a24'; }
        else { mmCtx.fillStyle = fog === 2 ? '#1a2e18' : '#101a10'; }
        mmCtx.fillRect(px, py, Math.ceil(scale), Math.ceil(scale));
        // Territory colors
        if (territoryMap[y] && territoryMap[y][x]) {
          mmCtx.fillStyle = territoryMap[y][x] === 'player' ? 'rgba(30,100,200,0.3)' : 'rgba(200,50,50,0.3)';
          mmCtx.fillRect(px, py, Math.ceil(scale), Math.ceil(scale));
        }
      }
    }
    // Enemy forts (red dots)
    for (const f of forts) {
      if (fogMap[f.y] && fogMap[f.y][f.x] > 0) {
        mmCtx.fillStyle = '#ff4444';
        mmCtx.fillRect(f.x * scale - 1, f.y * scale - 1, 3, 3);
      }
    }
    // Player forts (blue dots)
    for (const pf of playerForts) {
      mmCtx.fillStyle = pf.isHome ? '#ffd54f' : '#4fc3f7';
      mmCtx.fillRect(pf.gx * scale - 1, pf.gy * scale - 1, 3, 3);
    }
    minimapDirty = false;
  }

  // Draw cached minimap
  ctx.drawImage(minimapCanvas, mmX, mmY);

  // Dynamic elements: player (blinking white dot)
  const blink = Math.sin(animFrame * 0.15) > 0;
  if (blink) {
    ctx.fillStyle = '#fff';
    ctx.fillRect(mmX + player.x * scale - 1, mmY + player.y * scale - 1, 3, 3);
  }

  // Viewport rectangle
  const vr = getVisibleRange();
  ctx.strokeStyle = 'rgba(255,255,255,0.4)';
  ctx.lineWidth = 1;
  ctx.strokeRect(mmX + vr.minX * scale, mmY + vr.minY * scale,
    (vr.maxX - vr.minX) * scale, (vr.maxY - vr.minY) * scale);

  // Border
  ctx.strokeStyle = '#3a4a6a';
  ctx.lineWidth = 1;
  ctx.strokeRect(mmX, mmY, MINIMAP_SIZE, MINIMAP_SIZE);
}

function drawMiniTroop(x, y, type, def) {
  ctx.fillStyle = def.color;
  switch (type) {
    case 'riflemen':
      ctx.fillRect(x + 3, y + 2, 6, 8);
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(x + 6, y, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#555'; ctx.fillRect(x + 3, y - 4, 6, 3); // helmet
      ctx.fillStyle = '#333'; ctx.fillRect(x + 9, y - 1, 6, 2); // rifle
      break;
    case 'snipers':
      ctx.fillRect(x + 3, y + 2, 6, 8);
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(x + 6, y, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = def.dark; ctx.fillRect(x + 2, y - 4, 8, 3); // hood
      ctx.fillStyle = '#333'; ctx.fillRect(x + 8, y - 2, 8, 1.5); // long rifle
      ctx.fillStyle = def.color; ctx.beginPath(); ctx.arc(x + 14, y - 3, 1.5, 0, Math.PI * 2); ctx.fill(); // scope
      break;
    case 'machinegun':
      ctx.fillRect(x + 2, y + 2, 8, 8);
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(x + 6, y, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#444'; ctx.fillRect(x + 2, y - 4, 8, 3); // helmet
      ctx.fillStyle = '#333'; ctx.fillRect(x + 8, y - 1, 7, 3); // MG body
      ctx.fillStyle = '#222'; ctx.fillRect(x + 13, y - 2, 3, 1); // barrel
      break;
    case 'gunners':
      ctx.fillRect(x + 2, y + 1, 8, 9);
      ctx.fillStyle = def.dark; ctx.fillRect(x + 3, y + 2, 6, 4);
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(x + 6, y - 1, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#333'; ctx.fillRect(x + 2, y - 5, 8, 3);
      ctx.fillStyle = '#222'; ctx.fillRect(x + 9, y, 6, 2); ctx.fillRect(x + 13, y - 1, 3, 1);
      break;
    case 'rpg':
      ctx.fillRect(x + 3, y + 2, 6, 8);
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(x + 6, y, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#555'; ctx.fillRect(x + 3, y - 4, 6, 3);
      // RPG tube on shoulder
      ctx.fillStyle = '#4e342e'; ctx.fillRect(x + 7, y - 6, 2, 8);
      ctx.fillStyle = def.color; ctx.beginPath(); ctx.moveTo(x + 6, y - 7); ctx.lineTo(x + 10, y - 7); ctx.lineTo(x + 8, y - 10); ctx.fill(); // warhead
      break;
    case 'tanks':
      // Mini tank
      ctx.fillStyle = def.dark; ctx.fillRect(x, y + 3, 14, 7);
      ctx.fillStyle = def.color; ctx.fillRect(x + 1, y + 4, 12, 5);
      ctx.fillStyle = '#444'; ctx.fillRect(x + 4, y, 6, 5); // turret
      ctx.fillStyle = '#333'; ctx.fillRect(x + 10, y + 1, 6, 2); // barrel
      ctx.fillStyle = '#222';
      ctx.beginPath(); ctx.arc(x + 3, y + 10, 2, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(x + 7, y + 10, 2, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(x + 11, y + 10, 2, 0, Math.PI * 2); ctx.fill();
      break;
    case 'bombers':
      // Mini airplane
      ctx.fillStyle = def.color; ctx.fillRect(x + 2, y + 2, 10, 4); // fuselage
      ctx.fillStyle = def.dark;
      ctx.beginPath(); ctx.moveTo(x + 12, y + 3); ctx.lineTo(x + 16, y + 4); ctx.lineTo(x + 12, y + 5); ctx.fill(); // nose
      // Wings
      ctx.fillRect(x + 4, y - 2, 4, 3);
      ctx.fillRect(x + 4, y + 6, 4, 3);
      // Tail
      ctx.fillRect(x, y, 3, 2); ctx.fillRect(x, y + 6, 3, 2);
      // Bomb
      ctx.fillStyle = '#f44336'; ctx.beginPath(); ctx.arc(x + 7, y + 8, 1.5, 0, Math.PI * 2); ctx.fill();
      break;
    case 'medic':
      // Green body with white cross
      ctx.fillRect(x + 3, y + 2, 6, 8);
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(x + 6, y, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = def.dark; ctx.fillRect(x + 3, y - 4, 6, 3); // helmet
      // White cross on body
      ctx.fillStyle = '#fff'; ctx.fillRect(x + 5, y + 3, 2, 5); ctx.fillRect(x + 4, y + 4.5, 4, 2);
      break;
    case 'flamethrower':
      // Orange body with flame nozzle
      ctx.fillRect(x + 3, y + 2, 6, 8);
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(x + 6, y, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = def.dark; ctx.fillRect(x + 3, y - 4, 6, 3); // helmet
      // Fuel tank on back
      ctx.fillStyle = '#4e342e'; ctx.fillRect(x, y + 1, 3, 6);
      // Nozzle + flame
      ctx.fillStyle = '#333'; ctx.fillRect(x + 9, y - 1, 5, 2);
      ctx.fillStyle = '#ff9800'; ctx.beginPath(); ctx.arc(x + 15, y, 2, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ffeb3b'; ctx.beginPath(); ctx.arc(x + 15, y, 1, 0, Math.PI * 2); ctx.fill();
      break;
    case 'operative':
      // Purple body with suppressed weapon
      ctx.fillRect(x + 3, y + 2, 6, 8);
      ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(x + 6, y, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = def.dark; ctx.fillRect(x + 2, y - 4, 8, 3); // beret
      // Suppressed pistol
      ctx.fillStyle = '#333'; ctx.fillRect(x + 9, y - 1, 5, 1.5);
      ctx.fillStyle = '#555'; ctx.fillRect(x + 13, y - 1.5, 3, 2); // suppressor
      break;
    case 'helicopter':
      // Mini heli body
      ctx.fillStyle = def.dark;
      ctx.beginPath(); ctx.moveTo(x + 2, y + 4); ctx.lineTo(x + 5, y); ctx.lineTo(x + 12, y);
      ctx.lineTo(x + 14, y + 4); ctx.lineTo(x + 12, y + 7); ctx.lineTo(x + 4, y + 7); ctx.closePath(); ctx.fill();
      ctx.fillStyle = def.color;
      ctx.fillRect(x + 4, y + 1, 8, 5);
      // Rotor
      const rSpin2 = animFrame * 0.3;
      ctx.strokeStyle = 'rgba(150,150,150,0.7)'; ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x + 8 + Math.cos(rSpin2) * 8, y - 1 + Math.sin(rSpin2) * 1.5);
      ctx.lineTo(x + 8 - Math.cos(rSpin2) * 8, y - 1 - Math.sin(rSpin2) * 1.5);
      ctx.stroke();
      // Tail
      ctx.fillStyle = def.dark; ctx.fillRect(x, y + 3, 3, 1.5);
      break;
  }
}

// ═══════════════════════════════════════════
//  DRAWING - TERRAIN (ISOMETRIC)
// ═══════════════════════════════════════════
function drawGround(sx, sy, gv, tx, ty) {
  const isPath = pathMap[ty] && pathMap[ty][tx];

  // Fill diamond directly (no clip — use path fill instead)
  if (isPath) {
    const r = Math.floor(lerp(42,58,gv)), g = Math.floor(lerp(33,44,gv)), b = Math.floor(lerp(20,30,gv));
    ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
    isoDiamondPath(sx, sy);
    ctx.fill();
  } else {
    // Vary shade slightly for visual interest
    const rShade = Math.floor(lerp(22, 34, gv));
    const gShade = Math.floor(lerp(38, 58, gv));
    const bShade = Math.floor(lerp(18, 30, gv));
    ctx.fillStyle = 'rgb(' + rShade + ',' + gShade + ',' + bShade + ')';
    isoDiamondPath(sx, sy);
    ctx.fill();
    // Grass tufts (kept — cheap)
    if (gv > 0.35) {
      ctx.fillStyle = 'rgba(' + Math.floor(50+gv*30) + ',' + Math.floor(85+gv*30) + ',' + Math.floor(30+gv*15) + ',0.5)';
      for (let j = 0; j < 3; j++) {
        const gx2 = sx - 12 + ((gv * (20 + j * 17)) % 24);
        const gy2 = sy - 4 + ((gv * (10 + j * 11)) % 8);
        ctx.fillRect(gx2, gy2, 1, 3);
      }
    }
  }

  // Territory overlay
  if (territoryMap[ty] && territoryMap[ty][tx]) {
    const owner = territoryMap[ty][tx];
    ctx.fillStyle = owner === 'player' ? 'rgba(30,100,200,0.15)' : 'rgba(200,50,50,0.15)';
    isoDiamondPath(sx, sy);
    ctx.fill();
  }

  // Diamond outline
  ctx.strokeStyle = 'rgba(0,0,0,0.1)';
  ctx.lineWidth = 0.5;
  isoDiamondPath(sx, sy);
  ctx.stroke();
}

function drawWater(sx, sy, tx, ty) {
  const wave = Math.sin(animFrame * 0.05 + tx * 1.5 + ty * 0.8);

  // Water base (diamond fill, no clip)
  const r = Math.floor(15 + wave * 4), g = Math.floor(48 + wave * 8), b = Math.floor(85 + wave * 12);
  ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
  isoDiamondPath(sx, sy);
  ctx.fill();

  // A few wave lines (simplified)
  ctx.fillStyle = 'rgba(120,200,255,' + (0.12 + wave * 0.06) + ')';
  for (let i = -12; i < 12; i += 8) {
    const wy = sy - 2 + Math.sin(animFrame * 0.06 + (sx + i) * 0.12) * 2;
    ctx.fillRect(sx + i, wy, 3, 1);
  }

  // Diamond border
  ctx.strokeStyle = 'rgba(5,20,45,0.5)';
  ctx.lineWidth = 1.5;
  isoDiamondPath(sx, sy);
  ctx.stroke();
}

function drawWall(sx, sy, wx, wy) {
  const isEdge = (wx === 0 || wx === COLS - 1 || wy === 0 || wy === ROWS - 1);
  const seed = (wx * 7 + wy * 13) % 100 / 100;
  const h = WALL_HEIGHT;
  const topCol = isEdge ? '#3a3a4e' : '#505068';
  const leftCol = isEdge ? '#2a2a3a' : '#3a3a50';
  const rightCol = isEdge ? '#1e1e2e' : '#2a2a3e';

  // 3D extruded wall box
  drawIsoBox(sx, sy, h, topCol, leftCol, rightCol);

  // Ambient occlusion at base
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  isoDiamondPath(sx, sy);
  ctx.fill();
}

function drawTree(sx, sy, tx, ty) {
  const sway = Math.sin(animFrame * 0.03 + tx * 2.5 + ty * 1.3) * 1;
  // Drop shadow on ground plane (elongated ellipse)
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath(); ctx.ellipse(sx + 6, sy + 6, 12, 5, 0.3, 0, Math.PI * 2); ctx.fill();
  // Trunk (vertical cylinder in iso)
  ctx.fillStyle = '#3d2a15'; ctx.fillRect(sx - 2, sy - 16, 5, 18);
  ctx.fillStyle = '#5a3d20'; ctx.fillRect(sx - 1, sy - 15, 3, 16);
  ctx.fillStyle = '#4a3018'; ctx.fillRect(sx, sy - 10, 1, 5); // bark line
  // Foliage layers (bottom to top) with sway and depth darkening
  ctx.fillStyle = '#1a4210';
  ctx.beginPath(); ctx.ellipse(sx + sway, sy - 14, 12, 8, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#245a16';
  ctx.beginPath(); ctx.ellipse(sx - 1 + sway, sy - 18, 10, 7, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#307020';
  ctx.beginPath(); ctx.ellipse(sx + 1 + sway, sy - 22, 8, 6, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#3c8828';
  ctx.beginPath(); ctx.ellipse(sx + sway, sy - 25, 6, 4, 0, 0, Math.PI * 2); ctx.fill();
  // Top-left light dappling
  ctx.fillStyle = 'rgba(100,180,60,0.3)';
  ctx.beginPath(); ctx.ellipse(sx - 2 + sway, sy - 25, 4, 3, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = 'rgba(140,210,80,0.2)';
  ctx.beginPath(); ctx.ellipse(sx - 3 + sway, sy - 26, 3, 2, 0, 0, Math.PI * 2); ctx.fill();
}

// ═══════════════════════════════════════════
//  DRAWING - FOLLOWERS
// ═══════════════════════════════════════════
function getTopTroopTypes() {
  // Return up to 3 strongest troop types the player has
  const owned = TROOP_ORDER.filter(t => armyCount(player.army, t) > 0);
  owned.sort((a, b) => TROOP_TYPES[b].str - TROOP_TYPES[a].str);
  return owned.slice(0, 3);
}

function drawFollowers() {
  // Now handled inline in the z-sorted draw loop
}

function drawFollowerAt(sx, sy, type, idx) {
  const def = TROOP_TYPES[type];
  const bob = Math.sin(animFrame * 0.1 + idx * 2) * 1;
  const scale = 0.85 - idx * 0.05;
  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath(); ctx.ellipse(sx, sy + 4, 8 * scale, 3 * scale, 0, 0, Math.PI * 2); ctx.fill();
  ctx.globalAlpha = 0.7;
  drawMiniTroop(sx - 8, sy - 12 + bob, type, def);
  // Count badge
  const fCount = armyCount(player.army, type);
  ctx.font = 'bold 8px sans-serif'; ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillText(fCount, sx + 1, sy + bob + 9);
  ctx.fillStyle = def.color;
  ctx.fillText(fCount, sx, sy + bob + 8);
  ctx.globalAlpha = 1;
}

// ═══════════════════════════════════════════
//  DRAWING - PLAYER
// ═══════════════════════════════════════════
function drawPlayer(sx, sy) {
  const cx = sx, cy = sy;
  const bob = Math.sin(animFrame * 0.1) * 1.5;
  const bon = armyBonus(player.army);

  // Player glow aura on iso ground (enhanced with double-ring)
  const glowPulse = 0.14 + Math.sin(animFrame * 0.06) * 0.06;
  const glowOuter = ctx.createRadialGradient(cx, cy, 4, cx, cy, 38);
  glowOuter.addColorStop(0, 'rgba(79,195,247,' + (glowPulse + 0.04) + ')');
  glowOuter.addColorStop(0.3, 'rgba(50,160,240,' + (glowPulse * 0.6) + ')');
  glowOuter.addColorStop(0.6, 'rgba(40,120,200,' + (glowPulse * 0.25) + ')');
  glowOuter.addColorStop(1, 'rgba(30,100,180,0)');
  ctx.fillStyle = glowOuter;
  ctx.fillRect(cx - 44, cy - 44, 88, 88);

  // Ground ellipse ring (double ring for emphasis)
  ctx.strokeStyle = 'rgba(79,195,247,0.2)'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.ellipse(cx, cy + 4, 18, 8, 0, 0, Math.PI * 2); ctx.stroke();
  ctx.strokeStyle = 'rgba(79,195,247,0.35)'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.ellipse(cx, cy + 4, 14, 6, 0, 0, Math.PI * 2); ctx.stroke();
  // Drop shadow (softer, larger)
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.beginPath(); ctx.ellipse(cx + 3, cy + 6, 12, 4.5, 0.2, 0, Math.PI * 2); ctx.fill();

  const by = cy - 10 + bob;

  // === ELITE SPECIAL FORCES OPERATOR ===

  // Combat boots - 8" tactical with tread detail
  const bootLGrad = ctx.createLinearGradient(cx - 7, by + 11, cx - 1, by + 15);
  bootLGrad.addColorStop(0, '#2a2218'); bootLGrad.addColorStop(0.5, '#1e1610'); bootLGrad.addColorStop(1, '#141008');
  ctx.fillStyle = bootLGrad;
  ctx.fillRect(cx - 7, by + 11, 6, 4);
  const bootRGrad = ctx.createLinearGradient(cx + 1, by + 11, cx + 7, by + 15);
  bootRGrad.addColorStop(0, '#2a2218'); bootRGrad.addColorStop(0.5, '#1e1610'); bootRGrad.addColorStop(1, '#141008');
  ctx.fillStyle = bootRGrad;
  ctx.fillRect(cx + 1, by + 11, 6, 4);
  // Boot soles (vibram-style tread)
  ctx.fillStyle = '#0a0a08'; ctx.fillRect(cx - 8, by + 14, 7, 1.5); ctx.fillRect(cx, by + 14, 7, 1.5);
  // Tread pattern
  ctx.fillStyle = '#161610';
  for (let t = 0; t < 3; t++) { ctx.fillRect(cx - 7 + t * 2, by + 14.5, 1, 0.5); ctx.fillRect(cx + 1 + t * 2, by + 14.5, 1, 0.5); }
  // Boot highlights (leather sheen)
  ctx.fillStyle = 'rgba(255,255,255,0.07)';
  ctx.fillRect(cx - 6, by + 11, 4, 1); ctx.fillRect(cx + 2, by + 11, 4, 1);
  // Boot lacing (X pattern)
  ctx.strokeStyle = '#3a3020'; ctx.lineWidth = 0.4;
  for (let l = 0; l < 3; l++) {
    const ly = by + 11.5 + l * 1;
    ctx.beginPath(); ctx.moveTo(cx - 5.5, ly); ctx.lineTo(cx - 3, ly + 0.5); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx - 3, ly); ctx.lineTo(cx - 5.5, ly + 0.5); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx + 2.5, ly); ctx.lineTo(cx + 5, ly + 0.5); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx + 5, ly); ctx.lineTo(cx + 2.5, ly + 0.5); ctx.stroke();
  }
  // Boot tongue
  ctx.fillStyle = '#2a2218'; ctx.fillRect(cx - 5, by + 11, 2, 0.8); ctx.fillRect(cx + 3, by + 11, 2, 0.8);
  // Ankle padding
  ctx.fillStyle = '#221a10'; ctx.fillRect(cx - 7, by + 11, 1, 3); ctx.fillRect(cx + 6, by + 11, 1, 3);

  // Legs (MultiCam BDU pants) with gradient shading
  const legLGrad = ctx.createLinearGradient(cx - 7, by + 3, cx - 1, by + 11);
  legLGrad.addColorStop(0, '#5a6a48'); legLGrad.addColorStop(0.5, '#4a5a3a'); legLGrad.addColorStop(1, '#3a4a2a');
  ctx.fillStyle = legLGrad;
  ctx.fillRect(cx - 7, by + 3, 6, 9);
  const legRGrad = ctx.createLinearGradient(cx + 1, by + 3, cx + 7, by + 11);
  legRGrad.addColorStop(0, '#526242'); legRGrad.addColorStop(0.5, '#485838'); legRGrad.addColorStop(1, '#3a4a2a');
  ctx.fillStyle = legRGrad;
  ctx.fillRect(cx + 1, by + 3, 6, 9);
  // Organic MultiCam camo blobs on legs
  ctx.fillStyle = '#3a4a28';
  ctx.beginPath(); ctx.ellipse(cx - 5, by + 6, 2, 1.5, 0.4, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx + 4, by + 5, 1.5, 2, -0.3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#5a6a48';
  ctx.beginPath(); ctx.ellipse(cx - 3, by + 9, 1.5, 1.5, 0.2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx + 3, by + 8, 2, 1, -0.2, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#7a8860';
  ctx.beginPath(); ctx.ellipse(cx - 4, by + 4, 1, 1.5, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#2e3e20';
  ctx.beginPath(); ctx.ellipse(cx + 5, by + 10, 1.5, 1, 0.5, 0, Math.PI * 2); ctx.fill();
  // Knee pads (D3O style, contoured)
  const kpGrad = ctx.createLinearGradient(cx - 6, by + 6, cx - 2, by + 8);
  kpGrad.addColorStop(0, '#3a3a2e'); kpGrad.addColorStop(0.5, '#444438'); kpGrad.addColorStop(1, '#333328');
  ctx.fillStyle = kpGrad;
  ctx.beginPath();
  ctx.moveTo(cx - 6, by + 6.5); ctx.quadraticCurveTo(cx - 4, by + 5.5, cx - 2, by + 6.5);
  ctx.lineTo(cx - 2, by + 8); ctx.quadraticCurveTo(cx - 4, by + 8.8, cx - 6, by + 8); ctx.closePath(); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(cx + 2, by + 6.5); ctx.quadraticCurveTo(cx + 4, by + 5.5, cx + 6, by + 6.5);
  ctx.lineTo(cx + 6, by + 8); ctx.quadraticCurveTo(cx + 4, by + 8.8, cx + 2, by + 8); ctx.closePath(); ctx.fill();
  // Knee pad highlights
  ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(cx - 5.5, by + 6.5, 3, 0.8); ctx.fillRect(cx + 2.5, by + 6.5, 3, 0.8);
  // Cargo pockets (both legs)
  ctx.fillStyle = '#3d4d2e'; ctx.fillRect(cx - 6, by + 8, 3, 2.5); ctx.fillRect(cx + 3, by + 8, 3, 2.5);
  ctx.strokeStyle = '#2e3e20'; ctx.lineWidth = 0.4;
  ctx.strokeRect(cx - 6, by + 8, 3, 2.5); ctx.strokeRect(cx + 3, by + 8, 3, 2.5);
  // Pocket flap buttons
  ctx.fillStyle = '#4a5a3a'; ctx.fillRect(cx - 5, by + 8, 1, 0.5); ctx.fillRect(cx + 4, by + 8, 1, 0.5);
  // Belt with rigger's belt buckle
  ctx.fillStyle = '#3a3a2a'; ctx.fillRect(cx - 7, by + 3, 14, 1.8);
  ctx.fillStyle = '#555540'; ctx.fillRect(cx - 1, by + 3, 2.5, 1.8); // cobra buckle
  ctx.fillStyle = 'rgba(255,255,255,0.08)'; ctx.fillRect(cx - 0.5, by + 3.2, 1.5, 0.5);
  // Drop leg holster (right thigh)
  ctx.fillStyle = '#2a2a22'; ctx.fillRect(cx + 5, by + 4, 2.5, 3.5);
  ctx.fillStyle = '#333'; ctx.fillRect(cx + 5.5, by + 4, 1.5, 2.5); // pistol grip
  // Holster strap
  ctx.strokeStyle = '#3a3a2a'; ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.moveTo(cx + 5, by + 4); ctx.lineTo(cx + 6, by + 3); ctx.stroke();

  // Body (MultiCam combat shirt) with enhanced gradient
  const bodyGrad = ctx.createLinearGradient(cx - 9, by - 7, cx + 9, by + 5);
  bodyGrad.addColorStop(0, '#5e7050'); bodyGrad.addColorStop(0.3, '#566846'); bodyGrad.addColorStop(0.6, '#4a5a3a'); bodyGrad.addColorStop(1, '#3a4a2a');
  ctx.fillStyle = bodyGrad;
  ctx.fillRect(cx - 9, by - 7, 18, 13);
  // Organic MultiCam pattern on torso
  ctx.fillStyle = '#3a4a28';
  ctx.beginPath(); ctx.ellipse(cx - 5, by - 4, 3, 2, 0.3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx + 4, by + 1, 2.5, 2, -0.2, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#5a6a48';
  ctx.beginPath(); ctx.ellipse(cx + 1, by - 5, 2.5, 1.5, 0.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx - 4, by + 2, 2, 1.5, -0.3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#2e3e1e';
  ctx.beginPath(); ctx.ellipse(cx + 6, by + 3, 2, 1.5, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx - 2, by - 1, 1.5, 2, 0.6, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#7a886a';
  ctx.beginPath(); ctx.ellipse(cx - 6, by - 2, 1.5, 1, 0.2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx + 2, by - 4, 1.5, 1, -0.4, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#4a3a28';
  ctx.beginPath(); ctx.ellipse(cx, by + 3, 2, 1, 0, 0, Math.PI * 2); ctx.fill();
  // Body directional lighting (top-left highlight, bottom-right shadow)
  ctx.fillStyle = 'rgba(255,255,220,0.1)';
  ctx.fillRect(cx - 8, by - 7, 9, 5);
  ctx.fillStyle = 'rgba(0,0,0,0.12)';
  ctx.fillRect(cx + 2, by + 1, 6, 5);
  // Shirt collar
  ctx.fillStyle = '#4a5a3a'; ctx.fillRect(cx - 3, by - 7, 6, 1.5);
  ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(cx - 2, by - 7, 4, 0.5);

  // Tactical plate carrier vest (JPC 2.0 style)
  const vestGrad = ctx.createLinearGradient(cx - 6, by - 6, cx + 6, by + 4);
  vestGrad.addColorStop(0, '#505040'); vestGrad.addColorStop(0.4, '#4a4a38'); vestGrad.addColorStop(1, '#383828');
  ctx.fillStyle = vestGrad;
  ctx.fillRect(cx - 6, by - 6, 12, 10);
  // MOLLE webbing (horizontal laser-cut)
  ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.lineWidth = 0.6;
  for (let r = 0; r < 5; r++) {
    const ry = by - 5 + r * 2;
    ctx.beginPath(); ctx.moveTo(cx - 5, ry); ctx.lineTo(cx + 5, ry); ctx.stroke();
    // MOLLE slot holes
    for (let s = 0; s < 4; s++) {
      ctx.fillStyle = 'rgba(0,0,0,0.08)';
      ctx.fillRect(cx - 4 + s * 2.5, ry + 0.5, 1.5, 0.5);
    }
  }
  // Front plate area (slightly raised look)
  ctx.fillStyle = 'rgba(255,255,255,0.04)'; ctx.fillRect(cx - 4, by - 5, 8, 8);
  // Triple mag pouches (KYWI style)
  ctx.fillStyle = '#3e3e2c';
  ctx.fillRect(cx - 5, by - 2, 3, 4.5); ctx.fillRect(cx - 1.5, by - 2, 3, 4.5); ctx.fillRect(cx + 2, by - 2, 3, 4.5);
  // Mag pouch elastic retention (kydex insert)
  ctx.fillStyle = '#2a2a1e';
  ctx.fillRect(cx - 4.5, by - 2, 2, 0.8); ctx.fillRect(cx - 1, by - 2, 2, 0.8); ctx.fillRect(cx + 2.5, by - 2, 2, 0.8);
  // PMAG tips visible
  ctx.fillStyle = '#444438';
  ctx.fillRect(cx - 4.5, by - 2, 2, 0.4); ctx.fillRect(cx - 1, by - 2, 2, 0.4); ctx.fillRect(cx + 2.5, by - 2, 2, 0.4);
  // Pouch outlines
  ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 0.4;
  ctx.strokeRect(cx - 5, by - 2, 3, 4.5); ctx.strokeRect(cx - 1.5, by - 2, 3, 4.5); ctx.strokeRect(cx + 2, by - 2, 3, 4.5);
  // Admin pouch (zippered)
  ctx.fillStyle = '#363626'; ctx.fillRect(cx - 3, by - 5, 6, 3);
  ctx.strokeStyle = '#2a2a1a'; ctx.lineWidth = 0.3; ctx.strokeRect(cx - 3, by - 5, 6, 3);
  // Zipper pull
  ctx.fillStyle = '#555'; ctx.fillRect(cx + 2.5, by - 5, 0.5, 1);
  // Comms PTT on chest
  ctx.fillStyle = '#2a2a22'; ctx.fillRect(cx + 4, by - 4, 1.5, 2);
  ctx.fillStyle = '#333'; ctx.fillRect(cx + 4.2, by - 3.5, 1, 1); // button
  // Vest highlight (top-left light)
  ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(cx - 5, by - 5, 6, 1.5);
  // Shoulder straps (padded)
  ctx.fillStyle = '#404030';
  ctx.fillRect(cx - 7, by - 6, 2.5, 5); ctx.fillRect(cx + 5, by - 6, 2.5, 5);
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  ctx.fillRect(cx - 6.5, by - 6, 1.5, 1); ctx.fillRect(cx + 5.5, by - 6, 1.5, 1);
  // Cummerbund (side wrap)
  ctx.fillStyle = '#3a3a2a'; ctx.fillRect(cx - 8, by - 3, 2, 6); ctx.fillRect(cx + 6, by - 3, 2, 6);

  // Hydration tube (from back to front)
  ctx.strokeStyle = '#2a2a22'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(cx - 7, by - 5); ctx.quadraticCurveTo(cx - 8, by - 3, cx - 7, by - 1); ctx.stroke();
  ctx.fillStyle = '#333'; ctx.fillRect(cx - 8, by - 1, 1.5, 1); // bite valve

  if (bon > 0) {
    ctx.strokeStyle = 'rgba(100,220,120,0.35)'; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(cx - 10, by - 8); ctx.lineTo(cx + 10, by - 8);
    ctx.lineTo(cx + 10, by + 7); ctx.lineTo(cx - 10, by + 7); ctx.closePath();
    ctx.stroke();
  }

  // Arms (combat shirt sleeves) with improved shading
  const armLGrad = ctx.createLinearGradient(cx - 13, by - 4, cx - 8, by + 5);
  armLGrad.addColorStop(0, '#5e7050'); armLGrad.addColorStop(0.5, '#4e6040'); armLGrad.addColorStop(1, '#3a4a2a');
  ctx.fillStyle = armLGrad;
  ctx.fillRect(cx - 13, by - 4, 5, 10);
  const armRGrad = ctx.createLinearGradient(cx + 8, by - 4, cx + 13, by + 5);
  armRGrad.addColorStop(0, '#526242'); armRGrad.addColorStop(0.5, '#485838'); armRGrad.addColorStop(1, '#3a4a2a');
  ctx.fillStyle = armRGrad;
  ctx.fillRect(cx + 8, by - 4, 5, 10);
  // Arm camo blobs
  ctx.fillStyle = '#3a4a28';
  ctx.beginPath(); ctx.ellipse(cx - 11, by - 1, 1.5, 1.5, 0.3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx + 10, by + 1, 1.5, 1.5, -0.2, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#5a6a48';
  ctx.beginPath(); ctx.ellipse(cx - 10, by + 3, 1, 1.5, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx + 11, by - 2, 1.5, 1, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#7a886a';
  ctx.beginPath(); ctx.ellipse(cx - 12, by + 1, 1, 1, 0, 0, Math.PI * 2); ctx.fill();
  // Elbow pads (D3O style)
  ctx.fillStyle = '#3a3a2e'; ctx.fillRect(cx - 13, by + 2, 4, 2.5); ctx.fillRect(cx + 9, by + 2, 4, 2.5);
  ctx.fillStyle = 'rgba(255,255,255,0.05)'; ctx.fillRect(cx - 12.5, by + 2, 3, 0.5); ctx.fillRect(cx + 9.5, by + 2, 3, 0.5);
  // Forearms (rolled sleeves showing skin)
  ctx.fillStyle = '#c8a882'; ctx.fillRect(cx - 13, by + 4, 4, 2); ctx.fillRect(cx + 9, by + 4, 4, 2);
  // Tactical watch (left wrist)
  ctx.fillStyle = '#1a1a1a'; ctx.fillRect(cx - 13, by + 5, 3, 1.5);
  ctx.fillStyle = '#2a3a2a'; ctx.fillRect(cx - 12.5, by + 5.2, 2, 1); // watch face
  ctx.fillStyle = '#4fc3f7'; ctx.fillRect(cx - 12, by + 5.5, 1, 0.3); // digital readout
  // Gloves (Mechanix M-Pact style)
  const gloveLGrad = ctx.createLinearGradient(cx - 13, by + 5, cx - 9, by + 8);
  gloveLGrad.addColorStop(0, '#2e2e22'); gloveLGrad.addColorStop(1, '#222218');
  ctx.fillStyle = gloveLGrad;
  ctx.fillRect(cx - 13, by + 6, 4, 2.5);
  ctx.fillRect(cx + 9, by + 6, 4, 2.5);
  // Glove TPR knuckle guard
  ctx.fillStyle = '#3a3a30'; ctx.fillRect(cx - 12, by + 6, 2.5, 1); ctx.fillRect(cx + 10, by + 6, 2.5, 1);
  // Finger detail
  ctx.fillStyle = '#2a2a20';
  ctx.fillRect(cx - 13, by + 7.5, 1, 1); ctx.fillRect(cx - 11.5, by + 7.5, 1, 1); ctx.fillRect(cx - 10, by + 7.5, 1, 1);
  ctx.fillRect(cx + 9, by + 7.5, 1, 1); ctx.fillRect(cx + 10.5, by + 7.5, 1, 1); ctx.fillRect(cx + 12, by + 7.5, 1, 1);

  // M249 SAW machine gun (enhanced detail)
  // Collapsible stock (right side)
  const stockGrad = ctx.createLinearGradient(cx + 12, by - 2, cx + 20, by + 3);
  stockGrad.addColorStop(0, '#3e3e34'); stockGrad.addColorStop(0.5, '#343430'); stockGrad.addColorStop(1, '#2a2a24');
  ctx.fillStyle = stockGrad;
  ctx.beginPath(); ctx.moveTo(cx + 12, by - 2); ctx.lineTo(cx + 19, by - 1); ctx.lineTo(cx + 20, by + 2);
  ctx.lineTo(cx + 17, by + 3); ctx.lineTo(cx + 12, by + 2); ctx.closePath(); ctx.fill();
  // Stock buffer tube
  ctx.fillStyle = '#3a3a34'; ctx.fillRect(cx + 10, by - 1, 3, 2);
  // Butt pad (rubber)
  ctx.fillStyle = '#222220'; ctx.fillRect(cx + 17, by, 2, 2);
  ctx.fillStyle = 'rgba(255,255,255,0.04)'; ctx.fillRect(cx + 13, by - 1, 4, 0.8);
  // Receiver body (FN machined, two-tone)
  const rcvGrad = ctx.createLinearGradient(cx + 2, by - 4, cx + 12, by + 2);
  rcvGrad.addColorStop(0, '#4a4a4a'); rcvGrad.addColorStop(0.3, '#3e3e3e'); rcvGrad.addColorStop(0.7, '#333'); rcvGrad.addColorStop(1, '#2a2a2a');
  ctx.fillStyle = rcvGrad;
  ctx.fillRect(cx + 2, by - 4, 10, 5);
  // Ejection port cover
  ctx.fillStyle = '#555'; ctx.fillRect(cx + 6, by - 3.5, 3, 1.5);
  ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(cx + 6.5, by - 3.5, 2, 0.5);
  // Feed tray cover (hinged, ribbed)
  ctx.fillStyle = '#4e4e4e'; ctx.fillRect(cx + 3, by - 5, 8, 1.5);
  ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 0.3;
  for (let ft = 0; ft < 4; ft++) ctx.fillRect(cx + 4 + ft * 1.8, by - 5, 0.3, 1.5);
  ctx.fillStyle = 'rgba(255,255,255,0.1)'; ctx.fillRect(cx + 4, by - 5, 6, 0.5);
  // Barrel with heat shield (perforated)
  const barrelGrad = ctx.createLinearGradient(cx - 14, by - 3, cx + 2, by - 1);
  barrelGrad.addColorStop(0, '#444'); barrelGrad.addColorStop(0.5, '#3a3a3a'); barrelGrad.addColorStop(1, '#333');
  ctx.fillStyle = barrelGrad;
  ctx.fillRect(cx - 14, by - 4, 16, 3);
  // Heat shield ventilation holes (round)
  for (let h = 0; h < 6; h++) {
    ctx.fillStyle = '#2a2a2a';
    ctx.beginPath(); ctx.arc(cx - 12 + h * 2.5, by - 2.5, 0.6, 0, Math.PI * 2); ctx.fill();
  }
  // Barrel tip / flash hider (A2 birdcage)
  ctx.fillStyle = '#505050'; ctx.fillRect(cx - 18, by - 4, 4, 3);
  const fhGrad = ctx.createLinearGradient(cx - 20, by - 4.5, cx - 18, by - 1);
  fhGrad.addColorStop(0, '#5a5a5a'); fhGrad.addColorStop(0.5, '#4a4a4a'); fhGrad.addColorStop(1, '#3a3a3a');
  ctx.fillStyle = fhGrad;
  ctx.fillRect(cx - 20, by - 4.5, 2.5, 4);
  // Flash hider slots
  ctx.fillStyle = '#2a2a2a';
  for (let s = 0; s < 3; s++) ctx.fillRect(cx - 20, by - 3.5 + s * 1, 1.5, 0.4);
  // Gas regulator
  ctx.fillStyle = '#4a4a4a'; ctx.fillRect(cx - 5, by - 5, 2.5, 2);
  ctx.fillStyle = '#555'; ctx.beginPath(); ctx.arc(cx - 4, by - 4, 0.8, 0, Math.PI * 2); ctx.fill();
  // 200-round soft pouch / nutsack
  ctx.fillStyle = '#3a3a2a'; ctx.fillRect(cx + 2, by + 1, 6, 7);
  ctx.fillStyle = '#2e2e22'; ctx.fillRect(cx + 3, by + 2, 4, 5);
  // Pouch fabric texture
  ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 0.3;
  ctx.beginPath(); ctx.moveTo(cx + 3, by + 3); ctx.lineTo(cx + 7, by + 3); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 3, by + 5); ctx.lineTo(cx + 7, by + 5); ctx.stroke();
  // Ammo belt feed (brass links visible)
  ctx.fillStyle = '#a89840';
  ctx.fillRect(cx + 3, by + 1, 1.2, 0.8); ctx.fillRect(cx + 5, by + 1, 1.2, 0.8); ctx.fillRect(cx + 7, by + 1, 1, 0.8);
  // Belt link detail
  ctx.fillStyle = '#8a7830';
  ctx.fillRect(cx + 3.5, by + 1, 0.5, 0.8); ctx.fillRect(cx + 5.5, by + 1, 0.5, 0.8);
  // Carrying handle (M249 specific)
  ctx.fillStyle = '#3e3e3e';
  ctx.beginPath(); ctx.moveTo(cx + 4, by - 6); ctx.quadraticCurveTo(cx + 7, by - 9, cx + 10, by - 6);
  ctx.lineTo(cx + 9.5, by - 5.5); ctx.quadraticCurveTo(cx + 7, by - 8, cx + 4.5, by - 5.5);
  ctx.closePath(); ctx.fill();
  // Optic (Elcan-style short sight)
  ctx.fillStyle = '#2a2a2e'; ctx.fillRect(cx + 5, by - 7, 4, 2);
  ctx.fillStyle = '#333338'; ctx.fillRect(cx + 5.5, by - 7, 3, 1.5);
  // Optic lens
  ctx.fillStyle = 'rgba(100,180,255,0.25)'; ctx.fillRect(cx + 5, by - 7, 0.8, 1.5);
  ctx.fillStyle = 'rgba(255,255,255,0.15)'; ctx.fillRect(cx + 5.2, by - 6.8, 0.3, 0.5);
  // Front sight post
  ctx.fillStyle = '#4a4a4a'; ctx.fillRect(cx - 12, by - 6, 1.5, 2.5);
  ctx.fillStyle = '#5a5a5a'; ctx.fillRect(cx - 12, by - 7, 1.5, 1.2);
  // Bipod (deployed position, angled)
  ctx.strokeStyle = '#4a4a4a'; ctx.lineWidth = 1.3;
  ctx.beginPath(); ctx.moveTo(cx - 8, by - 1); ctx.lineTo(cx - 11, by + 6); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx - 6, by - 1); ctx.lineTo(cx - 3, by + 6); ctx.stroke();
  // Bipod feet (rubber)
  ctx.fillStyle = '#333'; ctx.fillRect(cx - 12, by + 5, 2, 1.5); ctx.fillRect(cx - 4, by + 5, 2, 1.5);
  // Metallic barrel highlight
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.fillRect(cx - 16, by - 3.5, 12, 0.6);

  // Head with full detail
  // Neck (skin + comms wire)
  ctx.fillStyle = '#c8a882'; ctx.fillRect(cx - 2.5, by - 9, 5, 3.5);
  // Neck shadow
  ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(cx - 2, by - 7, 4, 1.5);
  // Comms earpiece wire
  ctx.strokeStyle = '#222'; ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.moveTo(cx + 2, by - 8); ctx.quadraticCurveTo(cx + 4, by - 6, cx + 3, by - 4); ctx.stroke();

  // Head shape (3D skin gradient)
  const headGrad = ctx.createRadialGradient(cx - 2, by - 15, 1, cx, by - 13, 7.5);
  headGrad.addColorStop(0, '#e8d0b0'); headGrad.addColorStop(0.6, '#d8b898'); headGrad.addColorStop(1, '#c0a080');
  ctx.fillStyle = headGrad;
  ctx.beginPath(); ctx.arc(cx, by - 13, 7, 0, Math.PI * 2); ctx.fill();
  // Jaw line (subtle definition)
  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  ctx.beginPath(); ctx.arc(cx, by - 11, 6, 0.3, Math.PI - 0.3); ctx.fill();
  // Ears
  ctx.fillStyle = '#d4b494';
  ctx.beginPath(); ctx.ellipse(cx + 6.5, by - 13, 1.5, 2.8, 0, 0, Math.PI * 2); ctx.fill();
  // Ear inner
  ctx.fillStyle = '#c8a882'; ctx.beginPath(); ctx.ellipse(cx + 6.5, by - 13, 0.8, 1.5, 0, 0, Math.PI * 2); ctx.fill();
  // Comms earpiece (Peltor)
  ctx.fillStyle = '#222'; ctx.beginPath(); ctx.ellipse(cx + 7, by - 13, 2, 2.5, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#333'; ctx.beginPath(); ctx.ellipse(cx + 7, by - 13, 1.2, 1.8, 0, 0, Math.PI * 2); ctx.fill();
  // Earpiece boom mic
  ctx.strokeStyle = '#222'; ctx.lineWidth = 0.6;
  ctx.beginPath(); ctx.moveTo(cx + 6, by - 11); ctx.quadraticCurveTo(cx + 3, by - 8, cx + 1, by - 8.5); ctx.stroke();
  ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(cx + 1, by - 8.5, 0.8, 0, Math.PI * 2); ctx.fill();

  // Face paint (MultiCam pattern - organic streaks)
  ctx.fillStyle = 'rgba(50,65,30,0.4)';
  ctx.save(); ctx.translate(cx, by - 13); ctx.rotate(-0.18);
  ctx.beginPath(); ctx.ellipse(-2, -2, 4, 1, 0.1, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(1, 2, 3.5, 1, -0.2, 0, Math.PI * 2); ctx.fill();
  ctx.restore();
  ctx.fillStyle = 'rgba(80,60,30,0.3)';
  ctx.save(); ctx.translate(cx, by - 13); ctx.rotate(0.1);
  ctx.beginPath(); ctx.ellipse(-3, 1, 3, 0.8, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(2, -1, 2, 0.8, 0.3, 0, Math.PI * 2); ctx.fill();
  ctx.restore();

  // Eyes (alert, focused, with eye light)
  ctx.fillStyle = '#f0f0e8'; ctx.fillRect(cx - 3.5, by - 14.5, 3, 2.2); ctx.fillRect(cx + 0.5, by - 14.5, 3, 2.2);
  // Iris (blue-grey)
  ctx.fillStyle = '#4a6a7a'; ctx.fillRect(cx - 3, by - 14, 2, 1.8); ctx.fillRect(cx + 1, by - 14, 2, 1.8);
  // Pupil
  ctx.fillStyle = '#111'; ctx.fillRect(cx - 2.5, by - 13.8, 1.2, 1.2); ctx.fillRect(cx + 1.5, by - 13.8, 1.2, 1.2);
  // Eye light (catchlight)
  ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.fillRect(cx - 2.8, by - 14, 0.5, 0.5); ctx.fillRect(cx + 1.2, by - 14, 0.5, 0.5);
  // Eyelids (upper)
  ctx.fillStyle = 'rgba(150,120,90,0.3)'; ctx.fillRect(cx - 3.5, by - 14.5, 3, 0.5); ctx.fillRect(cx + 0.5, by - 14.5, 3, 0.5);
  // Eyebrows (strong, slightly furrowed)
  ctx.fillStyle = 'rgba(50,35,20,0.55)';
  ctx.save(); ctx.translate(cx - 3.5, by - 15.5); ctx.rotate(0.08);
  ctx.fillRect(0, 0, 3.5, 0.9); ctx.restore();
  ctx.save(); ctx.translate(cx + 0.5, by - 15.8); ctx.rotate(-0.08);
  ctx.fillRect(0, 0, 3.5, 0.9); ctx.restore();
  // Nose (3D-ish with highlight)
  ctx.fillStyle = 'rgba(190,160,130,0.35)';
  ctx.beginPath(); ctx.moveTo(cx - 0.5, by - 13); ctx.lineTo(cx + 0.5, by - 11);
  ctx.lineTo(cx + 1.5, by - 10.5); ctx.lineTo(cx - 0.5, by - 10.5); ctx.closePath(); ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,0.08)'; ctx.fillRect(cx - 0.3, by - 12.5, 0.5, 1.5); // nose bridge highlight
  // Mouth
  ctx.fillStyle = 'rgba(160,110,90,0.35)'; ctx.fillRect(cx - 1.5, by - 9.5, 3, 0.8);
  ctx.fillStyle = 'rgba(130,80,60,0.2)'; ctx.fillRect(cx - 1, by - 9, 2, 0.3); // lower lip shadow
  // Chin
  ctx.fillStyle = 'rgba(0,0,0,0.04)'; ctx.fillRect(cx - 2, by - 8.5, 4, 1);
  // 5 o'clock shadow
  ctx.fillStyle = 'rgba(40,30,20,0.1)';
  ctx.fillRect(cx - 3, by - 10, 6, 2);

  // Military helmet (Ops-Core FAST style, MultiCam)
  const helmetGrad = ctx.createLinearGradient(cx - 9, by - 22, cx + 9, by - 15);
  helmetGrad.addColorStop(0, '#5e7050'); helmetGrad.addColorStop(0.3, '#566846'); helmetGrad.addColorStop(0.7, '#4a5a3a'); helmetGrad.addColorStop(1, '#3a4a2a');
  ctx.fillStyle = helmetGrad;
  ctx.beginPath(); ctx.arc(cx, by - 17, 9, Math.PI, 0); ctx.fill();
  ctx.fillRect(cx - 9, by - 18, 18, 4);
  // Helmet organic MultiCam blobs
  ctx.fillStyle = '#3a4a28';
  ctx.beginPath(); ctx.ellipse(cx - 4, by - 20, 3, 1.5, 0.2, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#5a6a48';
  ctx.beginPath(); ctx.ellipse(cx + 3, by - 19, 2.5, 1.5, -0.3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#2e3e1e';
  ctx.beginPath(); ctx.ellipse(cx, by - 18, 2, 1.2, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#7a886a';
  ctx.beginPath(); ctx.ellipse(cx - 2, by - 21, 2, 1, 0.4, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#4a3a28';
  ctx.beginPath(); ctx.ellipse(cx + 5, by - 18, 1.5, 1, -0.5, 0, Math.PI * 2); ctx.fill();
  // Helmet ear cuts (FAST style, reveals Peltor)
  ctx.fillStyle = '#1a1a18';
  ctx.beginPath(); ctx.arc(cx - 8, by - 15, 2.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 8, by - 15, 2.5, 0, Math.PI * 2); ctx.fill();
  // ARC rails (side accessory rails)
  ctx.fillStyle = '#3e3e34'; ctx.fillRect(cx - 9, by - 19, 2, 5); ctx.fillRect(cx + 7, by - 19, 2, 5);
  // Helmet rim with highlight
  ctx.fillStyle = '#3a4a2a'; ctx.fillRect(cx - 9, by - 15, 18, 1.5);
  ctx.fillStyle = 'rgba(255,255,255,0.08)'; ctx.fillRect(cx - 8, by - 15, 7, 0.6);
  // Chin strap (H-nape)
  ctx.fillStyle = '#353525'; ctx.fillRect(cx - 7, by - 14, 1.5, 3); ctx.fillRect(cx + 6, by - 14, 1.5, 3);
  ctx.fillStyle = '#444430'; ctx.fillRect(cx - 6, by - 11, 1.5, 1); ctx.fillRect(cx + 5, by - 11, 1.5, 1); // buckle
  // Wilcox L4G24 NVG mount (front, shrouded)
  ctx.fillStyle = '#2e2e24'; ctx.fillRect(cx - 3.5, by - 22, 7, 2.5);
  ctx.fillStyle = '#3a3a30'; ctx.fillRect(cx - 2.5, by - 21.5, 5, 1.5);
  // PVS-31 dual tube NVGs (flipped up)
  ctx.fillStyle = '#222220';
  ctx.fillRect(cx - 3.5, by - 25, 3, 3); ctx.fillRect(cx + 0.5, by - 25, 3, 3);
  // NVG objective lenses (green tint)
  ctx.fillStyle = 'rgba(100,200,100,0.25)';
  ctx.beginPath(); ctx.arc(cx - 2, by - 24, 1.2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 2, by - 24, 1.2, 0, Math.PI * 2); ctx.fill();
  // NVG housing detail
  ctx.fillStyle = '#2a2a28'; ctx.fillRect(cx - 3.5, by - 23, 7, 0.5);
  // NVG battery pack (rear of housing)
  ctx.fillStyle = '#1a1a18'; ctx.fillRect(cx - 3, by - 25, 1, 1); ctx.fillRect(cx + 2, by - 25, 1, 1);
  // Counterweight pouch (rear)
  ctx.fillStyle = '#3a3a2a'; ctx.fillRect(cx + 4, by - 21, 4, 2.5);
  ctx.strokeStyle = '#2a2a1a'; ctx.lineWidth = 0.3; ctx.strokeRect(cx + 4, by - 21, 4, 2.5);
  // Helmet-mounted light (Surefire HL1)
  ctx.fillStyle = '#3a3a3a'; ctx.fillRect(cx + 7, by - 18, 2.5, 1.5);
  ctx.fillStyle = '#4a4a4a'; ctx.fillRect(cx + 9, by - 18, 1, 1);
  // IR strobe (top of helmet)
  ctx.fillStyle = '#2a2a2a'; ctx.fillRect(cx - 1, by - 22.5, 2, 1);
  // Velcro patches
  // Blood type patch
  ctx.fillStyle = '#4a5a3a'; ctx.fillRect(cx - 7, by - 20, 3, 1.5);
  ctx.fillStyle = '#555'; ctx.font = '3px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('A+', cx - 5.5, by - 19);
  // Flag patch (US)
  ctx.fillStyle = 'rgba(60,70,60,0.4)'; ctx.fillRect(cx + 5, by - 20, 3, 2);
  ctx.fillStyle = 'rgba(90,90,80,0.3)'; ctx.fillRect(cx + 5, by - 20, 1.2, 0.8);

  // Player name floating above
  if (playerName) {
    ctx.font = 'bold 8px sans-serif'; ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.fillText(playerName, cx + 1, by - 27);
    ctx.fillStyle = '#e0f0ff'; ctx.fillText(playerName, cx, by - 28);
  }

  const pw = armyPower(player.army);
  drawLabel(cx, cy + 16, pw + (bon > 0 ? '+' + bon : ''), '#4fc3f7');
}

// ═══════════════════════════════════════════
//  DRAWING - ENEMIES (ISOMETRIC)
// ═══════════════════════════════════════════
function drawEnemy(e, sx, sy) {
  const def = ENEMY_TYPES[e.type];
  const cx = sx, cy = sy;
  const bob = Math.sin(animFrame * 0.12 + e.x * 3) * 1;

  // Danger glow for strong enemies
  const myPow = effectivePower(player.army, true, e.type);
  if (e.str > myPow * 0.8) {
    const dangerPulse = 0.1 + Math.sin(animFrame * 0.12 + e.x) * 0.06;
    const dGrad = ctx.createRadialGradient(cx, cy, 3, cx, cy, 28);
    dGrad.addColorStop(0, 'rgba(255,40,40,' + (dangerPulse + 0.04) + ')');
    dGrad.addColorStop(0.5, 'rgba(255,60,30,' + dangerPulse + ')');
    dGrad.addColorStop(1, 'rgba(200,30,30,0)');
    ctx.fillStyle = dGrad;
    ctx.fillRect(cx - 30, cy - 30, 60, 60);
  }

  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.beginPath(); ctx.ellipse(cx + 3, cy + 5, 10, 4, 0.2, 0, Math.PI * 2); ctx.fill();

  const by = cy - 10 + bob;

  switch (e.type) {
    case 'militant': drawMilitant(cx, by, def); break;
    case 'commando': drawCommando(cx, by, def); break;
    case 'sniper_e': drawSniperEnemy(cx, by, def); break;
    case 'apc': drawAPC(cx, by, def); break;
    case 'helicopter': drawHelicopter(cx, by, def); break;
    case 'mad_scientist': drawMadScientist(cx, by, def); break;
    case 'mutant': drawMutant(cx, by, def); break;
  }

  drawLabel(cx, cy + 14, e.str, def.color);
  ctx.fillStyle = def.color; ctx.font = '8px sans-serif'; ctx.textAlign = 'center';
  ctx.globalAlpha = 0.7; ctx.fillText(def.name, cx, cy + 24); ctx.globalAlpha = 1;
}

// ═══════════════════════════════════════════
//  DRAWING - ENEMIES
// ═══════════════════════════════════════════
function drawMilitant(cx, by, def) {
  // ── Detailed scruffy insurgent fighter with AK-47 ──

  // Combat boots (worn brown leather)
  const bootGrad = ctx.createLinearGradient(cx - 5, by + 9, cx + 4, by + 12);
  bootGrad.addColorStop(0, '#3e2a1a'); bootGrad.addColorStop(1, '#2a1a0a');
  ctx.fillStyle = bootGrad;
  ctx.fillRect(cx - 5, by + 9, 4, 3); ctx.fillRect(cx + 1, by + 9, 4, 3);
  // Boot soles
  ctx.fillStyle = '#1a1008'; ctx.fillRect(cx - 6, by + 11, 5, 1.5); ctx.fillRect(cx, by + 11, 5, 1.5);
  // Boot lacing
  ctx.strokeStyle = '#5a4a3a'; ctx.lineWidth = 0.4;
  for (let i = 0; i < 3; i++) {
    ctx.beginPath(); ctx.moveTo(cx - 4.5, by + 9.5 + i * 0.8); ctx.lineTo(cx - 2, by + 9.5 + i * 0.8); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx + 1.5, by + 9.5 + i * 0.8); ctx.lineTo(cx + 4, by + 9.5 + i * 0.8); ctx.stroke();
  }

  // Baggy pants (worn khaki/tan)
  const pantsGrad = ctx.createLinearGradient(cx - 5, by + 3, cx + 4, by + 9);
  pantsGrad.addColorStop(0, '#8a7a5a'); pantsGrad.addColorStop(0.5, '#7a6a4a'); pantsGrad.addColorStop(1, '#6a5a3a');
  ctx.fillStyle = pantsGrad;
  ctx.fillRect(cx - 5, by + 3, 4, 7); ctx.fillRect(cx + 1, by + 3, 4, 7);
  // Pant wrinkles
  ctx.fillStyle = 'rgba(0,0,0,0.12)';
  ctx.fillRect(cx - 4, by + 5, 3, 0.6); ctx.fillRect(cx + 2, by + 6, 3, 0.6);
  ctx.fillRect(cx - 4, by + 8, 3, 0.5); ctx.fillRect(cx + 2, by + 4, 3, 0.5);
  // Belt
  ctx.fillStyle = '#3a2a1a'; ctx.fillRect(cx - 5, by + 3, 10, 1.5);
  ctx.fillStyle = '#5a4a3a'; ctx.fillRect(cx - 1, by + 3, 2, 1.5); // buckle

  // Torso - loose fitting shirt/tunic
  const torsoGrad = ctx.createLinearGradient(cx - 7, by - 5, cx + 7, by + 4);
  torsoGrad.addColorStop(0, '#9a8a6a'); torsoGrad.addColorStop(0.4, def.color); torsoGrad.addColorStop(1, def.dark);
  ctx.fillStyle = torsoGrad;
  ctx.fillRect(cx - 7, by - 5, 14, 10);
  // Shirt folds/wrinkles
  ctx.fillStyle = 'rgba(0,0,0,0.08)';
  ctx.fillRect(cx - 5, by - 3, 1, 7); ctx.fillRect(cx + 3, by - 2, 1, 6);
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.fillRect(cx - 2, by - 4, 1, 8); ctx.fillRect(cx + 1, by - 3, 1, 7);

  // Chest rig / magazine vest (worn, scruffy)
  ctx.fillStyle = '#5d4037'; ctx.fillRect(cx - 6, by - 4, 12, 5);
  // Rig stitching
  ctx.strokeStyle = '#4a3020'; ctx.lineWidth = 0.5;
  ctx.strokeRect(cx - 5.5, by - 3.5, 11, 4);
  // Magazine pouches on chest rig
  ctx.fillStyle = '#4e342e';
  ctx.fillRect(cx - 5, by - 3, 3, 3); ctx.fillRect(cx - 1, by - 3, 3, 3); ctx.fillRect(cx + 3, by - 3, 3, 3);
  // AK mag tips peeking out
  ctx.fillStyle = '#3a3a38';
  ctx.fillRect(cx - 4.5, by - 3, 2, 1); ctx.fillRect(cx - 0.5, by - 3, 2, 1); ctx.fillRect(cx + 3.5, by - 3, 2, 1);

  // Arms (tan skin with rolled sleeves)
  const armGrad = ctx.createLinearGradient(cx - 11, by - 4, cx - 7, by + 4);
  armGrad.addColorStop(0, '#c8a070'); armGrad.addColorStop(1, '#a08060');
  ctx.fillStyle = armGrad;
  ctx.fillRect(cx - 11, by - 3, 4, 8); ctx.fillRect(cx + 7, by - 3, 4, 8);
  // Rolled sleeve cuffs
  ctx.fillStyle = def.color;
  ctx.fillRect(cx - 11, by - 4, 4, 2); ctx.fillRect(cx + 7, by - 4, 4, 2);
  // Hands
  ctx.fillStyle = '#c8a070';
  ctx.fillRect(cx - 11, by + 4, 3, 2); ctx.fillRect(cx + 8, by + 4, 3, 2);

  // AK-47 rifle (detailed)
  // Wooden stock (orange-brown wood grain)
  const stockGrad = ctx.createLinearGradient(cx + 6, by - 6, cx + 14, by - 3);
  stockGrad.addColorStop(0, '#6d4c2a'); stockGrad.addColorStop(0.5, '#7d5c3a'); stockGrad.addColorStop(1, '#5d3c1a');
  ctx.fillStyle = stockGrad;
  ctx.fillRect(cx + 6, by - 6, 8, 3);
  // Wood grain lines
  ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 0.3;
  ctx.beginPath(); ctx.moveTo(cx + 7, by - 5.5); ctx.lineTo(cx + 13, by - 5); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 7, by - 4.5); ctx.lineTo(cx + 13, by - 4); ctx.stroke();
  // Receiver (dark metal with gradient)
  const rcvGrad = ctx.createLinearGradient(cx + 10, by - 8, cx + 16, by - 5);
  rcvGrad.addColorStop(0, '#2a2a2a'); rcvGrad.addColorStop(0.5, '#3a3a3a'); rcvGrad.addColorStop(1, '#252525');
  ctx.fillStyle = rcvGrad;
  ctx.fillRect(cx + 10, by - 8, 8, 3);
  // Dust cover
  ctx.fillStyle = 'rgba(255,255,255,0.08)'; ctx.fillRect(cx + 11, by - 8, 6, 0.8);
  // Gas tube above barrel
  ctx.fillStyle = '#4a4a4a'; ctx.fillRect(cx + 16, by - 8, 6, 1.5);
  // Barrel
  ctx.fillStyle = '#333'; ctx.fillRect(cx + 18, by - 7, 6, 1.5);
  // Muzzle brake
  ctx.fillStyle = '#2a2a2a'; ctx.fillRect(cx + 23, by - 7.5, 2, 2);
  ctx.fillStyle = '#222'; ctx.fillRect(cx + 24, by - 7, 0.5, 1);
  // Banana magazine (curved)
  ctx.fillStyle = '#3a3a38';
  ctx.save(); ctx.translate(cx + 14, by - 5); ctx.rotate(0.1);
  ctx.fillRect(0, 0, 2.5, 5);
  ctx.fillStyle = '#2a2a28'; ctx.fillRect(0, 0, 2.5, 1); // mag top
  ctx.restore();
  // Front sight post
  ctx.fillStyle = '#444'; ctx.fillRect(cx + 21, by - 9, 1, 2);
  // Rear sight
  ctx.fillStyle = '#444'; ctx.fillRect(cx + 12, by - 9, 1.5, 1);

  // Head
  // Neck
  ctx.fillStyle = '#c8a070'; ctx.fillRect(cx - 2, by - 8, 4, 3);
  // Head shape with skin gradient
  const headGrad = ctx.createRadialGradient(cx - 1, by - 13, 1, cx, by - 11, 6.5);
  headGrad.addColorStop(0, '#d8b890'); headGrad.addColorStop(1, '#b89070');
  ctx.fillStyle = headGrad;
  ctx.beginPath(); ctx.arc(cx, by - 11, 6, 0, Math.PI * 2); ctx.fill();
  // Ear
  ctx.fillStyle = '#c8a878'; ctx.beginPath(); ctx.ellipse(cx + 5.5, by - 11, 1.5, 2.5, 0, 0, Math.PI * 2); ctx.fill();
  // Stubble/beard shadow
  ctx.fillStyle = 'rgba(40,30,20,0.2)';
  ctx.beginPath(); ctx.arc(cx, by - 8, 4, 0, Math.PI); ctx.fill();
  // Eyes
  ctx.fillStyle = '#e8e8d8'; ctx.fillRect(cx - 3, by - 12.5, 2.5, 2); ctx.fillRect(cx + 0.5, by - 12.5, 2.5, 2);
  ctx.fillStyle = '#2a1a0a'; ctx.fillRect(cx - 2.5, by - 12, 1.5, 1.5); ctx.fillRect(cx + 1, by - 12, 1.5, 1.5);
  ctx.fillStyle = '#111'; ctx.fillRect(cx - 2, by - 12, 1, 1); ctx.fillRect(cx + 1.5, by - 12, 1, 1);
  // Angry eyebrows (angled)
  ctx.fillStyle = 'rgba(40,30,20,0.6)';
  ctx.save(); ctx.translate(cx - 3, by - 13.5); ctx.rotate(0.15);
  ctx.fillRect(0, 0, 3, 0.8); ctx.restore();
  ctx.save(); ctx.translate(cx + 0.5, by - 14); ctx.rotate(-0.15);
  ctx.fillRect(0, 0, 3, 0.8); ctx.restore();
  // Nose
  ctx.fillStyle = 'rgba(180,140,110,0.4)'; ctx.fillRect(cx - 0.5, by - 11, 1.5, 2);
  // Scowling mouth
  ctx.fillStyle = 'rgba(100,50,30,0.4)'; ctx.fillRect(cx - 1.5, by - 8.5, 3, 0.7);

  // Headwrap / keffiyeh (layered cloth)
  const wrapGrad = ctx.createLinearGradient(cx - 8, by - 17, cx + 8, by - 12);
  wrapGrad.addColorStop(0, def.dark); wrapGrad.addColorStop(0.5, def.color); wrapGrad.addColorStop(1, def.dark);
  ctx.fillStyle = wrapGrad;
  ctx.beginPath(); ctx.arc(cx, by - 15, 7, Math.PI, 0); ctx.fill();
  ctx.fillRect(cx - 7, by - 16, 14, 4);
  // Wrap cloth texture lines
  ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 0.4;
  for (let i = 0; i < 4; i++) {
    ctx.beginPath(); ctx.moveTo(cx - 6, by - 16 + i * 1.2); ctx.lineTo(cx + 6, by - 16 + i * 1.2); ctx.stroke();
  }
  // Cloth draping down (tail end)
  ctx.fillStyle = def.color;
  ctx.beginPath(); ctx.moveTo(cx + 5, by - 13); ctx.lineTo(cx + 8, by - 10);
  ctx.lineTo(cx + 6, by - 6); ctx.lineTo(cx + 4, by - 6); ctx.lineTo(cx + 6, by - 10);
  ctx.lineTo(cx + 4, by - 13); ctx.closePath(); ctx.fill();
  ctx.fillStyle = 'rgba(0,0,0,0.1)';
  ctx.fillRect(cx + 4, by - 12, 3, 1);
}

function drawCommando(cx, by, def) {
  // ── Elite tactical operator with suppressed weapon & NVGs ──

  // Tactical boots (black, polished)
  const bootGrad = ctx.createLinearGradient(cx - 6, by + 9, cx + 5, by + 12);
  bootGrad.addColorStop(0, '#1a1a1a'); bootGrad.addColorStop(1, '#0a0a0a');
  ctx.fillStyle = bootGrad;
  ctx.fillRect(cx - 6, by + 9, 5, 3); ctx.fillRect(cx + 1, by + 9, 5, 3);
  // Boot soles (rubber tread)
  ctx.fillStyle = '#050505'; ctx.fillRect(cx - 7, by + 11, 6, 1.5); ctx.fillRect(cx, by + 11, 6, 1.5);
  // Boot zippers
  ctx.strokeStyle = '#3a3a3a'; ctx.lineWidth = 0.4;
  ctx.beginPath(); ctx.moveTo(cx - 4, by + 9); ctx.lineTo(cx - 4, by + 11); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 3, by + 9); ctx.lineTo(cx + 3, by + 11); ctx.stroke();

  // BDU tactical pants (dark grey/charcoal)
  const pantsGrad = ctx.createLinearGradient(cx - 6, by + 3, cx + 5, by + 10);
  pantsGrad.addColorStop(0, '#3a3a40'); pantsGrad.addColorStop(0.5, '#32323a'); pantsGrad.addColorStop(1, '#2a2a30');
  ctx.fillStyle = pantsGrad;
  ctx.fillRect(cx - 6, by + 3, 5, 7); ctx.fillRect(cx + 1, by + 3, 5, 7);
  // Knee pads (integral)
  ctx.fillStyle = '#222228'; ctx.fillRect(cx - 5, by + 6, 4, 2.5); ctx.fillRect(cx + 2, by + 6, 4, 2.5);
  ctx.fillStyle = 'rgba(255,255,255,0.04)'; ctx.fillRect(cx - 4.5, by + 6, 3, 0.5); ctx.fillRect(cx + 2.5, by + 6, 3, 0.5);
  // Cargo pockets
  ctx.fillStyle = '#2e2e36'; ctx.fillRect(cx - 5, by + 4, 3, 2); ctx.fillRect(cx + 3, by + 4, 3, 2);
  // Belt with pistol holster
  ctx.fillStyle = '#1a1a20'; ctx.fillRect(cx - 6, by + 3, 12, 1.5);
  ctx.fillStyle = '#222'; ctx.fillRect(cx + 4, by + 2, 2.5, 3); // drop leg holster
  ctx.fillStyle = '#333'; ctx.fillRect(cx + 4.5, by + 2, 1.5, 2); // pistol grip peek

  // Torso - combat shirt (dark tactical)
  const torsoGrad = ctx.createLinearGradient(cx - 7, by - 6, cx + 7, by + 4);
  torsoGrad.addColorStop(0, '#404048'); torsoGrad.addColorStop(0.4, def.color); torsoGrad.addColorStop(1, def.dark);
  ctx.fillStyle = torsoGrad;
  ctx.fillRect(cx - 7, by - 6, 14, 11);
  // Shirt seam lines
  ctx.fillStyle = 'rgba(0,0,0,0.1)';
  ctx.fillRect(cx, by - 5, 0.5, 9);

  // Plate carrier (tactical, dark)
  const vestGrad = ctx.createLinearGradient(cx - 6, by - 5, cx + 6, by + 1);
  vestGrad.addColorStop(0, '#2a2e32'); vestGrad.addColorStop(0.5, '#37474f'); vestGrad.addColorStop(1, '#2a2e32');
  ctx.fillStyle = vestGrad;
  ctx.fillRect(cx - 6, by - 5, 12, 7);
  // MOLLE webbing (horizontal straps)
  ctx.strokeStyle = 'rgba(60,70,80,0.6)'; ctx.lineWidth = 0.5;
  for (let i = 0; i < 4; i++) {
    ctx.beginPath(); ctx.moveTo(cx - 5.5, by - 4 + i * 1.5); ctx.lineTo(cx + 5.5, by - 4 + i * 1.5); ctx.stroke();
  }
  // Triple mag pouches
  ctx.fillStyle = '#2a3038';
  ctx.fillRect(cx - 5, by - 4, 3, 3); ctx.fillRect(cx - 1, by - 4, 3, 3); ctx.fillRect(cx + 3, by - 4, 3, 3);
  // Mag tops (dark)
  ctx.fillStyle = '#1a1a22';
  ctx.fillRect(cx - 4.5, by - 4, 2, 0.8); ctx.fillRect(cx - 0.5, by - 4, 2, 0.8); ctx.fillRect(cx + 3.5, by - 4, 2, 0.8);
  // Radio pouch on shoulder
  ctx.fillStyle = '#2a2e32'; ctx.fillRect(cx - 7, by - 5, 2, 3);
  ctx.fillStyle = '#333'; ctx.fillRect(cx - 6.5, by - 4.5, 1, 2); // radio
  // IR patch (reflective)
  ctx.fillStyle = 'rgba(100,120,100,0.3)'; ctx.fillRect(cx + 4, by - 5, 2, 1.5);
  // Shoulder straps
  ctx.fillStyle = '#2a2e32';
  ctx.beginPath(); ctx.moveTo(cx - 5, by - 5); ctx.lineTo(cx - 7, by - 6); ctx.lineTo(cx - 6, by - 6); ctx.lineTo(cx - 4, by - 5); ctx.fill();
  ctx.beginPath(); ctx.moveTo(cx + 5, by - 5); ctx.lineTo(cx + 7, by - 6); ctx.lineTo(cx + 6, by - 6); ctx.lineTo(cx + 4, by - 5); ctx.fill();

  // Arms (dark sleeves, gloved hands)
  const armGrad = ctx.createLinearGradient(cx - 12, by - 4, cx - 7, by + 5);
  armGrad.addColorStop(0, '#3a3a42'); armGrad.addColorStop(1, '#2a2a32');
  ctx.fillStyle = armGrad;
  ctx.fillRect(cx - 12, by - 4, 5, 9); ctx.fillRect(cx + 7, by - 4, 5, 9);
  // Elbow pads
  ctx.fillStyle = '#222228'; ctx.fillRect(cx - 11, by, 3, 2); ctx.fillRect(cx + 8, by, 3, 2);
  // Tactical gloves (black)
  ctx.fillStyle = '#1a1a1a'; ctx.fillRect(cx - 12, by + 4, 4, 2); ctx.fillRect(cx + 8, by + 4, 4, 2);
  // Glove knuckle detail
  ctx.fillStyle = 'rgba(50,50,50,0.5)';
  ctx.fillRect(cx - 11, by + 4, 2, 0.5); ctx.fillRect(cx + 9, by + 4, 2, 0.5);

  // Suppressed M4A1 / HK416 style weapon
  // Collapsible stock
  ctx.fillStyle = '#222';
  ctx.fillRect(cx + 7, by - 5, 5, 2.5);
  ctx.fillStyle = '#2a2a2a'; ctx.fillRect(cx + 7, by - 4, 2, 1.5); // stock pad
  // Buffer tube
  ctx.fillStyle = '#333'; ctx.fillRect(cx + 9, by - 5, 4, 1.5);
  // Upper receiver (machined aluminum)
  const rcvGrad = ctx.createLinearGradient(cx + 10, by - 7, cx + 18, by - 4);
  rcvGrad.addColorStop(0, '#2a2a2a'); rcvGrad.addColorStop(0.5, '#3a3a3a'); rcvGrad.addColorStop(1, '#252525');
  ctx.fillStyle = rcvGrad;
  ctx.fillRect(cx + 11, by - 7, 7, 2.5);
  // Picatinny rail on top
  ctx.fillStyle = '#3a3a3a';
  for (let i = 0; i < 5; i++) ctx.fillRect(cx + 11.5 + i * 1.2, by - 7.5, 0.8, 0.5);
  // Handguard (free float)
  ctx.fillStyle = '#2e2e2e'; ctx.fillRect(cx + 17, by - 7, 6, 2.5);
  // Barrel (threaded)
  ctx.fillStyle = '#333'; ctx.fillRect(cx + 22, by - 6.5, 3, 1.5);
  // Suppressor (cylindrical, long)
  const supGrad = ctx.createLinearGradient(cx + 24, by - 7, cx + 32, by - 5);
  supGrad.addColorStop(0, '#3a3a3a'); supGrad.addColorStop(0.3, '#555'); supGrad.addColorStop(0.7, '#444'); supGrad.addColorStop(1, '#333');
  ctx.fillStyle = supGrad;
  ctx.fillRect(cx + 24, by - 7, 8, 2.5);
  // Suppressor baffles (rings)
  ctx.strokeStyle = 'rgba(80,80,80,0.4)'; ctx.lineWidth = 0.3;
  for (let i = 0; i < 4; i++) {
    ctx.beginPath(); ctx.moveTo(cx + 25.5 + i * 1.5, by - 7); ctx.lineTo(cx + 25.5 + i * 1.5, by - 4.5); ctx.stroke();
  }
  // Pistol grip
  ctx.fillStyle = '#1a1a1a'; ctx.fillRect(cx + 12, by - 5, 2.5, 4);
  // STANAG magazine
  ctx.fillStyle = '#333';
  ctx.fillRect(cx + 14, by - 5, 2, 4);
  ctx.fillStyle = '#2a2a2a'; ctx.fillRect(cx + 14, by - 5, 2, 0.8);
  // PEQ-15 laser unit on rail
  ctx.fillStyle = '#2a2a22'; ctx.fillRect(cx + 17, by - 8.5, 3, 1.5);
  ctx.fillStyle = '#3a3a2a'; ctx.fillRect(cx + 17.5, by - 8.5, 0.5, 0.5);
  // Foregrip
  ctx.fillStyle = '#222'; ctx.fillRect(cx + 19, by - 5, 1.5, 2.5);

  // Head
  // Neck (balaclava-covered)
  ctx.fillStyle = '#1a1a20'; ctx.fillRect(cx - 2, by - 8, 4, 3);
  // Head shape (balaclava)
  const headGrad = ctx.createRadialGradient(cx - 1, by - 13, 1, cx, by - 11, 6.5);
  headGrad.addColorStop(0, '#2a2a30'); headGrad.addColorStop(1, '#1a1a20');
  ctx.fillStyle = headGrad;
  ctx.beginPath(); ctx.arc(cx, by - 11, 6, 0, Math.PI * 2); ctx.fill();
  // Eye cutout (skin showing)
  ctx.fillStyle = '#c8a882'; ctx.fillRect(cx - 4, by - 13, 8, 2.5);
  // Eyes (intense stare)
  ctx.fillStyle = '#e8e8e0'; ctx.fillRect(cx - 3, by - 12.5, 2.5, 2); ctx.fillRect(cx + 0.5, by - 12.5, 2.5, 2);
  ctx.fillStyle = '#2a4a2a'; ctx.fillRect(cx - 2.5, by - 12, 1.5, 1.5); ctx.fillRect(cx + 1, by - 12, 1.5, 1.5);
  ctx.fillStyle = '#111'; ctx.fillRect(cx - 2, by - 12, 1, 1); ctx.fillRect(cx + 1.5, by - 12, 1, 1);
  // Eyebrow ridges (through balaclava)
  ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(cx - 3.5, by - 13.5, 3, 0.7); ctx.fillRect(cx + 0.5, by - 13.5, 3, 0.7);

  // Ops-Core FAST helmet (dark)
  const helmetGrad = ctx.createLinearGradient(cx - 8, by - 20, cx + 8, by - 14);
  helmetGrad.addColorStop(0, '#2a2a2e'); helmetGrad.addColorStop(0.5, '#333338'); helmetGrad.addColorStop(1, '#22222a');
  ctx.fillStyle = helmetGrad;
  ctx.beginPath(); ctx.arc(cx, by - 16, 8, Math.PI, 0); ctx.fill();
  ctx.fillRect(cx - 8, by - 17, 16, 4);
  // Helmet ear cutouts (FAST style)
  ctx.fillStyle = '#1a1a20'; ctx.beginPath(); ctx.arc(cx - 7, by - 14, 2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 7, by - 14, 2, 0, Math.PI * 2); ctx.fill();
  // Helmet rim
  ctx.fillStyle = '#252528'; ctx.fillRect(cx - 8, by - 14, 16, 1.2);
  ctx.fillStyle = 'rgba(255,255,255,0.05)'; ctx.fillRect(cx - 7, by - 14, 6, 0.5);
  // ARC rails (side rails on helmet)
  ctx.fillStyle = '#3a3a3e'; ctx.fillRect(cx - 8, by - 17, 1.5, 4); ctx.fillRect(cx + 7, by - 17, 1.5, 4);
  // Counterweight pouch (rear)
  ctx.fillStyle = '#2a2a2e'; ctx.fillRect(cx + 3, by - 19, 4, 2);
  // Velcro patch (IR flag)
  ctx.fillStyle = 'rgba(60,70,60,0.4)'; ctx.fillRect(cx - 3, by - 19, 3, 1.5);

  // NVG mount (rhino arm style)
  ctx.fillStyle = '#2a2a22';
  ctx.fillRect(cx - 2, by - 20, 4, 1.5); // mount base
  // Articulating arm
  ctx.fillStyle = '#333';
  ctx.beginPath(); ctx.moveTo(cx, by - 20); ctx.lineTo(cx - 1, by - 22); ctx.lineTo(cx + 1, by - 22); ctx.closePath(); ctx.fill();
  // PVS-31 dual tube NVGs (flipped up)
  ctx.fillStyle = '#1a1a18';
  ctx.fillRect(cx - 3, by - 24, 2.5, 2.5); ctx.fillRect(cx + 0.5, by - 24, 2.5, 2.5);
  // NVG lens glow (green, eerie)
  ctx.fillStyle = '#76ff03'; ctx.shadowColor = '#76ff03'; ctx.shadowBlur = 5;
  ctx.beginPath(); ctx.arc(cx - 1.75, by - 23, 0.8, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 1.75, by - 23, 0.8, 0, Math.PI * 2); ctx.fill();
  ctx.shadowBlur = 0;
  // NVG housing detail
  ctx.fillStyle = '#222'; ctx.fillRect(cx - 3, by - 22, 6, 0.5);
  // Helmet-mounted light (Princeton Tec)
  ctx.fillStyle = '#3a3a3a'; ctx.fillRect(cx + 6, by - 17, 2, 1.5);
  ctx.fillStyle = '#4a4a4a'; ctx.fillRect(cx + 7.5, by - 17, 0.8, 1);
}

function drawSniperEnemy(cx, by, def) {
  // ── Ghillie-suited sniper with precision rifle ──

  // Boots (muddy, worn)
  const bootGrad = ctx.createLinearGradient(cx - 5, by + 9, cx + 4, by + 12);
  bootGrad.addColorStop(0, '#2a2418'); bootGrad.addColorStop(1, '#1a1408');
  ctx.fillStyle = bootGrad;
  ctx.fillRect(cx - 5, by + 9, 4, 3); ctx.fillRect(cx + 1, by + 9, 4, 3);
  // Boot soles
  ctx.fillStyle = '#0a0a06'; ctx.fillRect(cx - 6, by + 11, 5, 1.5); ctx.fillRect(cx, by + 11, 5, 1.5);
  // Mud stains
  ctx.fillStyle = 'rgba(80,60,30,0.4)'; ctx.fillRect(cx - 5, by + 10, 3, 1); ctx.fillRect(cx + 2, by + 10, 3, 1);

  // Pants (dark woodland, low profile)
  const pantsGrad = ctx.createLinearGradient(cx - 5, by + 3, cx + 4, by + 10);
  pantsGrad.addColorStop(0, '#2a3a28'); pantsGrad.addColorStop(0.5, '#1e2e1c'); pantsGrad.addColorStop(1, '#182818');
  ctx.fillStyle = pantsGrad;
  ctx.fillRect(cx - 5, by + 3, 4, 7); ctx.fillRect(cx + 1, by + 3, 4, 7);
  // Knee pads (padded, low vis)
  ctx.fillStyle = '#1a2a18'; ctx.fillRect(cx - 4, by + 6, 3, 2); ctx.fillRect(cx + 2, by + 6, 3, 2);
  // Belt
  ctx.fillStyle = '#1a1a14'; ctx.fillRect(cx - 5, by + 3, 10, 1.5);

  // Torso (base, then ghillie on top)
  const torsoGrad = ctx.createLinearGradient(cx - 7, by - 4, cx + 6, by + 4);
  torsoGrad.addColorStop(0, '#2a3a28'); torsoGrad.addColorStop(0.5, def.color); torsoGrad.addColorStop(1, def.dark);
  ctx.fillStyle = torsoGrad;
  ctx.fillRect(cx - 7, by - 4, 14, 9);

  // Ghillie suit overlay - layered burlap/jute strips
  // Base layer frayed strips
  ctx.fillStyle = '#3a4a30';
  for (let i = 0; i < 6; i++) {
    const sx = cx - 8 + i * 3; const sy = by - 3 + Math.sin(i * 1.7) * 1;
    ctx.fillRect(sx, sy, 2.5, 5 + Math.sin(i * 2.3) * 2);
  }
  // Mid layer organic strips (different greens/browns)
  ctx.fillStyle = '#4a5a38';
  ctx.beginPath(); ctx.ellipse(cx - 4, by - 2, 3, 2, 0.4, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx + 3, by + 1, 2.5, 2, -0.2, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#5a6240';
  ctx.beginPath(); ctx.ellipse(cx - 1, by, 2, 1.5, 0.6, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx + 1, by + 3, 2, 1.5, -0.5, 0, Math.PI * 2); ctx.fill();
  // Dark brown earth-tone strips
  ctx.fillStyle = '#3a3020';
  ctx.beginPath(); ctx.ellipse(cx - 5, by + 2, 2, 1.5, 0.2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx + 5, by - 1, 1.5, 2, -0.3, 0, Math.PI * 2); ctx.fill();
  // Dangling jute strands
  ctx.strokeStyle = '#4a5a30'; ctx.lineWidth = 0.8;
  for (let i = 0; i < 5; i++) {
    const sx = cx - 6 + i * 3;
    const wave = Math.sin(animFrame * 0.04 + i * 1.5) * 1;
    ctx.beginPath(); ctx.moveTo(sx, by + 4); ctx.lineTo(sx + wave, by + 7 + i % 2); ctx.stroke();
  }
  // Leaf/twig debris
  ctx.fillStyle = '#6a7a48';
  ctx.fillRect(cx - 3, by - 4, 1.5, 1); ctx.fillRect(cx + 2, by - 3, 1, 1.5);
  ctx.fillStyle = '#4a3a1a'; ctx.fillRect(cx + 4, by - 2, 1.5, 0.5); // twig

  // Arms with ghillie strips
  ctx.fillStyle = def.dark;
  ctx.fillRect(cx - 10, by - 2, 4, 7); ctx.fillRect(cx + 6, by - 2, 4, 7);
  // Arm ghillie strips
  ctx.fillStyle = '#3a4a28';
  ctx.fillRect(cx - 11, by - 1, 2, 3); ctx.fillRect(cx - 9, by + 2, 2, 2);
  ctx.fillRect(cx + 7, by, 2, 3); ctx.fillRect(cx + 8, by + 3, 2, 2);
  ctx.fillStyle = '#5a6a40';
  ctx.fillRect(cx - 10, by + 1, 1.5, 2); ctx.fillRect(cx + 7, by - 1, 1.5, 2);
  // Hands (shooting gloves)
  ctx.fillStyle = '#2a2a1a'; ctx.fillRect(cx - 10, by + 4, 3, 2); ctx.fillRect(cx + 7, by + 4, 3, 2);

  // Sniper rifle (M40/Remington 700 style bolt-action)
  // Wooden stock (walnut)
  const stockGrad = ctx.createLinearGradient(cx + 5, by - 5, cx + 13, by - 2);
  stockGrad.addColorStop(0, '#5a3820'); stockGrad.addColorStop(0.5, '#6a4830'); stockGrad.addColorStop(1, '#4a2818');
  ctx.fillStyle = stockGrad;
  ctx.fillRect(cx + 5, by - 5, 7, 3);
  // Stock cheek rest
  ctx.fillStyle = '#5a3820'; ctx.fillRect(cx + 6, by - 6, 4, 1.5);
  // Wood grain
  ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 0.3;
  ctx.beginPath(); ctx.moveTo(cx + 6, by - 4.5); ctx.lineTo(cx + 11, by - 4); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 6, by - 3.5); ctx.lineTo(cx + 11, by - 3); ctx.stroke();
  // Action/receiver (blued steel)
  const actionGrad = ctx.createLinearGradient(cx + 10, by - 6, cx + 16, by - 3);
  actionGrad.addColorStop(0, '#2a2a30'); actionGrad.addColorStop(0.5, '#3a3a42'); actionGrad.addColorStop(1, '#222228');
  ctx.fillStyle = actionGrad;
  ctx.fillRect(cx + 10, by - 6, 6, 3);
  // Bolt handle
  ctx.fillStyle = '#4a4a50'; ctx.fillRect(cx + 13, by - 7, 1.5, 1.5);
  ctx.beginPath(); ctx.arc(cx + 14, by - 7, 0.8, 0, Math.PI * 2); ctx.fill();
  // Heavy barrel (free-floated, bull barrel)
  const barrelGrad = ctx.createLinearGradient(cx + 14, by - 6, cx + 28, by - 4);
  barrelGrad.addColorStop(0, '#333338'); barrelGrad.addColorStop(0.5, '#444448'); barrelGrad.addColorStop(1, '#2a2a30');
  ctx.fillStyle = barrelGrad;
  ctx.fillRect(cx + 14, by - 6, 14, 2);
  // Barrel highlight
  ctx.fillStyle = 'rgba(255,255,255,0.08)'; ctx.fillRect(cx + 15, by - 6, 12, 0.5);
  // Muzzle brake
  ctx.fillStyle = '#222'; ctx.fillRect(cx + 27, by - 6.5, 2.5, 2.5);
  ctx.fillStyle = '#1a1a1a'; ctx.fillRect(cx + 28, by - 6, 0.5, 1.5); // brake slots
  // Trigger guard
  ctx.strokeStyle = '#3a3a3a'; ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.arc(cx + 12, by - 3, 1.5, 0, Math.PI); ctx.stroke();
  // Bipod (deployed)
  ctx.strokeStyle = '#3a3a3a'; ctx.lineWidth = 1.2;
  ctx.beginPath(); ctx.moveTo(cx + 16, by - 4); ctx.lineTo(cx + 14, by + 2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 18, by - 4); ctx.lineTo(cx + 20, by + 2); ctx.stroke();
  // Bipod feet
  ctx.fillStyle = '#333'; ctx.fillRect(cx + 13, by + 1, 2, 1); ctx.fillRect(cx + 19, by + 1, 2, 1);

  // Scope (large, high magnification)
  const scopeGrad = ctx.createLinearGradient(cx + 11, by - 9, cx + 20, by - 6);
  scopeGrad.addColorStop(0, '#1a1a1e'); scopeGrad.addColorStop(0.3, '#2a2a30'); scopeGrad.addColorStop(0.7, '#333338'); scopeGrad.addColorStop(1, '#1a1a1e');
  ctx.fillStyle = scopeGrad;
  ctx.fillRect(cx + 11, by - 9, 9, 2.5);
  // Scope tube
  ctx.fillRect(cx + 10, by - 8.5, 1.5, 1.5); ctx.fillRect(cx + 19, by - 8.5, 1.5, 1.5);
  // Scope turrets (elevation/windage)
  ctx.fillStyle = '#3a3a3e'; ctx.fillRect(cx + 14, by - 10, 1.5, 1.5); ctx.fillRect(cx + 17, by - 10, 1.5, 1.5);
  // Objective lens with glint
  ctx.fillStyle = def.color; ctx.shadowColor = def.color; ctx.shadowBlur = 4;
  ctx.beginPath(); ctx.arc(cx + 20.5, by - 7.8, 1.5, 0, Math.PI * 2); ctx.fill();
  ctx.shadowBlur = 0;
  // Lens reflection
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.beginPath(); ctx.arc(cx + 20, by - 8.2, 0.5, 0, Math.PI * 2); ctx.fill();
  // Scope rings/mounts
  ctx.fillStyle = '#2a2a2e'; ctx.fillRect(cx + 12, by - 7, 2, 1); ctx.fillRect(cx + 18, by - 7, 2, 1);

  // Head
  // Neck (wrapped)
  ctx.fillStyle = '#2a3a20'; ctx.fillRect(cx - 2, by - 7, 4, 3);
  // Head shape
  const headGrad = ctx.createRadialGradient(cx - 1, by - 12, 1, cx, by - 10, 5.5);
  headGrad.addColorStop(0, '#d0b088'); headGrad.addColorStop(1, '#a88868');
  ctx.fillStyle = headGrad;
  ctx.beginPath(); ctx.arc(cx, by - 10, 5.5, 0, Math.PI * 2); ctx.fill();
  // Face paint (heavy camo stripes)
  ctx.fillStyle = 'rgba(30,50,20,0.5)';
  ctx.save(); ctx.translate(cx, by - 10); ctx.rotate(-0.15);
  ctx.fillRect(-4, -3, 7, 1.5); ctx.fillRect(-3, 0, 6, 1.5); ctx.fillRect(-2, 3, 5, 1);
  ctx.restore();
  ctx.fillStyle = 'rgba(60,40,20,0.35)';
  ctx.save(); ctx.translate(cx, by - 10); ctx.rotate(0.1);
  ctx.fillRect(-3, -2, 5, 1); ctx.fillRect(-4, 1, 6, 1);
  ctx.restore();
  // Eyes (narrowed, focused)
  ctx.fillStyle = '#e0e0d0'; ctx.fillRect(cx - 2.5, by - 11.5, 2, 1.5); ctx.fillRect(cx + 0.5, by - 11.5, 2, 1.5);
  ctx.fillStyle = '#2a3a20'; ctx.fillRect(cx - 2, by - 11, 1, 1); ctx.fillRect(cx + 1, by - 11, 1, 1);
  ctx.fillStyle = '#111'; ctx.fillRect(cx - 1.8, by - 11, 0.6, 0.6); ctx.fillRect(cx + 1.2, by - 11, 0.6, 0.6);
  // Nose
  ctx.fillStyle = 'rgba(170,130,100,0.3)'; ctx.fillRect(cx - 0.5, by - 10, 1, 1.5);

  // Ghillie hood (covers top of head)
  const hoodGrad = ctx.createLinearGradient(cx - 7, by - 17, cx + 7, by - 12);
  hoodGrad.addColorStop(0, def.dark); hoodGrad.addColorStop(0.5, def.color); hoodGrad.addColorStop(1, def.dark);
  ctx.fillStyle = hoodGrad;
  ctx.beginPath(); ctx.arc(cx, by - 14, 7, Math.PI, 0); ctx.fill();
  ctx.fillRect(cx - 7, by - 15, 14, 4);
  // Ghillie hood strips/frays
  ctx.fillStyle = '#3a4a28';
  ctx.beginPath(); ctx.ellipse(cx - 3, by - 17, 2.5, 1.5, 0.2, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#5a6a40';
  ctx.beginPath(); ctx.ellipse(cx + 2, by - 16, 2, 1.5, -0.3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#4a5a30';
  ctx.beginPath(); ctx.ellipse(cx - 1, by - 18, 2, 1, 0.5, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#2e3e1e';
  ctx.beginPath(); ctx.ellipse(cx + 4, by - 15, 1.5, 2, -0.4, 0, Math.PI * 2); ctx.fill();
  // Dangling frays from hood
  ctx.strokeStyle = '#3a4a28'; ctx.lineWidth = 0.6;
  const waveH = Math.sin(animFrame * 0.05) * 0.5;
  ctx.beginPath(); ctx.moveTo(cx - 6, by - 12); ctx.lineTo(cx - 7 + waveH, by - 9); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 6, by - 12); ctx.lineTo(cx + 7 + waveH, by - 9); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx - 4, by - 12); ctx.lineTo(cx - 5, by - 8); ctx.stroke();
}

function drawAPC(cx, by, def) {
  // ── Detailed 8-wheeled APC (BTR/Stryker style) ──

  // Ground shadow (large vehicle)
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.beginPath(); ctx.ellipse(cx, by + 12, 20, 5, 0, 0, Math.PI * 2); ctx.fill();

  // Exhaust smoke (subtle)
  const smokeAlpha = 0.05 + Math.sin(animFrame * 0.08) * 0.02;
  ctx.fillStyle = 'rgba(80,80,80,' + smokeAlpha + ')';
  ctx.beginPath(); ctx.arc(cx - 17, by + 4, 3 + Math.sin(animFrame * 0.1) * 1, 0, Math.PI * 2); ctx.fill();

  // Hull bottom / chassis
  const chassisGrad = ctx.createLinearGradient(cx - 16, by + 6, cx + 16, by + 10);
  chassisGrad.addColorStop(0, '#2a3034'); chassisGrad.addColorStop(0.5, '#333a3e'); chassisGrad.addColorStop(1, '#252a2e');
  ctx.fillStyle = chassisGrad;
  ctx.fillRect(cx - 16, by + 5, 32, 6);

  // Wheels (4 per side, visible)
  for (let i = 0; i < 4; i++) {
    const wx = cx - 12 + i * 8;
    // Tire
    ctx.fillStyle = '#1a1a1a';
    ctx.beginPath(); ctx.arc(wx, by + 10, 3.5, 0, Math.PI * 2); ctx.fill();
    // Tire tread pattern
    ctx.strokeStyle = '#222'; ctx.lineWidth = 0.4;
    for (let t = 0; t < 6; t++) {
      const a = t * Math.PI / 3;
      ctx.beginPath(); ctx.moveTo(wx + Math.cos(a) * 2.5, by + 10 + Math.sin(a) * 2.5);
      ctx.lineTo(wx + Math.cos(a) * 3.3, by + 10 + Math.sin(a) * 3.3); ctx.stroke();
    }
    // Hub cap
    const hubGrad = ctx.createRadialGradient(wx, by + 10, 0.5, wx, by + 10, 2);
    hubGrad.addColorStop(0, '#555'); hubGrad.addColorStop(1, '#333');
    ctx.fillStyle = hubGrad;
    ctx.beginPath(); ctx.arc(wx, by + 10, 2, 0, Math.PI * 2); ctx.fill();
    // Hub bolt
    ctx.fillStyle = '#666';
    ctx.beginPath(); ctx.arc(wx, by + 10, 0.5, 0, Math.PI * 2); ctx.fill();
  }
  // Wheel well shadows
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  for (let i = 0; i < 4; i++) {
    ctx.fillRect(cx - 14 + i * 8, by + 6, 5, 2);
  }

  // Main hull (angled armor)
  // Lower hull
  const hullLowGrad = ctx.createLinearGradient(cx - 16, by, cx + 16, by + 6);
  hullLowGrad.addColorStop(0, '#4a5a5e'); hullLowGrad.addColorStop(0.3, def.color); hullLowGrad.addColorStop(0.7, def.dark); hullLowGrad.addColorStop(1, '#3a4a4e');
  ctx.fillStyle = hullLowGrad;
  ctx.fillRect(cx - 16, by, 32, 7);
  // Upper hull (angled top)
  const hullUpGrad = ctx.createLinearGradient(cx - 15, by - 6, cx + 15, by);
  hullUpGrad.addColorStop(0, '#6a7a80'); hullUpGrad.addColorStop(0.3, '#5a6a70'); hullUpGrad.addColorStop(1, def.color);
  ctx.fillStyle = hullUpGrad;
  ctx.beginPath();
  ctx.moveTo(cx - 16, by); ctx.lineTo(cx - 14, by - 6);
  ctx.lineTo(cx + 14, by - 6); ctx.lineTo(cx + 16, by);
  ctx.closePath(); ctx.fill();
  // Hull top face (lighter, catches light)
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.fillRect(cx - 14, by - 6, 28, 2);

  // Armor plate seam lines
  ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.moveTo(cx - 16, by + 3); ctx.lineTo(cx + 16, by + 3); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx - 6, by - 5); ctx.lineTo(cx - 6, by + 5); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 6, by - 5); ctx.lineTo(cx + 6, by + 5); ctx.stroke();

  // Side armor ERA/slat (reactive armor panels)
  ctx.fillStyle = 'rgba(70,80,85,0.5)';
  ctx.fillRect(cx - 15, by + 1, 6, 3); ctx.fillRect(cx - 7, by + 1, 6, 3); ctx.fillRect(cx + 3, by + 1, 6, 3);
  ctx.fillRect(cx + 11, by + 1, 4, 3);
  // Panel bolts
  ctx.fillStyle = '#555';
  for (let i = 0; i < 4; i++) {
    ctx.beginPath(); ctx.arc(cx - 13 + i * 8, by + 2, 0.5, 0, Math.PI * 2); ctx.fill();
  }

  // View ports (armored glass, dark)
  ctx.fillStyle = '#1a2228';
  ctx.fillRect(cx - 10, by - 3, 3, 2); ctx.fillRect(cx - 4, by - 3, 3, 2); ctx.fillRect(cx + 4, by - 3, 3, 2);
  // Glass reflection
  ctx.fillStyle = 'rgba(100,150,200,0.15)';
  ctx.fillRect(cx - 9.5, by - 3, 1, 1); ctx.fillRect(cx - 3.5, by - 3, 1, 1); ctx.fillRect(cx + 4.5, by - 3, 1, 1);

  // Front headlights
  ctx.fillStyle = '#aa9960'; ctx.fillRect(cx + 13, by - 2, 2, 1.5);
  ctx.fillStyle = '#aa9960'; ctx.fillRect(cx + 13, by + 1, 2, 1.5);
  // Headlight glow
  ctx.fillStyle = 'rgba(200,180,100,0.08)';
  ctx.beginPath(); ctx.arc(cx + 15, by, 4, 0, Math.PI * 2); ctx.fill();

  // Rear details
  ctx.fillStyle = '#aa3030'; ctx.fillRect(cx - 15, by - 2, 1.5, 1.5); // tail light
  ctx.fillStyle = '#aa3030'; ctx.fillRect(cx - 15, by + 1, 1.5, 1.5);

  // Stowage/equipment on hull
  ctx.fillStyle = '#3a4a3a'; ctx.fillRect(cx - 13, by - 5, 3, 2); // ammo box
  ctx.strokeStyle = '#2a3a2a'; ctx.lineWidth = 0.4; ctx.strokeRect(cx - 13, by - 5, 3, 2);
  ctx.fillStyle = '#4a3a2a'; ctx.fillRect(cx + 8, by - 5, 4, 2); // fuel jerry can
  ctx.fillStyle = '#3a2a1a'; ctx.fillRect(cx + 9, by - 5.5, 2, 0.8); // can handle

  // Turret base ring
  ctx.fillStyle = '#3a4248';
  ctx.beginPath(); ctx.ellipse(cx, by - 6, 5, 2, 0, 0, Math.PI * 2); ctx.fill();

  // Turret (RCWS style remote weapon station)
  const turretGrad = ctx.createLinearGradient(cx - 5, by - 14, cx + 5, by - 7);
  turretGrad.addColorStop(0, '#4a5458'); turretGrad.addColorStop(0.5, '#5a6468'); turretGrad.addColorStop(1, '#3a4448');
  ctx.fillStyle = turretGrad;
  ctx.fillRect(cx - 5, by - 13, 10, 7);
  // Turret top
  ctx.fillStyle = 'rgba(255,255,255,0.05)'; ctx.fillRect(cx - 4, by - 13, 8, 1.5);
  // Turret armor edges
  ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 0.5;
  ctx.strokeRect(cx - 5, by - 13, 10, 7);

  // Optics package on turret
  ctx.fillStyle = '#2a2a30'; ctx.fillRect(cx - 3, by - 14, 4, 1.5);
  ctx.fillStyle = 'rgba(100,150,200,0.3)'; ctx.fillRect(cx - 2, by - 14, 1, 1); // camera lens
  ctx.fillStyle = 'rgba(200,50,50,0.3)'; ctx.fillRect(cx + 0.5, by - 14, 1, 1); // IR sensor

  // Main gun barrel (autocannon / HMG)
  const barrelGrad = ctx.createLinearGradient(cx + 5, by - 11, cx + 20, by - 9);
  barrelGrad.addColorStop(0, '#333'); barrelGrad.addColorStop(0.5, '#444'); barrelGrad.addColorStop(1, '#2a2a2a');
  ctx.fillStyle = barrelGrad;
  ctx.fillRect(cx + 5, by - 11, 15, 2.5);
  // Barrel flash hider
  ctx.fillStyle = '#222'; ctx.fillRect(cx + 19, by - 11.5, 2, 3);
  ctx.fillStyle = '#1a1a1a';
  ctx.fillRect(cx + 20, by - 11, 0.5, 1); ctx.fillRect(cx + 20, by - 9.5, 0.5, 1);
  // Barrel highlight
  ctx.fillStyle = 'rgba(255,255,255,0.08)'; ctx.fillRect(cx + 6, by - 11, 12, 0.5);
  // Coax MG
  ctx.fillStyle = '#333'; ctx.fillRect(cx + 5, by - 8, 10, 1);

  // Antenna
  ctx.strokeStyle = '#555'; ctx.lineWidth = 0.7;
  const antWave = Math.sin(animFrame * 0.06) * 1;
  ctx.beginPath(); ctx.moveTo(cx - 4, by - 13); ctx.lineTo(cx - 5 + antWave, by - 22); ctx.stroke();
  ctx.fillStyle = '#aa3030'; ctx.fillRect(cx - 5.5 + antWave, by - 22, 1.5, 1); // antenna tip

  // Smoke grenade launchers on turret sides
  ctx.fillStyle = '#3a3a3a';
  ctx.fillRect(cx - 7, by - 11, 2, 4); ctx.fillRect(cx + 5, by - 11, 0, 0);
  // Individual tubes
  ctx.fillStyle = '#2a2a2a';
  ctx.beginPath(); ctx.arc(cx - 6.5, by - 10, 0.8, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx - 6.5, by - 8.5, 0.8, 0, Math.PI * 2); ctx.fill();
}

function drawHelicopter(cx, by, def) {
  // ── Detailed attack helicopter (Mi-24/Apache style) ──
  const bladeSpin = animFrame * 0.35;
  const hover = Math.sin(animFrame * 0.08) * 1.5;
  const hby = by + hover; // hover bobbing

  // Ground shadow (moves with hover)
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath(); ctx.ellipse(cx + 2, by + 20, 16, 5, 0.05, 0, Math.PI * 2); ctx.fill();

  // Rotor downwash effect on ground
  const washAlpha = 0.03 + Math.sin(animFrame * 0.15) * 0.015;
  ctx.strokeStyle = 'rgba(150,150,150,' + washAlpha + ')';
  ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.ellipse(cx, by + 20, 18 + Math.sin(animFrame * 0.2) * 2, 6, 0, 0, Math.PI * 2); ctx.stroke();

  // Tail boom
  const tailGrad = ctx.createLinearGradient(cx + 8, hby - 1, cx + 24, hby + 2);
  tailGrad.addColorStop(0, def.color); tailGrad.addColorStop(0.5, def.dark); tailGrad.addColorStop(1, '#1a3a6a');
  ctx.fillStyle = tailGrad;
  ctx.beginPath();
  ctx.moveTo(cx + 8, hby - 2); ctx.lineTo(cx + 24, hby - 1);
  ctx.lineTo(cx + 24, hby + 2); ctx.lineTo(cx + 8, hby + 3);
  ctx.closePath(); ctx.fill();
  // Tail boom spine
  ctx.fillStyle = 'rgba(255,255,255,0.05)';
  ctx.fillRect(cx + 10, hby - 1.5, 12, 0.5);
  // Tail boom rivet line
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.fillRect(cx + 10, hby + 1, 12, 0.3);

  // Vertical stabilizer / tail fin
  const finGrad = ctx.createLinearGradient(cx + 20, hby - 8, cx + 26, hby + 2);
  finGrad.addColorStop(0, '#3a6aaa'); finGrad.addColorStop(1, def.dark);
  ctx.fillStyle = finGrad;
  ctx.beginPath();
  ctx.moveTo(cx + 22, hby - 1); ctx.lineTo(cx + 20, hby - 8);
  ctx.lineTo(cx + 24, hby - 8); ctx.lineTo(cx + 26, hby - 1);
  ctx.closePath(); ctx.fill();
  // Horizontal stabilizer
  ctx.fillStyle = def.dark;
  ctx.beginPath();
  ctx.moveTo(cx + 21, hby); ctx.lineTo(cx + 18, hby - 3);
  ctx.lineTo(cx + 26, hby - 3); ctx.lineTo(cx + 26, hby);
  ctx.closePath(); ctx.fill();

  // Tail rotor
  const trSpin = animFrame * 0.5;
  ctx.strokeStyle = 'rgba(180,180,180,0.5)'; ctx.lineWidth = 1;
  const trLen = 5;
  ctx.beginPath();
  ctx.moveTo(cx + 23, hby - 7 + Math.sin(trSpin) * trLen);
  ctx.lineTo(cx + 23, hby - 7 - Math.sin(trSpin) * trLen); ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(cx + 23, hby - 7 + Math.cos(trSpin) * trLen);
  ctx.lineTo(cx + 23, hby - 7 - Math.cos(trSpin) * trLen); ctx.stroke();
  // Tail rotor hub
  ctx.fillStyle = '#555'; ctx.beginPath(); ctx.arc(cx + 23, hby - 7, 1, 0, Math.PI * 2); ctx.fill();

  // Engine housing (top of fuselage)
  const engineGrad = ctx.createLinearGradient(cx - 4, hby - 10, cx + 8, hby - 7);
  engineGrad.addColorStop(0, '#4a7aba'); engineGrad.addColorStop(0.5, def.color); engineGrad.addColorStop(1, def.dark);
  ctx.fillStyle = engineGrad;
  ctx.fillRect(cx - 4, hby - 10, 12, 3);
  // Engine intake grilles
  ctx.fillStyle = '#1a1a2a';
  ctx.fillRect(cx - 2, hby - 10, 3, 1.5); ctx.fillRect(cx + 3, hby - 10, 3, 1.5);
  // Engine exhaust ports
  ctx.fillStyle = '#222'; ctx.fillRect(cx + 6, hby - 9, 2, 2);
  // Heat shimmer from exhaust
  const heatAlpha = 0.04 + Math.sin(animFrame * 0.2) * 0.02;
  ctx.fillStyle = 'rgba(255,200,100,' + heatAlpha + ')';
  ctx.beginPath(); ctx.arc(cx + 9, hby - 8, 2, 0, Math.PI * 2); ctx.fill();

  // Main fuselage body
  const bodyGrad = ctx.createLinearGradient(cx - 12, hby - 4, cx + 10, hby + 5);
  bodyGrad.addColorStop(0, '#5a8aca'); bodyGrad.addColorStop(0.3, def.color); bodyGrad.addColorStop(0.7, def.dark); bodyGrad.addColorStop(1, '#1a4a8a');
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.moveTo(cx - 14, hby + 1); ctx.lineTo(cx - 8, hby - 8);
  ctx.lineTo(cx + 8, hby - 8); ctx.lineTo(cx + 10, hby);
  ctx.lineTo(cx + 8, hby + 5); ctx.lineTo(cx - 12, hby + 5);
  ctx.closePath(); ctx.fill();

  // Fuselage panel lines
  ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 0.4;
  ctx.beginPath(); ctx.moveTo(cx - 6, hby - 7); ctx.lineTo(cx - 8, hby + 4); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 2, hby - 7); ctx.lineTo(cx + 4, hby + 4); ctx.stroke();
  // Fuselage highlight (top left light)
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  ctx.beginPath();
  ctx.moveTo(cx - 12, hby); ctx.lineTo(cx - 6, hby - 7);
  ctx.lineTo(cx + 4, hby - 7); ctx.lineTo(cx + 2, hby);
  ctx.closePath(); ctx.fill();

  // Side armor plating
  ctx.fillStyle = 'rgba(40,60,90,0.4)';
  ctx.fillRect(cx - 10, hby, 8, 3); ctx.fillRect(cx, hby, 6, 3);

  // Side door / access panel
  ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 0.5;
  ctx.strokeRect(cx - 4, hby - 3, 5, 5);
  ctx.fillStyle = '#333'; ctx.fillRect(cx - 2, hby - 1, 1, 1); // door handle

  // Cockpit canopy (tandem, armored glass)
  // Rear seat canopy
  ctx.fillStyle = 'rgba(60,100,140,0.6)';
  ctx.beginPath();
  ctx.moveTo(cx - 4, hby - 2); ctx.lineTo(cx - 2, hby - 6);
  ctx.lineTo(cx + 3, hby - 6); ctx.lineTo(cx + 3, hby - 2);
  ctx.closePath(); ctx.fill();
  // Front seat canopy (larger, angled)
  const canopyGrad = ctx.createLinearGradient(cx - 10, hby - 4, cx - 4, hby);
  canopyGrad.addColorStop(0, 'rgba(130,210,250,0.6)'); canopyGrad.addColorStop(1, 'rgba(60,120,180,0.4)');
  ctx.fillStyle = canopyGrad;
  ctx.beginPath();
  ctx.moveTo(cx - 10, hby); ctx.lineTo(cx - 6, hby - 5);
  ctx.lineTo(cx - 2, hby - 5); ctx.lineTo(cx - 2, hby);
  ctx.closePath(); ctx.fill();
  // Canopy frame
  ctx.strokeStyle = 'rgba(30,60,100,0.6)'; ctx.lineWidth = 0.8;
  ctx.beginPath(); ctx.moveTo(cx - 6, hby - 5); ctx.lineTo(cx - 6, hby); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx - 2, hby - 6); ctx.lineTo(cx - 2, hby); ctx.stroke();
  // Canopy glare
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.beginPath();
  ctx.moveTo(cx - 9, hby - 1); ctx.lineTo(cx - 7, hby - 4);
  ctx.lineTo(cx - 5, hby - 4); ctx.lineTo(cx - 7, hby - 1);
  ctx.closePath(); ctx.fill();

  // Chin turret (sensor/gun)
  ctx.fillStyle = '#2a3a4a';
  ctx.beginPath(); ctx.arc(cx - 10, hby + 3, 3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#333'; ctx.fillRect(cx - 14, hby + 2, 4, 1.5); // chain gun barrel
  // Sensor dome
  ctx.fillStyle = 'rgba(100,150,200,0.3)';
  ctx.beginPath(); ctx.arc(cx - 10, hby + 3, 1.5, 0, Math.PI * 2); ctx.fill();

  // Stub wings / weapon pylons
  const wingGrad = ctx.createLinearGradient(cx - 14, hby + 1, cx - 18, hby + 4);
  wingGrad.addColorStop(0, def.color); wingGrad.addColorStop(1, def.dark);
  ctx.fillStyle = wingGrad;
  // Left wing
  ctx.beginPath();
  ctx.moveTo(cx - 10, hby + 1); ctx.lineTo(cx - 18, hby + 2);
  ctx.lineTo(cx - 18, hby + 4); ctx.lineTo(cx - 10, hby + 3);
  ctx.closePath(); ctx.fill();
  // Right wing
  ctx.beginPath();
  ctx.moveTo(cx + 6, hby + 1); ctx.lineTo(cx + 14, hby + 2);
  ctx.lineTo(cx + 14, hby + 4); ctx.lineTo(cx + 6, hby + 3);
  ctx.closePath(); ctx.fill();

  // Hardpoints with missiles (Hellfire/Ataka style)
  // Left pylon
  ctx.fillStyle = '#3a3a3a'; ctx.fillRect(cx - 16, hby + 2, 2, 1.5); // pylon
  // Missile rack
  ctx.fillStyle = '#4a4a4a'; ctx.fillRect(cx - 18, hby + 1, 4, 3);
  // Missiles
  ctx.fillStyle = '#ddd';
  ctx.fillRect(cx - 18, hby + 1, 3.5, 1); ctx.fillRect(cx - 18, hby + 3, 3.5, 1);
  // Missile nose cones (red)
  ctx.fillStyle = '#e53935';
  ctx.fillRect(cx - 19, hby + 1, 1, 1); ctx.fillRect(cx - 19, hby + 3, 1, 1);
  // Missile fins
  ctx.fillStyle = '#999';
  ctx.fillRect(cx - 15, hby + 0.5, 0.5, 1.5); ctx.fillRect(cx - 15, hby + 2.5, 0.5, 1.5);

  // Right pylon missiles
  ctx.fillStyle = '#3a3a3a'; ctx.fillRect(cx + 12, hby + 2, 2, 1.5);
  ctx.fillStyle = '#4a4a4a'; ctx.fillRect(cx + 12, hby + 1, 4, 3);
  ctx.fillStyle = '#ddd';
  ctx.fillRect(cx + 12.5, hby + 1, 3.5, 1); ctx.fillRect(cx + 12.5, hby + 3, 3.5, 1);
  ctx.fillStyle = '#e53935';
  ctx.fillRect(cx + 16, hby + 1, 1, 1); ctx.fillRect(cx + 16, hby + 3, 1, 1);
  ctx.fillStyle = '#999';
  ctx.fillRect(cx + 12.5, hby + 0.5, 0.5, 1.5); ctx.fillRect(cx + 12.5, hby + 2.5, 0.5, 1.5);

  // Rocket pods (outboard)
  ctx.fillStyle = '#3a4a3a';
  ctx.beginPath(); ctx.ellipse(cx - 16, hby + 4, 2, 1.5, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx + 14, hby + 4, 2, 1.5, 0, 0, Math.PI * 2); ctx.fill();

  // Landing skids
  // Skid struts
  ctx.strokeStyle = '#4a5a6a'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(cx - 8, hby + 5); ctx.lineTo(cx - 10, hby + 10); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx - 4, hby + 5); ctx.lineTo(cx - 6, hby + 10); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 6, hby + 5); ctx.lineTo(cx + 4, hby + 10); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 2, hby + 5); ctx.lineTo(cx, hby + 10); ctx.stroke();
  // Skid tubes
  ctx.strokeStyle = '#3a4a5a'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(cx - 14, hby + 10); ctx.lineTo(cx - 4, hby + 10); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx - 2, hby + 10); ctx.lineTo(cx + 8, hby + 10); ctx.stroke();
  // Skid cross braces
  ctx.strokeStyle = '#4a5a6a'; ctx.lineWidth = 0.8;
  ctx.beginPath(); ctx.moveTo(cx - 10, hby + 10); ctx.lineTo(cx - 7, hby + 7); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 1, hby + 10); ctx.lineTo(cx + 3, hby + 7); ctx.stroke();

  // Main rotor (4 blades, motion blur)
  const rLen = 22;
  // Rotor disc (motion blur circle)
  ctx.strokeStyle = 'rgba(150,160,170,0.12)'; ctx.lineWidth = 3;
  ctx.beginPath(); ctx.ellipse(cx, hby - 10, rLen, rLen * 0.15, 0, 0, Math.PI * 2); ctx.stroke();
  // Individual blades (4)
  for (let b = 0; b < 4; b++) {
    const angle = bladeSpin + (b * Math.PI / 2);
    const bx = Math.cos(angle) * rLen;
    const bIso = Math.sin(angle) * (rLen * 0.15); // isometric foreshortening
    // Blade with gradient
    const bladeAlpha = 0.4 + Math.abs(Math.sin(angle)) * 0.3;
    ctx.strokeStyle = 'rgba(140,150,160,' + bladeAlpha + ')';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(cx + bx, hby - 10 + bIso);
    ctx.lineTo(cx - bx, hby - 10 - bIso);
    ctx.stroke();
    // Blade tip weights
    ctx.fillStyle = 'rgba(200,50,50,0.4)';
    ctx.beginPath(); ctx.arc(cx + bx, hby - 10 + bIso, 1, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cx - bx, hby - 10 - bIso, 1, 0, Math.PI * 2); ctx.fill();
  }

  // Rotor mast
  ctx.fillStyle = '#444';
  ctx.fillRect(cx - 1.5, hby - 12, 3, 3);
  // Rotor hub (swashplate)
  const hubGrad = ctx.createRadialGradient(cx, hby - 10, 1, cx, hby - 10, 3);
  hubGrad.addColorStop(0, '#666'); hubGrad.addColorStop(1, '#444');
  ctx.fillStyle = hubGrad;
  ctx.beginPath(); ctx.arc(cx, hby - 10, 3, 0, Math.PI * 2); ctx.fill();
  // Hub cap
  ctx.fillStyle = '#777';
  ctx.beginPath(); ctx.arc(cx, hby - 10, 1.2, 0, Math.PI * 2); ctx.fill();

  // Navigation lights
  ctx.fillStyle = '#ff1a1a'; ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 3;
  ctx.beginPath(); ctx.arc(cx - 12, hby + 3, 0.8, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#1aff1a'; ctx.shadowColor = '#00ff00';
  ctx.beginPath(); ctx.arc(cx + 8, hby + 3, 0.8, 0, Math.PI * 2); ctx.fill();
  ctx.shadowBlur = 0;
  // Anti-collision beacon (flashing)
  if (Math.sin(animFrame * 0.2) > 0) {
    ctx.fillStyle = 'rgba(255,60,60,0.6)'; ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 4;
    ctx.beginPath(); ctx.arc(cx, hby - 10, 1, 0, Math.PI * 2); ctx.fill();
    ctx.shadowBlur = 0;
  }
}

function drawMadScientist(cx, by, def) {
  // Legs
  ctx.fillStyle = '#333'; ctx.fillRect(cx - 4, by + 4, 3, 7); ctx.fillRect(cx + 1, by + 4, 3, 7);
  // White lab coat
  ctx.fillStyle = '#e8e8e8'; ctx.fillRect(cx - 7, by - 6, 14, 12);
  ctx.fillStyle = '#ddd'; ctx.fillRect(cx - 7, by + 2, 14, 4);
  // Coat lapels
  ctx.fillStyle = '#ccc'; ctx.beginPath(); ctx.moveTo(cx - 2, by - 6); ctx.lineTo(cx, by - 2); ctx.lineTo(cx + 2, by - 6); ctx.fill();
  // Arms in coat
  ctx.fillStyle = '#e0e0e0'; ctx.fillRect(cx - 10, by - 4, 4, 9); ctx.fillRect(cx + 6, by - 4, 4, 9);
  // Head
  ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(cx, by - 10, 5, 0, Math.PI * 2); ctx.fill();
  // Wild hair (purple-tinted)
  ctx.fillStyle = '#6a1b9a';
  ctx.beginPath(); ctx.arc(cx - 3, by - 15, 3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 3, by - 15, 3, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx, by - 16, 2.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx - 5, by - 13, 2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 5, by - 13, 2, 0, Math.PI * 2); ctx.fill();
  // Green goggles
  ctx.fillStyle = '#76ff03';
  ctx.beginPath(); ctx.arc(cx - 2, by - 10, 2, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 2, by - 10, 2, 0, Math.PI * 2); ctx.fill();
  ctx.strokeStyle = '#333'; ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.arc(cx - 2, by - 10, 2, 0, Math.PI * 2); ctx.stroke();
  ctx.beginPath(); ctx.arc(cx + 2, by - 10, 2, 0, Math.PI * 2); ctx.stroke();
  // Bubbling flask in hand
  ctx.fillStyle = '#4caf50'; ctx.beginPath(); ctx.moveTo(cx + 8, by + 2); ctx.lineTo(cx + 6, by - 2);
  ctx.lineTo(cx + 11, by - 2); ctx.closePath(); ctx.fill();
  ctx.fillStyle = '#aed581'; ctx.beginPath(); ctx.arc(cx + 8.5, by - 3, 1.5, 0, Math.PI * 2); ctx.fill();
  // Bubbles
  const bub = animFrame * 0.15;
  ctx.fillStyle = 'rgba(76,175,80,0.6)';
  ctx.beginPath(); ctx.arc(cx + 8 + Math.sin(bub)*2, by - 5 - Math.abs(Math.sin(bub*1.3))*3, 1, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 9 + Math.sin(bub+1)*1.5, by - 4 - Math.abs(Math.sin(bub*0.8))*2, 0.7, 0, Math.PI * 2); ctx.fill();
}

function drawMutant(cx, by, def) {
  // Large muscular green creature
  // Feet (big)
  ctx.fillStyle = '#33691e'; ctx.fillRect(cx - 6, by + 6, 5, 4); ctx.fillRect(cx + 1, by + 6, 5, 4);
  // Thick legs
  ctx.fillStyle = '#558b2f'; ctx.fillRect(cx - 5, by + 1, 4, 6); ctx.fillRect(cx + 1, by + 1, 4, 6);
  // Massive torso
  ctx.fillStyle = def.color; ctx.fillRect(cx - 8, by - 8, 16, 11);
  ctx.fillStyle = def.dark; ctx.fillRect(cx - 7, by - 7, 14, 4);
  // Chest scars
  ctx.strokeStyle = '#1b5e20'; ctx.lineWidth = 0.7;
  ctx.beginPath(); ctx.moveTo(cx - 4, by - 5); ctx.lineTo(cx + 2, by - 2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + 3, by - 6); ctx.lineTo(cx - 1, by - 1); ctx.stroke();
  // Muscular arms (thick)
  ctx.fillStyle = def.color;
  ctx.fillRect(cx - 13, by - 6, 6, 10); ctx.fillRect(cx + 7, by - 6, 6, 10);
  ctx.fillStyle = def.dark;
  ctx.fillRect(cx - 12, by + 3, 4, 3); ctx.fillRect(cx + 8, by + 3, 4, 3); // fists
  // Small head
  ctx.fillStyle = '#689f38'; ctx.beginPath(); ctx.arc(cx, by - 12, 4, 0, Math.PI * 2); ctx.fill();
  // Glowing yellow eyes
  ctx.fillStyle = '#ffff00';
  ctx.beginPath(); ctx.arc(cx - 2, by - 12, 1.5, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + 2, by - 12, 1.5, 0, Math.PI * 2); ctx.fill();
  // Eye glow effect
  const glowPulse = 0.3 + Math.sin(animFrame * 0.15) * 0.2;
  ctx.fillStyle = 'rgba(255,255,0,' + glowPulse + ')';
  ctx.beginPath(); ctx.arc(cx, by - 12, 6, 0, Math.PI * 2); ctx.fill();
  // Mouth/jaw
  ctx.fillStyle = '#33691e';
  ctx.fillRect(cx - 3, by - 9, 6, 2);
  ctx.fillStyle = '#fff'; ctx.fillRect(cx - 2, by - 9, 1, 1); ctx.fillRect(cx + 1, by - 9, 1, 1); // teeth
}

// ═══════════════════════════════════════════
//  DRAWING - ALLIES, FORTS, CHESTS
// ═══════════════════════════════════════════
function drawAllyUnit(a, sx, sy) {
  const cx = sx, cy = sy;
  const bob = Math.sin(animFrame * 0.08 + a.x * 2) * 1;
  const td = TROOP_TYPES[a.troopType];

  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.ellipse(cx + 3, cy + 5, 9, 3, 0.2, 0, Math.PI * 2); ctx.fill();

  const by = cy - 10 + bob;

  ctx.fillStyle = '#558b2f';
  ctx.fillRect(cx - 4, by + 3, 3, 7); ctx.fillRect(cx + 1, by + 3, 3, 7);
  ctx.fillStyle = '#7cb342'; ctx.fillRect(cx - 6, by - 5, 12, 10);
  ctx.fillStyle = '#aed581'; ctx.fillRect(cx - 5, by - 4, 10, 3);
  ctx.fillStyle = '#689f38';
  ctx.fillRect(cx - 9, by - 3, 3, 7); ctx.fillRect(cx + 6, by - 3, 3, 7);
  ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(cx, by - 10, 5, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#111';
  ctx.fillRect(cx - 3, by - 11, 1, 1); ctx.fillRect(cx + 2, by - 11, 1, 1);
  ctx.strokeStyle = '#111'; ctx.lineWidth = 0.8;
  ctx.beginPath(); ctx.arc(cx, by - 8, 3, 0.2, Math.PI - 0.2); ctx.stroke();

  ctx.strokeStyle = '#558b2f'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(cx + 7, by - 16); ctx.lineTo(cx + 7, by - 2); ctx.stroke();
  ctx.fillStyle = td.color;
  const flagWave = Math.sin(animFrame * 0.15) * 2;
  ctx.beginPath();
  ctx.moveTo(cx + 8, by - 16); ctx.lineTo(cx + 16 + flagWave, by - 14);
  ctx.lineTo(cx + 16 + flagWave, by - 10); ctx.lineTo(cx + 8, by - 8); ctx.closePath(); ctx.fill();

  drawLabel(cx, cy + 14, a.count + ' ' + td.name, td.color);
}

function drawMercCamp(m, sx, sy) {
  const cx = sx, cy = sy;
  const bob = Math.sin(animFrame * 0.06 + m.x * 3) * 0.5;
  const by = cy - 8 + bob;
  const td = TROOP_TYPES[m.troopType];

  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.ellipse(cx + 3, cy + 5, 12, 4, 0.2, 0, Math.PI * 2); ctx.fill();

  // Tent base (triangular)
  ctx.fillStyle = '#5d4037';
  ctx.beginPath(); ctx.moveTo(cx - 12, by + 8); ctx.lineTo(cx, by - 8);
  ctx.lineTo(cx + 12, by + 8); ctx.closePath(); ctx.fill();
  // Tent front
  ctx.fillStyle = '#795548';
  ctx.beginPath(); ctx.moveTo(cx - 10, by + 8); ctx.lineTo(cx, by - 6);
  ctx.lineTo(cx + 10, by + 8); ctx.closePath(); ctx.fill();
  // Opening
  ctx.fillStyle = '#3e2723';
  ctx.beginPath(); ctx.moveTo(cx - 4, by + 8); ctx.lineTo(cx, by + 2);
  ctx.lineTo(cx + 4, by + 8); ctx.closePath(); ctx.fill();

  // Flag pole + color flag
  ctx.strokeStyle = '#4e342e'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(cx + 10, by - 10); ctx.lineTo(cx + 10, by + 2); ctx.stroke();
  ctx.fillStyle = td.color;
  const flagWave = Math.sin(animFrame * 0.15 + m.y) * 2;
  ctx.beginPath(); ctx.moveTo(cx + 11, by - 10); ctx.lineTo(cx + 19 + flagWave, by - 8);
  ctx.lineTo(cx + 19 + flagWave, by - 5); ctx.lineTo(cx + 11, by - 3); ctx.closePath(); ctx.fill();

  // Gold coin accent
  ctx.fillStyle = '#ffd54f'; ctx.beginPath(); ctx.arc(cx - 8, by + 5, 3, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#ff8f00'; ctx.beginPath(); ctx.arc(cx - 8, by + 5, 2, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#ffd54f'; ctx.font = '5px sans-serif'; ctx.fillText('$', cx - 9.5, by + 7);

  // Label
  drawLabel(cx, cy + 16, m.count + ' ' + td.name + ' (' + m.cost + 'g)', '#ffd54f');
}

function drawOverworldEngineer(eg, sx, sy) {
  const cx = sx, cy = sy;
  const bob = Math.sin(animFrame * 0.09 + eg.x * 4) * 1;
  const by = cy - 8 + bob;
  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.ellipse(cx + 2, cy + 4, 8, 3, 0.1, 0, Math.PI * 2); ctx.fill();
  // Boots
  ctx.fillStyle = '#5d4037'; ctx.fillRect(cx - 4, by + 8, 3, 3); ctx.fillRect(cx + 1, by + 8, 3, 3);
  // Orange overalls
  ctx.fillStyle = '#ff9800'; ctx.fillRect(cx - 5, by + 2, 10, 7);
  ctx.fillStyle = '#e65100'; ctx.fillRect(cx - 5, by + 2, 10, 2); // straps
  // Arms
  ctx.fillStyle = '#ff9800'; ctx.fillRect(cx - 8, by, 4, 7); ctx.fillRect(cx + 4, by, 4, 7);
  // Skin
  ctx.fillStyle = '#dbb896'; ctx.fillRect(cx - 8, by + 5, 3, 2); ctx.fillRect(cx + 5, by + 5, 3, 2);
  // Head
  ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(cx, by - 3, 4, 0, Math.PI * 2); ctx.fill();
  // Hard hat (yellow)
  ctx.fillStyle = '#fdd835'; ctx.beginPath(); ctx.arc(cx, by - 5, 4.5, Math.PI, 0); ctx.fill();
  ctx.fillRect(cx - 5, by - 6, 10, 2);
  // Eyes
  ctx.fillStyle = '#333'; ctx.fillRect(cx - 2, by - 4, 1.5, 1.5); ctx.fillRect(cx + 1, by - 4, 1.5, 1.5);
  // Wrench in hand
  ctx.fillStyle = '#78909c'; ctx.fillRect(cx + 6, by + 1, 6, 1.5);
  ctx.fillStyle = '#546e7a'; ctx.fillRect(cx + 11, by, 2, 3);
  // "FREE" label
  ctx.font = 'bold 7px sans-serif'; ctx.textAlign = 'center';
  ctx.fillStyle = '#4caf50'; ctx.fillText('FREE', cx, cy + 15);
}

function drawFort(sx, sy, str) {
  const cx = sx, cy = sy;
  const fortH = 28;

  // Ground shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.ellipse(cx + 4, cy + 6, 18, 7, 0.2, 0, Math.PI * 2); ctx.fill();

  // 3D building: isometric box
  // Front wall (right side)
  ctx.fillStyle = '#5d4037';
  ctx.beginPath();
  ctx.moveTo(cx + TILE_W * 0.35, cy - fortH);
  ctx.lineTo(cx, cy - fortH + TILE_H * 0.35);
  ctx.lineTo(cx, cy + TILE_H * 0.35);
  ctx.lineTo(cx + TILE_W * 0.35, cy);
  ctx.closePath(); ctx.fill();
  // Side wall (left side)
  ctx.fillStyle = '#4e342e';
  ctx.beginPath();
  ctx.moveTo(cx - TILE_W * 0.35, cy - fortH);
  ctx.lineTo(cx, cy - fortH + TILE_H * 0.35);
  ctx.lineTo(cx, cy + TILE_H * 0.35);
  ctx.lineTo(cx - TILE_W * 0.35, cy);
  ctx.closePath(); ctx.fill();
  // Roof (top face)
  ctx.fillStyle = '#8d6e63';
  ctx.beginPath();
  ctx.moveTo(cx, cy - fortH - TILE_H * 0.35);
  ctx.lineTo(cx + TILE_W * 0.35, cy - fortH);
  ctx.lineTo(cx, cy - fortH + TILE_H * 0.35);
  ctx.lineTo(cx - TILE_W * 0.35, cy - fortH);
  ctx.closePath(); ctx.fill();

  // Battlements on top
  ctx.fillStyle = '#795548';
  for (let i = 0; i < 3; i++) {
    ctx.fillRect(cx - 12 + i * 8, cy - fortH - 8, 4, 5);
  }

  // Windows with warm glow
  ctx.fillStyle = '#ffcc02'; ctx.shadowColor = '#ff8800'; ctx.shadowBlur = 6;
  ctx.fillRect(cx + 4, cy - fortH + 10, 3, 3);
  ctx.fillRect(cx + 12, cy - fortH + 8, 3, 3);
  ctx.fillRect(cx - 8, cy - fortH + 10, 3, 3);
  ctx.fillRect(cx - 14, cy - fortH + 8, 3, 3);

  // Door
  ctx.fillStyle = '#3e2723'; ctx.shadowBlur = 0;
  ctx.fillRect(cx - 3, cy - 8, 6, 10);
  ctx.fillStyle = '#4e342e'; ctx.beginPath(); ctx.arc(cx, cy - 8, 3, Math.PI, 0); ctx.fill();

  // Animated torch flames
  const flicker1 = Math.sin(animFrame * 0.2) * 2;
  const flicker2 = Math.sin(animFrame * 0.25 + 1) * 2;
  // Left torch
  ctx.fillStyle = '#ffcc02'; ctx.shadowColor = '#ff8800'; ctx.shadowBlur = 6;
  ctx.fillRect(cx - 10, cy - 12, 2, 3);
  ctx.fillStyle = '#ff6600';
  ctx.beginPath(); ctx.moveTo(cx - 10, cy - 13); ctx.lineTo(cx - 9, cy - 18 + flicker1); ctx.lineTo(cx - 8, cy - 13); ctx.fill();
  // Right torch
  ctx.fillStyle = '#ffcc02';
  ctx.fillRect(cx + 8, cy - 12, 2, 3);
  ctx.fillStyle = '#ff6600';
  ctx.beginPath(); ctx.moveTo(cx + 8, cy - 13); ctx.lineTo(cx + 9, cy - 18 + flicker2); ctx.lineTo(cx + 10, cy - 13); ctx.fill();
  ctx.shadowBlur = 0;

  // Flag on top
  ctx.strokeStyle = '#bbb'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(cx, cy - fortH - 8); ctx.lineTo(cx, cy - fortH - 26); ctx.stroke();
  const flagW = Math.sin(animFrame * 0.12) * 2;
  ctx.fillStyle = '#e53935';
  ctx.beginPath();
  ctx.moveTo(cx + 1, cy - fortH - 26); ctx.lineTo(cx + 10 + flagW, cy - fortH - 24);
  ctx.lineTo(cx + 10 + flagW, cy - fortH - 19); ctx.lineTo(cx + 1, cy - fortH - 17);
  ctx.closePath(); ctx.fill();

  // Fort glow on ground
  const fortGlow = ctx.createRadialGradient(cx, cy, 6, cx, cy, 35);
  fortGlow.addColorStop(0, 'rgba(255,150,50,0.06)');
  fortGlow.addColorStop(1, 'rgba(255,150,50,0)');
  ctx.fillStyle = fortGlow;
  ctx.fillRect(cx - 38, cy - 38, 76, 76);

  drawLabel(cx, cy + 18, str, '#ffa726');
}

function drawPlayerFort(sx, sy, pf) {
  const cx = sx, cy = sy;
  const fortH = 28;
  // Wall colors by upgrade level
  const wallColors = ['#37474f','#455a64','#546e7a','#607d8b'];
  const wallDark  = ['#263238','#37474f','#455a64','#546e7a'];
  const wLvl = pf.walls || 0;

  // Ground shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.ellipse(cx + 4, cy + 6, 18, 7, 0.2, 0, Math.PI * 2); ctx.fill();

  // Front wall (right side) — blue-gray tones
  ctx.fillStyle = wallColors[wLvl];
  ctx.beginPath();
  ctx.moveTo(cx + TILE_W * 0.35, cy - fortH);
  ctx.lineTo(cx, cy - fortH + TILE_H * 0.35);
  ctx.lineTo(cx, cy + TILE_H * 0.35);
  ctx.lineTo(cx + TILE_W * 0.35, cy);
  ctx.closePath(); ctx.fill();
  // Side wall (left side)
  ctx.fillStyle = wallDark[wLvl];
  ctx.beginPath();
  ctx.moveTo(cx - TILE_W * 0.35, cy - fortH);
  ctx.lineTo(cx, cy - fortH + TILE_H * 0.35);
  ctx.lineTo(cx, cy + TILE_H * 0.35);
  ctx.lineTo(cx - TILE_W * 0.35, cy);
  ctx.closePath(); ctx.fill();
  // Roof
  ctx.fillStyle = '#78909c';
  ctx.beginPath();
  ctx.moveTo(cx, cy - fortH - TILE_H * 0.35);
  ctx.lineTo(cx + TILE_W * 0.35, cy - fortH);
  ctx.lineTo(cx, cy - fortH + TILE_H * 0.35);
  ctx.lineTo(cx - TILE_W * 0.35, cy - fortH);
  ctx.closePath(); ctx.fill();

  // Battlements
  ctx.fillStyle = wallColors[wLvl];
  for (let i = 0; i < 3; i++) ctx.fillRect(cx - 12 + i * 8, cy - fortH - 8, 4, 5);

  // Windows (blue glow)
  ctx.fillStyle = '#64b5f6'; ctx.shadowColor = '#2196f3'; ctx.shadowBlur = 6;
  ctx.fillRect(cx + 4, cy - fortH + 10, 3, 3);
  ctx.fillRect(cx + 12, cy - fortH + 8, 3, 3);
  ctx.fillRect(cx - 8, cy - fortH + 10, 3, 3);
  ctx.fillRect(cx - 14, cy - fortH + 8, 3, 3);

  // Door
  ctx.fillStyle = '#263238'; ctx.shadowBlur = 0;
  ctx.fillRect(cx - 3, cy - 8, 6, 10);
  ctx.fillStyle = '#37474f'; ctx.beginPath(); ctx.arc(cx, cy - 8, 3, Math.PI, 0); ctx.fill();

  // Torches
  const flicker1 = Math.sin(animFrame * 0.2) * 2;
  const flicker2 = Math.sin(animFrame * 0.25 + 1) * 2;
  ctx.fillStyle = '#64b5f6'; ctx.shadowColor = '#2196f3'; ctx.shadowBlur = 6;
  ctx.fillRect(cx - 10, cy - 12, 2, 3);
  ctx.fillStyle = '#42a5f5';
  ctx.beginPath(); ctx.moveTo(cx - 10, cy - 13); ctx.lineTo(cx - 9, cy - 18 + flicker1); ctx.lineTo(cx - 8, cy - 13); ctx.fill();
  ctx.fillStyle = '#64b5f6';
  ctx.fillRect(cx + 8, cy - 12, 2, 3);
  ctx.fillStyle = '#42a5f5';
  ctx.beginPath(); ctx.moveTo(cx + 8, cy - 13); ctx.lineTo(cx + 9, cy - 18 + flicker2); ctx.lineTo(cx + 10, cy - 13); ctx.fill();
  ctx.shadowBlur = 0;

  // Flag — blue for player, gold for home
  ctx.strokeStyle = '#bbb'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(cx, cy - fortH - 8); ctx.lineTo(cx, cy - fortH - 26); ctx.stroke();
  const flagW = Math.sin(animFrame * 0.12) * 2;
  ctx.fillStyle = pf.isHome ? '#ffd54f' : '#1e88e5';
  ctx.beginPath();
  ctx.moveTo(cx + 1, cy - fortH - 26); ctx.lineTo(cx + 10 + flagW, cy - fortH - 24);
  ctx.lineTo(cx + 10 + flagW, cy - fortH - 19); ctx.lineTo(cx + 1, cy - fortH - 17);
  ctx.closePath(); ctx.fill();

  // Home fort golden glow
  if (pf.isHome) {
    const hGlow = ctx.createRadialGradient(cx, cy, 6, cx, cy, 40);
    hGlow.addColorStop(0, 'rgba(255,215,0,0.1)');
    hGlow.addColorStop(1, 'rgba(255,215,0,0)');
    ctx.fillStyle = hGlow;
    ctx.fillRect(cx - 42, cy - 42, 84, 84);
  }

  // Turret indicators
  if (pf.turrets > 0) {
    ctx.fillStyle = '#90a4ae';
    ctx.fillRect(cx - 18, cy - fortH - 4, 4, 6);
    ctx.fillRect(cx + 14, cy - fortH - 4, 4, 6);
    if (pf.turrets >= 2) { ctx.fillStyle = '#78909c'; ctx.fillRect(cx - 19, cy - fortH - 7, 6, 4); ctx.fillRect(cx + 13, cy - fortH - 7, 6, 4); }
  }

  // Label
  const garCount = TROOP_ORDER.reduce((s, t) => s + (pf.garrison[t] ? pf.garrison[t].length : 0), 0);
  const label = pf.isHome ? 'HOME' : 'Fort';
  drawLabel(cx, cy + 18, label + (garCount > 0 ? ' [' + garCount + ']' : ''), '#64b5f6');
}

function drawChest(sx, sy, goldAmt) {
  const cx = sx, cy = sy;
  const sparkle = Math.sin(animFrame * 0.2) * 0.3 + 0.7;
  const chestH = 8;

  // Glow on ground (iso ellipse)
  const chGlow = ctx.createRadialGradient(cx, cy, 3, cx, cy, 22);
  chGlow.addColorStop(0, 'rgba(180,120,255,' + (sparkle * 0.08) + ')');
  chGlow.addColorStop(1, 'rgba(120,60,200,0)');
  ctx.fillStyle = chGlow;
  ctx.fillRect(cx - 24, cy - 18, 48, 40);
  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.beginPath(); ctx.ellipse(cx + 2, cy + 4, 10, 4, 0.2, 0, Math.PI * 2); ctx.fill();

  // 3D chest box: top + left + right faces
  const bw = 10, bh = 6; // half-widths for the iso box
  // Top face (lid)
  ctx.fillStyle = '#ab47bc';
  ctx.beginPath();
  ctx.moveTo(cx, cy - chestH - bh); ctx.lineTo(cx + bw, cy - chestH);
  ctx.lineTo(cx, cy - chestH + bh); ctx.lineTo(cx - bw, cy - chestH);
  ctx.closePath(); ctx.fill();
  // Lid highlight
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.beginPath();
  ctx.moveTo(cx, cy - chestH - bh); ctx.lineTo(cx + bw, cy - chestH);
  ctx.lineTo(cx, cy - chestH + bh); ctx.lineTo(cx - bw, cy - chestH);
  ctx.closePath(); ctx.fill();
  // Left face
  ctx.fillStyle = '#7b1fa2';
  ctx.beginPath();
  ctx.moveTo(cx - bw, cy - chestH); ctx.lineTo(cx, cy - chestH + bh);
  ctx.lineTo(cx, cy + bh); ctx.lineTo(cx - bw, cy);
  ctx.closePath(); ctx.fill();
  // Right face
  ctx.fillStyle = '#5c1480';
  ctx.beginPath();
  ctx.moveTo(cx + bw, cy - chestH); ctx.lineTo(cx, cy - chestH + bh);
  ctx.lineTo(cx, cy + bh); ctx.lineTo(cx + bw, cy);
  ctx.closePath(); ctx.fill();

  // Metal bands
  ctx.fillStyle = '#ffc107';
  ctx.fillRect(cx - bw + 1, cy - chestH, bw * 2 - 2, 1.5);
  ctx.fillRect(cx - bw + 1, cy - 2, bw * 2 - 2, 1.5);
  // Lock
  ctx.fillStyle = '#ffd54f'; ctx.shadowColor = 'rgba(255,213,79,' + sparkle + ')'; ctx.shadowBlur = 6;
  ctx.beginPath(); ctx.arc(cx, cy - chestH / 2, 3, 0, Math.PI * 2); ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#5d1680'; ctx.fillRect(cx - 0.5, cy - chestH / 2 - 0.5, 1, 2);

  // Sparkle orbits
  for (let s = 0; s < 3; s++) {
    const sa = Math.sin(animFrame * 0.18 + s * 2.1);
    const spx = cx + Math.cos(animFrame * 0.07 + s * 2.3) * (12 + s * 3);
    const spy = cy - 6 + Math.sin(animFrame * 0.09 + s * 1.7) * 8;
    if (sa > 0.3) {
      ctx.fillStyle = 'rgba(255,215,80,' + ((sa - 0.3) * 0.8) + ')';
      ctx.fillRect(spx - 1, spy - 1, 2, 2);
    }
  }
  drawLabel(cx, cy + 14, goldAmt + 'g', '#ce93d8');
}

// ═══════════════════════════════════════════
//  DRAWING - UTILITIES
// ═══════════════════════════════════════════
function drawLabel(x, y, text, color) {
  ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'center';
  // Background pill
  const w = ctx.measureText(text).width + 8;
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  const rx = x - w/2, ry = y - 10, rw = w, rh = 14, rr = 4;
  ctx.beginPath();
  ctx.moveTo(rx + rr, ry); ctx.lineTo(rx + rw - rr, ry);
  ctx.arcTo(rx + rw, ry, rx + rw, ry + rr, rr);
  ctx.lineTo(rx + rw, ry + rh - rr);
  ctx.arcTo(rx + rw, ry + rh, rx + rw - rr, ry + rh, rr);
  ctx.lineTo(rx + rr, ry + rh);
  ctx.arcTo(rx, ry + rh, rx, ry + rh - rr, rr);
  ctx.lineTo(rx, ry + rr);
  ctx.arcTo(rx, ry, rx + rr, ry, rr);
  ctx.closePath();
  ctx.fill();
  // Text with slight outline
  ctx.fillStyle = 'rgba(0,0,0,0.8)';
  ctx.fillText(text, x + 1, y + 1);
  ctx.fillText(text, x - 1, y + 1);
  ctx.fillStyle = color; ctx.fillText(text, x, y);
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.ox += p.vx; p.oy += p.vy;
    p.vy += 0.04;
    p.vx *= 0.96; p.vy *= 0.98;
    p.life--;
    const t = p.life / p.maxLife;
    const alpha = t * t;
    p.size *= 0.995;
    // Convert world coords to screen
    const iso = toIso(p.gx, p.gy);
    const sx = iso.x + p.ox, sy = iso.y + p.oy;
    if (sx < -20 || sx > W + 20 || sy < -20 || sy > H + 20) { particles.splice(i, 1); continue; }
    ctx.globalAlpha = alpha;
    const pGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, p.size);
    pGrad.addColorStop(0, p.color);
    pGrad.addColorStop(0.5, p.color);
    pGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = pGrad;
    ctx.beginPath(); ctx.arc(sx, sy, p.size, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function updateAmbientParticles() {
  for (let i = ambientParticles.length - 1; i >= 0; i--) {
    const p = ambientParticles[i];
    p.x += p.vx + Math.sin(animFrame * 0.02 + i) * 0.15;
    p.y += p.vy;
    p.life--;
    // Just draw at screen coords (ambient, not grid-bound)
    if (p.y > 0 && p.y < H - PANEL_H && p.x > 0 && p.x < W) {
      ctx.fillStyle = 'rgba(200,210,180,' + (p.alpha * (p.life / p.maxLife)) + ')';
      ctx.fillRect(p.x, p.y, p.size, p.size);
    }
    if (p.life <= 0 || p.y < -10 || p.x < -10 || p.x > W + 10) {
      ambientParticles[i] = {
        x: Math.random() * W, y: H - PANEL_H + 10,
        vx: (Math.random() - 0.5) * 0.3, vy: -0.1 - Math.random() * 0.2,
        size: 1 + Math.random() * 1.5, alpha: 0.15 + Math.random() * 0.25,
        life: 200 + randInt(0, 200), maxLife: 400,
      };
    }
  }
}

function updateFloatingTexts() {
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const ft = floatingTexts[i];
    const t = ft.life / 60;
    ft.oy -= 0.4 + t * 0.6;
    ft.life--;
    const raw = ft.life / 60;
    const alpha = raw * raw;
    const scale = 1 + (1 - raw) * 0.2;
    // Convert world coords to screen
    const iso = toIso(ft.gx, ft.gy);
    const sx = iso.x, sy = iso.y + ft.oy;
    if (sx < -100 || sx > W + 100 || sy < -100 || sy > H + 100) { floatingTexts.splice(i, 1); continue; }
    ctx.font = 'bold ' + Math.floor(13 * scale) + 'px sans-serif'; ctx.textAlign = 'center';
    ctx.globalAlpha = Math.min(1, alpha);
    ctx.shadowColor = ft.color; ctx.shadowBlur = 8;
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillText(ft.text, sx + 1, sy + 1);
    ctx.fillStyle = ft.color; ctx.fillText(ft.text, sx, sy);
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    if (ft.life <= 0) floatingTexts.splice(i, 1);
  }
}

// ═══════════════════════════════════════════
//  TACTICAL BATTLE SYSTEM
// ═══════════════════════════════════════════
const BATTLE_ISO_X = W / 2;
const BATTLE_ISO_Y = 100;

function toBattleIso(gx, gy) {
  return {
    x: (gx - gy) * (TILE_W / 2) + BATTLE_ISO_X,
    y: (gx + gy) * (TILE_H / 2) + BATTLE_ISO_Y
  };
}
function fromBattleIso(sx, sy) {
  const rx = sx - BATTLE_ISO_X;
  const ry = sy - BATTLE_ISO_Y;
  const gx = (rx / (TILE_W / 2) + ry / (TILE_H / 2)) / 2;
  const gy = (ry / (TILE_H / 2) - rx / (TILE_W / 2)) / 2;
  return { x: Math.round(gx), y: Math.round(gy) };
}

function enterBattle(arr, idx, isFort) {
  const entity = arr[idx];
  gameMode = 'deploy';
  deploySelectedType = null;
  battleParticles = [];
  battleFloatingTexts = [];

  // Generate battle grid
  const grid = [];
  for (let y = 0; y < BROWS; y++) {
    grid[y] = [];
    for (let x = 0; x < BCOLS; x++) {
      // Random obstacles (10% in middle area, not in deployment zones)
      if (x >= 3 && x < BCOLS - 3 && Math.random() < 0.1) grid[y][x] = 'wall';
      else grid[y][x] = 'grass';
    }
  }

  // Generate enemy units from strength
  const eType = isFort ? 'militant' : entity.type;
  const eStr = isFort ? entity.str : entity.str;
  const eStats = ENEMY_BATTLE_STATS[eType];
  const numEnemies = Math.max(1, Math.ceil(eStr / eStats.hp));
  const enemyUnits = [];
  for (let i = 0; i < numEnemies; i++) {
    const ex = BCOLS - 1 - (i % 3);
    const ey = Math.floor(i / 3) + Math.floor((BROWS - Math.ceil(numEnemies / 3)) / 2);
    const ey2 = Math.max(0, Math.min(BROWS - 1, ey));
    // Mix unit types for forts and mad scientists
    let unitType = eType;
    if (isFort && i > 0 && Math.random() < 0.4) unitType = 'commando';
    if (eType === 'mad_scientist' && i > 0 && Math.random() < 0.5) unitType = 'mutant';
    const stats = ENEMY_BATTLE_STATS[unitType];
    enemyUnits.push({
      type: unitType, hp: stats.hp, maxHp: stats.hp,
      atk: stats.atk, range: stats.range,
      aoe: stats.aoe, heavy: stats.heavy || false,
      x: ex, y: ey2, vx: ex, vy: ey2,
      moveSpeed: stats.moveSpeed, attackRate: stats.attackRate, attackCD: 0,
    });
  }
  // Make sure no two enemies overlap
  for (let i = 1; i < enemyUnits.length; i++) {
    while (enemyUnits.some((u, j) => j < i && u.x === enemyUnits[i].x && u.y === enemyUnits[i].y)) {
      enemyUnits[i].y = (enemyUnits[i].y + 1) % BROWS;
    }
    enemyUnits[i].vx = enemyUnits[i].x;
    enemyUnits[i].vy = enemyUnits[i].y;
  }

  battle = {
    grid,
    playerUnits: [],
    enemyUnits,
    enemyContext: { type: eType, str: eStr, index: idx, isFort, arr },
    simSpeed: 1,     // 1, 2, or 4
    simPaused: false,
    frameCount: 0,
    resultMsg: '',
    deployArmy: {}, // copy of player army HP arrays for deployment
  };
  // Copy army HP arrays for deployment
  for (const t of TROOP_ORDER) battle.deployArmy[t] = Array.isArray(player.army[t]) ? player.army[t].slice() : [];
}

function cancelDeploy() {
  // player.army was never modified during deploy, so just reset
  gameMode = 'overworld';
  battle = null;
  // Push player back so they don't re-trigger
  player.x = Math.max(1, player.x - player.lastDx);
  player.y = Math.max(1, player.y - player.lastDy);
}

function startBattle() {
  if (battle.playerUnits.length === 0) return;
  for (const t of TROOP_ORDER) player.army[t] = Array.isArray(battle.deployArmy[t]) ? battle.deployArmy[t].slice() : [];
  battle.deployedSnapshot = {};
  for (const u of battle.playerUnits) {
    if (!battle.deployedSnapshot[u.type]) battle.deployedSnapshot[u.type] = [];
    battle.deployedSnapshot[u.type].push(u.maxHp);
  }
  // Init real-time fields on all units
  for (const u of battle.playerUnits) {
    const s = BATTLE_STATS[u.type];
    u.moveSpeed = s.moveSpeed; u.attackRate = s.attackRate; u.attackCD = Math.floor(Math.random() * 20);
    u.vx = u.x; u.vy = u.y;
  }
  for (const u of battle.enemyUnits) {
    const s = ENEMY_BATTLE_STATS[u.type];
    u.moveSpeed = s.moveSpeed; u.attackRate = s.attackRate; u.attackCD = Math.floor(Math.random() * 30);
    u.vx = u.x; u.vy = u.y;
  }
  battleProjectiles = [];
  updateHUD();
  gameMode = 'battle';
  battle.simSpeed = 1;
  battle.simPaused = false;
  battle.frameCount = 0;
}

function getEuclidDist(a, b) {
  return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
}

// ═════ PROJECTILE HELPERS ═════
function getProjectileType(unitType) {
  if (unitType === 'rpg') return 'rocket';
  if (unitType === 'tanks' || unitType === 'apc') return 'shell';
  if (unitType === 'bombers') return 'bomb';
  if (unitType === 'flamethrower') return 'flame';
  if (unitType === 'medic') return 'heal';
  if (unitType === 'machinegun') return 'mg_burst';
  if (unitType === 'mutant') return 'fist';
  if (unitType === 'mad_scientist') return 'laser';
  return 'bullet';
}

function getProjectileColor(pType) {
  if (pType === 'rocket') return '#ff6600';
  if (pType === 'shell') return '#aaa';
  if (pType === 'bomb') return '#ff4444';
  if (pType === 'flame') return '#ff9800';
  if (pType === 'heal') return '#66bb6a';
  if (pType === 'mg_burst') return '#ffee58';
  if (pType === 'fist') return '#76ff03';
  if (pType === 'laser') return '#ce93d8';
  return '#ffffaa';
}

function getProjectileSpeed(pType) {
  if (pType === 'rocket') return 0.12;
  if (pType === 'shell') return 0.1;
  if (pType === 'bomb') return 0.08;
  if (pType === 'flame') return 0.15;
  if (pType === 'heal') return 0.15;
  if (pType === 'fist') return 0.2;
  if (pType === 'laser') return 0.14;
  if (pType === 'mg_burst') return 0.18;
  return 0.16;
}

function spawnProjectile(attacker, target, isPlayer) {
  const pType = getProjectileType(attacker.type);
  const count = pType === 'mg_burst' ? 3 : 1;
  for (let i = 0; i < count; i++) {
    battleProjectiles.push({
      x: attacker.x, y: attacker.y,
      tx: target.x, ty: target.y,
      targetUnit: target,
      speed: getProjectileSpeed(pType),
      dmg: attacker.atk, atk: attacker.atk,
      attackerType: attacker.type, aoe: attacker.aoe || 0,
      isPlayer, type: pType,
      color: getProjectileColor(pType),
      life: 120, delay: i * 5,
      heavy: attacker.heavy,
    });
  }
}

// ═════ REAL-TIME BATTLE AI ═════
function updateRealTimeBattle() {
  if (!battle || battle.simPaused || gameMode !== 'battle') return;
  const speedMul = battle.simSpeed;
  battle.frameCount = (battle.frameCount || 0) + 1;

  const allUnits = battle.playerUnits.concat(battle.enemyUnits);

  // Process burning DOT every ~60 frames
  if (battle.frameCount % 60 === 0) {
    for (const u of allUnits) {
      if (u.hp <= 0 || !u.burning || u.burning <= 0) continue;
      u.hp -= 2;
      u.burning--;
      const biso = toBattleIso(u.x, u.y);
      for (let i = 0; i < 4; i++) {
        battleParticles.push({ x: biso.x + (Math.random()-0.5)*8, y: biso.y - 10 + (Math.random()-0.5)*6, vx: (Math.random()-0.5)*1.5, vy: -1.5 - Math.random(), life: 18, maxLife: 18, color: i < 2 ? '#ff9800' : '#ffeb3b', size: 2 + Math.random() });
      }
      battleFloatingTexts.push({ x: biso.x, y: biso.y - 28, text: '-2 BURN', color: '#ff9800', life: 40 });
      if (u.hp <= 0) {
        battle.enemyUnits = battle.enemyUnits.filter(x => x.hp > 0);
        battle.playerUnits = battle.playerUnits.filter(x => x.hp > 0);
        if (battle.enemyUnits.length === 0) { battleVictory(); return; }
        if (battle.playerUnits.length === 0) { battleDefeat(); return; }
      }
    }
  }

  // Turret bonus damage every ~120 frames
  if (battle.turretBonus && battle.frameCount % 120 === 0 && battle.enemyUnits.length > 0) {
    const target = battle.enemyUnits[randInt(0, battle.enemyUnits.length - 1)];
    if (target && target.hp > 0) {
      target.hp -= battle.turretBonus;
      const tiso = toBattleIso(target.x, target.y);
      battleFloatingTexts.push({ x: tiso.x, y: tiso.y - 28, text: '-' + battle.turretBonus + ' TURRET', color: '#90a4ae', life: 40 });
      for (let i = 0; i < 6; i++) {
        battleParticles.push({ x: tiso.x + (Math.random()-0.5)*12, y: tiso.y - 10 + (Math.random()-0.5)*8, vx: (Math.random()-0.5)*2, vy: -2 - Math.random(), life: 15, maxLife: 15, color: '#b0bec5', size: 2 });
      }
      if (target.hp <= 0) {
        battle.enemyUnits = battle.enemyUnits.filter(x => x.hp > 0);
        if (battle.enemyUnits.length === 0) { battleVictory(); return; }
      }
    }
  }

  // Mad scientists summon mutants every ~180 frames in battle
  if (battle.frameCount % 180 === 0) {
    for (const u of battle.enemyUnits) {
      if (u.hp <= 0 || u.type !== 'mad_scientist') continue;
      if (!u.summonCount) u.summonCount = 0;
      if (u.summonCount >= 3) continue;
      const ms = ENEMY_BATTLE_STATS.mutant;
      battle.enemyUnits.push({
        type: 'mutant', hp: ms.hp, maxHp: ms.hp, atk: ms.atk, range: ms.range,
        aoe: ms.aoe, heavy: ms.heavy, x: u.x + (Math.random()-0.5)*0.5, y: u.y + (Math.random()-0.5)*0.5,
        vx: u.x, vy: u.y, moveSpeed: ms.moveSpeed, attackRate: ms.attackRate, attackCD: 20,
      });
      u.summonCount++;
      const siso = toBattleIso(u.x, u.y);
      for (let i = 0; i < 8; i++) battleParticles.push({ x: siso.x, y: siso.y - 8, vx: (Math.random()-0.5)*3, vy: -Math.random()*2-1, life: 25, maxLife: 25, color: '#76ff03', size: 2.5 });
      battleFloatingTexts.push({ x: siso.x, y: siso.y - 30, text: 'SUMMON!', color: '#76ff03', life: 50 });
    }
  }

  for (const u of allUnits) {
    if (u.hp <= 0) continue;
    if (u.attackCD > 0) u.attackCD -= speedMul;
    const isPlayer = battle.playerUnits.includes(u);
    const enemies = isPlayer ? battle.enemyUnits : battle.playerUnits;
    const allies = isPlayer ? battle.playerUnits : battle.enemyUnits;

    // Medic: heal allies
    if (u.type === 'medic') {
      let healTarget = null, lowestFrac = 1;
      for (const a of allies) {
        if (a === u || a.hp <= 0) continue;
        const f = a.hp / a.maxHp;
        if (f < lowestFrac) { lowestFrac = f; healTarget = a; }
      }
      if (healTarget && lowestFrac < 0.9) {
        const d = getEuclidDist(u, healTarget);
        if (d <= u.range && u.attackCD <= 0) {
          const healAmt = 4;
          healTarget.hp = Math.min(healTarget.maxHp, healTarget.hp + healAmt);
          const hIso = toBattleIso(healTarget.x, healTarget.y);
          for (let i = 0; i < 4; i++) battleParticles.push({ x: hIso.x, y: hIso.y - 10, vx: (Math.random()-0.5)*2, vy: -1-Math.random()*2, life: 20, maxLife: 20, color: '#66bb6a', size: 2 });
          battleFloatingTexts.push({ x: hIso.x, y: hIso.y - 20, text: '+' + healAmt, color: '#66bb6a', life: 40 });
          u.attackCD = u.attackRate;
        } else if (d > u.range) {
          moveToward(u, healTarget, speedMul, allies);
        }
      }
      continue;
    }

    // Find target
    let target = null;
    if (isPlayer) {
      // Smart targeting
      let bestScore = 999;
      for (const e of enemies) {
        if (e.hp <= 0) continue;
        let score = getEuclidDist(u, e);
        if (u.type === 'rpg' && e.heavy) score -= 8;
        if (e.hp < e.maxHp) score -= 2;
        if (e.hp <= u.atk) score -= 1.5;
        if (score < bestScore) { bestScore = score; target = e; }
      }
    } else {
      // Enemy: nearest
      let nearDist = 999;
      for (const p of enemies) {
        if (p.hp <= 0) continue;
        const d = getEuclidDist(u, p);
        if (d < nearDist) { nearDist = d; target = p; }
      }
    }
    if (!target) continue;

    const dist = getEuclidDist(u, target);
    // Ranged units stop at range, melee close in
    const idealRange = (u.type === 'snipers' || u.type === 'bombers' || u.type === 'sniper_e') ? u.range * 0.8 : u.range * 0.7;

    if (dist <= u.range && u.attackCD <= 0) {
      // Fire projectile
      spawnProjectile(u, target, isPlayer);
      u.attackCD = u.attackRate;
    } else if (dist > idealRange) {
      moveToward(u, target, speedMul, allies);
    }
  }
}

function moveToward(u, target, speedMul, allies) {
  const dx = target.x - u.x, dy = target.y - u.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist < 0.05) return;
  let mx = (dx / dist) * u.moveSpeed * speedMul;
  let my = (dy / dist) * u.moveSpeed * speedMul;
  // Separation from allies to avoid stacking
  for (const a of allies) {
    if (a === u || a.hp <= 0) continue;
    const sd = getEuclidDist(u, a);
    if (sd < 0.6) {
      const sep = 0.005 / Math.max(0.1, sd);
      mx += (u.x - a.x) * sep;
      my += (u.y - a.y) * sep;
    }
  }
  u.x = Math.max(0.2, Math.min(BCOLS - 0.2, u.x + mx));
  u.y = Math.max(0.2, Math.min(BROWS - 0.2, u.y + my));
}

// ═════ PROJECTILE UPDATE ═════
function updateProjectiles() {
  for (let i = battleProjectiles.length - 1; i >= 0; i--) {
    const p = battleProjectiles[i];
    if (p.delay > 0) { p.delay--; continue; }
    // Move toward target
    const t = p.targetUnit;
    if (t && t.hp > 0) { p.tx = t.x; p.ty = t.y; }
    const dx = p.tx - p.x, dy = p.ty - p.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 0.15 || p.life <= 0) {
      // Impact!
      if (t && t.hp > 0) battleProjectileHit(p);
      battleProjectiles.splice(i, 1);
      continue;
    }
    p.x += (dx / dist) * p.speed * battle.simSpeed;
    p.y += (dy / dist) * p.speed * battle.simSpeed;
    p.life--;
    // Trail particles
    if (p.type === 'rocket' || p.type === 'flame') {
      const iso = toBattleIso(p.x, p.y);
      battleParticles.push({ x: iso.x, y: iso.y - 8, vx: (Math.random()-0.5)*1, vy: -0.5, life: 10, maxLife: 10, color: p.color, size: 1.5 });
    }
  }
}

function battleProjectileHit(proj) {
  const defender = proj.targetUnit;
  const isPlayerUnit = proj.isPlayer;

  let dmg = proj.dmg;
  if (proj.attackerType === 'rpg' && defender.heavy) dmg = Math.ceil(dmg * 1.6);
  if (defender.type === 'tanks') dmg = Math.max(1, dmg - 5);
  if (isPlayerUnit && morale !== 0) dmg = Math.max(1, Math.ceil(dmg * (1 + morale * 0.08)));
  dmg = Math.ceil(dmg * (0.8 + Math.random() * 0.4));
  if (proj.type === 'mg_burst') dmg = Math.ceil(dmg * 0.4);
  defender.hp -= dmg;

  const diso = toBattleIso(defender.x, defender.y);
  for (let i = 0; i < 5; i++) {
    battleParticles.push({ x: diso.x, y: diso.y - 10, vx: (Math.random()-0.5)*3, vy: -Math.random()*3-1, life: 20, maxLife: 20, color: defender.hp <= 0 ? '#ff4444' : '#ffaa44', size: 2 + Math.random()*2 });
  }
  battleFloatingTexts.push({ x: diso.x, y: diso.y - 25, text: '-' + dmg, color: '#ff4444', life: 50 });

  // Flamethrower burn DOT
  if (proj.type === 'flame' && defender.hp > 0) {
    defender.burning = 3;
  }

  // AOE splash
  if (proj.aoe > 0) {
    const targets = isPlayerUnit ? battle.enemyUnits : battle.playerUnits;
    for (const t of targets) {
      if (t === defender || t.hp <= 0) continue;
      if (getEuclidDist(t, defender) <= proj.aoe) {
        let splashDmg = Math.ceil(dmg * 0.5);
        t.hp -= splashDmg;
        const tiso = toBattleIso(t.x, t.y);
        battleFloatingTexts.push({ x: tiso.x, y: tiso.y - 25, text: '-' + splashDmg, color: '#ffaa00', life: 40 });
      }
    }
  }

  // Check for deaths
  battle.enemyUnits = battle.enemyUnits.filter(u => u.hp > 0);
  battle.playerUnits = battle.playerUnits.filter(u => u.hp > 0);
  if (battle.enemyUnits.length === 0) { battleVictory(); return; }
  if (battle.playerUnits.length === 0) { battleDefeat(); return; }
}

// ═════ BATTLE RESOLUTION ═════
function battleVictory() {
  const ctx2 = battle.enemyContext;
  const def = ctx2.isFort ? ENEMY_TYPES.militant : ENEMY_TYPES[ctx2.type];

  // Return units to army: survivors keep HP, dead respawn at 50% max, then all heal 50% missing
  for (const t of TROOP_ORDER) {
    if (!Array.isArray(player.army[t])) player.army[t] = [];
    const maxHp = BATTLE_STATS[t].hp + upgrades.reinforced * 3;
    // Add surviving units with their current HP
    for (const u of battle.playerUnits) {
      if (u.type === t) player.army[t].push(u.hp);
    }
    // Add dead units at 50% HP (respawn)
    const deployed = (battle.deployedSnapshot[t] || []).length;
    const survived = battle.playerUnits.filter(u => u.type === t).length;
    const dead = deployed - survived;
    for (let i = 0; i < dead; i++) player.army[t].push(Math.ceil(maxHp * 0.5));
    // Partial heal: all units heal 50% of missing HP
    for (let i = 0; i < player.army[t].length; i++) {
      const hp = player.army[t][i];
      player.army[t][i] = Math.min(maxHp, hp + Math.ceil((maxHp - hp) * 0.5));
    }
  }

  // Morale boost
  morale = Math.min(5, morale + 1);

  // Rewards
  const goldReward = Math.floor(ctx2.str * (def.goldMul || 0.3)) + randInt(2, 6);
  gold += goldReward;
  kills++;

  let capturedText = '';
  if (!ctx2.isFort) {
    const yieldType = def.yields || 'riflemen';
    const yieldDef = TROOP_TYPES[yieldType];
    const captureRate = Math.max(0.2, 0.4 - getDifficulty() * 0.02);
    const capturedCount = Math.max(1, Math.ceil(ctx2.str * captureRate / yieldDef.str));
    addTroops(player.army, yieldType, capturedCount);
    capturedText = '+' + capturedCount + ' ' + yieldDef.name;
    // Remove enemy from overworld
    const eIdx = ctx2.arr.indexOf(ctx2.arr[ctx2.index]);
    if (eIdx !== -1) ctx2.arr.splice(eIdx, 1);
  } else {
    // Fort capture — convert to player fort
    const gunCount = Math.max(1, Math.ceil(ctx2.str * 0.15 / TROOP_TYPES.gunners.str));
    const rifCount = Math.max(1, Math.ceil(ctx2.str * 0.1 / TROOP_TYPES.riflemen.str));
    addTroops(player.army, 'gunners', gunCount);
    addTroops(player.army, 'riflemen', rifCount);
    capturedText = '+' + gunCount + ' Gunners, +' + rifCount + ' Riflemen\nFort Captured!';
    const capturedFort = forts[ctx2.index];
    playerForts.push({ gx: capturedFort.x, gy: capturedFort.y, garrison: newArmy(), walls: 0, turrets: 0, mines: 0, isHome: false });
    forts.splice(ctx2.index, 1);
    recalcTerritory();
  }

  battle.resultMsg = 'VICTORY!\n+' + goldReward + ' gold\n' + capturedText +
    '\nAll troops recovered  Morale: ' + (morale > 0 ? '+' : '') + morale;
  gameMode = 'battle_result';

  spawnParticles(player.x, player.y, '#4fc3f7', 20, 5);
  updateHUD();

  // Check game win
  if (forts.length === 0) {
    setTimeout(() => { checkGameWin(); }, 500);
  }
}

function battleDefeat() {
  const ctx2 = battle.enemyContext;

  // Morale loss
  morale = Math.max(-5, morale - 1);

  // Return units to army: survivors keep HP, dead respawn at 50% max, then all heal 50% missing
  for (const t of TROOP_ORDER) {
    if (!Array.isArray(player.army[t])) player.army[t] = [];
    const maxHp = BATTLE_STATS[t].hp + upgrades.reinforced * 3;
    // Add surviving units with their current HP
    for (const u of battle.playerUnits) {
      if (u.type === t) player.army[t].push(u.hp);
    }
    // Add dead units at 50% HP (respawn)
    const deployed = (battle.deployedSnapshot[t] || []).length;
    const survived = battle.playerUnits.filter(u => u.type === t).length;
    const dead = deployed - survived;
    for (let i = 0; i < dead; i++) player.army[t].push(Math.ceil(maxHp * 0.5));
    // Partial heal: all units heal 50% of missing HP
    for (let i = 0; i < player.army[t].length; i++) {
      const hp = player.army[t][i];
      player.army[t][i] = Math.min(maxHp, hp + Math.ceil((maxHp - hp) * 0.5));
    }
  }

  // Reduce enemy str proportional to damage dealt
  const totalEnemyHp = battle.enemyUnits.reduce((s, u) => s + u.maxHp, 0);
  const remainingHp = battle.enemyUnits.reduce((s, u) => s + u.hp, 0);
  const dmgFraction = 1 - (remainingHp / totalEnemyHp);
  if (!ctx2.isFort) {
    const e = ctx2.arr[ctx2.index];
    if (e) e.str = Math.max(1, Math.ceil(e.str * (1 - dmgFraction)));
  }

  // Check if we lost a fort defense
  if (battle.turretBonus !== undefined) {
    // Was defending a fort — find which fort and destroy it
    const defFort = playerForts.findIndex(f => f.gx === player.x && f.gy === player.y);
    if (defFort !== -1) {
      const lostFort = playerForts[defFort];
      spawnFloatingText(lostFort.gx, lostFort.gy, 'Fort Lost!', '#f44336');
      playerForts.splice(defFort, 1);
      recalcTerritory();
    }
  }
  // Clear pending attacks for this battle
  pendingAttacks = pendingAttacks.filter(pa => !playerForts[pa.fortIndex] || playerForts[pa.fortIndex].gx !== player.x);

  // Push player back
  player.x = Math.max(1, Math.min(COLS - 2, player.x - player.lastDx));
  player.y = Math.max(1, Math.min(ROWS - 2, player.y - player.lastDy));
  playerVisual.x = player.x;
  playerVisual.y = player.y;

  let defeatMsg = 'DEFEAT!\nYour troops regroup and recover.\nMorale: ' + (morale > 0 ? '+' : '') + morale;
  if (battle.turretBonus !== undefined) defeatMsg += '\nFort destroyed by enemy!';
  battle.resultMsg = defeatMsg;
  gameMode = 'battle_result';
  shake = 6;
  updateHUD();
}

function handleResultClick() {
  gameMode = 'overworld';
  battle = null;
}

// ═════ DEPLOY PHASE ═════
function handleDeployClick(mx, my) {
  const panelY = H - PANEL_H;

  // Check if clicking army panel to select troop type
  if (my >= panelY) {
    const slotW = W / TROOP_ORDER.length;
    const slotIdx = Math.floor(mx / slotW);
    if (slotIdx >= 0 && slotIdx < TROOP_ORDER.length) {
      const type = TROOP_ORDER[slotIdx];
      if (battle.deployArmy[type] && battle.deployArmy[type].length > 0) {
        deploySelectedType = type;
      }
    }
    return;
  }

  // Check "Start Battle" button area (top right)
  if (mx >= W - 160 && mx <= W - 10 && my >= 10 && my <= 45 && battle.playerUnits.length > 0) {
    startBattle();
    return;
  }

  // Convert click to game-space (continuous, not snapped)
  const grid = fromBattleIso(mx, my);
  const gx = Math.round(grid.x * 2) / 2; // snap to 0.5 increments
  const gy = Math.round(grid.y * 2) / 2;
  if (gx < 0 || gx >= BCOLS || gy < 0 || gy >= BROWS) return;

  // Click on existing placed unit → pick it up (within 0.6 radius)
  const existIdx = battle.playerUnits.findIndex(u => getEuclidDist(u, {x:gx,y:gy}) < 0.6);
  if (existIdx !== -1) {
    const removed = battle.playerUnits.splice(existIdx, 1)[0];
    if (!Array.isArray(battle.deployArmy[removed.type])) battle.deployArmy[removed.type] = [];
    battle.deployArmy[removed.type].push(removed.persistentHp || removed.maxHp);
    return;
  }

  // Place unit in deployment zone (left third: x < 3)
  if (gx < 3 && deploySelectedType && battle.deployArmy[deploySelectedType] && battle.deployArmy[deploySelectedType].length > 0) {
    const gy2 = Math.floor(gy);
    if (gy2 >= 0 && gy2 < BROWS && battle.grid[gy2] && battle.grid[gy2][Math.floor(gx)] === 'wall') return;
    if (battle.playerUnits.some(u => getEuclidDist(u, {x:gx,y:gy}) < 0.5)) return;

    const stats = BATTLE_STATS[deploySelectedType];
    const persistHp = battle.deployArmy[deploySelectedType].pop();
    const baseMaxHp = stats.hp + upgrades.reinforced * 3;
    const unitHp = Math.min(persistHp, baseMaxHp);
    battle.playerUnits.push({
      type: deploySelectedType,
      hp: unitHp, maxHp: baseMaxHp, persistentHp: persistHp,
      atk: stats.atk + upgrades.armorPiercing + engineerATKBonus,
      range: stats.range + upgrades.extendedMag,
      aoe: stats.aoe + (['rpg','machinegun','bombers'].includes(deploySelectedType) ? upgrades.explosiveRounds : 0),
      heavy: false,
      x: gx, y: gy, vx: gx, vy: gy,
      moveSpeed: stats.moveSpeed, attackRate: stats.attackRate, attackCD: 0,
    });
    if (battle.deployArmy[deploySelectedType].length <= 0) deploySelectedType = null;
  }
}

// ═════ BATTLE PHASE INPUT (Simulation Controls) ═════
function handleBattleClick(mx, my) {
  // Speed buttons (top right area)
  // Pause/Play button: x=[W-155, W-100], y=[10, 38]
  if (mx >= W - 155 && mx <= W - 100 && my >= 10 && my <= 38) {
    battle.simPaused = !battle.simPaused;
    return;
  }
  // 1x button: x=[W-95, W-70], y=[10, 38]
  if (mx >= W - 95 && mx <= W - 70 && my >= 10 && my <= 38) {
    battle.simSpeed = 1; battle.simPaused = false;
    return;
  }
  // 2x button: x=[W-65, W-40], y=[10, 38]
  if (mx >= W - 65 && mx <= W - 40 && my >= 10 && my <= 38) {
    battle.simSpeed = 2; battle.simPaused = false;
    return;
  }
  // 4x button: x=[W-35, W-10], y=[10, 38]
  if (mx >= W - 35 && mx <= W - 10 && my >= 10 && my <= 38) {
    battle.simSpeed = 4; battle.simPaused = false;
    return;
  }
}

// (Old turn-based AI removed — replaced by updateRealTimeBattle)

// ═════ BATTLE SMOOTH ANIMATION ═════
function updateBattleSmooth() {
  if (!battle) return;
  const spd = 0.25;

  // Lerp unit visual positions toward actual positions
  const _allUnits = battle.playerUnits.concat(battle.enemyUnits);
  for (const u of _allUnits) {
    if (u.vx === undefined) { u.vx = u.x; u.vy = u.y; }
    u.vx += (u.x - u.vx) * spd;
    u.vy += (u.y - u.vy) * spd;
    if (Math.abs(u.x - u.vx) < 0.01) u.vx = u.x;
    if (Math.abs(u.y - u.vy) < 0.01) u.vy = u.y;
  }

  // Update battle particles
  for (let i = battleParticles.length - 1; i >= 0; i--) {
    const p = battleParticles[i];
    p.x += p.vx; p.y += p.vy;
    p.vy += 0.15;
    p.vx *= 0.97;
    p.life--;
    if (p.life <= 0) battleParticles.splice(i, 1);
  }

  // Update battle floating texts
  for (let i = battleFloatingTexts.length - 1; i >= 0; i--) {
    const ft = battleFloatingTexts[i];
    ft.y -= 0.6;
    ft.life--;
    if (ft.life <= 0) battleFloatingTexts.splice(i, 1);
  }

  // Shake
  if (shake > 0) shake *= 0.88;
  if (shake < 0.3) shake = 0;

  // Real-time battle simulation (runs every frame when not paused)
  if (gameMode === 'battle') {
    const steps = battle.simSpeed || 1;
    for (let s = 0; s < steps; s++) {
      updateRealTimeBattle();
      updateProjectiles();
    }
  }
}

// ═════ BATTLE RENDERING ═════
function drawBattle() {
  if (!battle) return;

  const shx = shake > 0.1 ? (Math.random() - 0.5) * shake : 0;
  const shy = shake > 0.1 ? (Math.random() - 0.5) * shake : 0;
  ctx.save();
  ctx.translate(shx, shy);

  ctx.fillStyle = '#0a0e14';
  ctx.fillRect(0, 0, W, H);

  // Draw terrain backdrop (no grid lines, just ground tiles)
  for (let sum = 0; sum < BCOLS + BROWS - 1; sum++) {
    for (let x = Math.max(0, sum - (BROWS - 1)); x <= Math.min(BCOLS - 1, sum); x++) {
      const y = sum - x;
      if (y < 0 || y >= BROWS) continue;
      const iso = toBattleIso(x, y);
      const tileType = battle.grid[y][x];

      if (tileType === 'wall') {
        drawWall(iso.x, iso.y, x, y);
      } else {
        drawGround(iso.x, iso.y, (x * 7 + y * 13) % 100 / 100, x, y);
      }

      // Deployment zone highlight
      if (gameMode === 'deploy' && x < 3 && tileType !== 'wall') {
        ctx.fillStyle = 'rgba(79,195,247,0.1)';
        isoDiamondPath(iso.x, iso.y);
        ctx.fill();
        ctx.strokeStyle = 'rgba(79,195,247,0.25)';
        ctx.lineWidth = 1;
        isoDiamondPath(iso.x, iso.y);
        ctx.stroke();
      }
    }
  }

  // Collect all alive units and sort by vy for painter's algorithm
  const allUnits = [];
  for (const u of battle.playerUnits) {
    if (u.hp > 0) allUnits.push({ unit: u, isPlayer: true });
  }
  for (const u of battle.enemyUnits) {
    if (u.hp > 0) allUnits.push({ unit: u, isPlayer: false });
  }
  allUnits.sort((a, b) => (a.unit.vy + a.unit.vx) - (b.unit.vy + b.unit.vx));

  // Draw projectiles
  for (const p of battleProjectiles) {
    if (p.delay > 0) continue;
    const piso = toBattleIso(p.x, p.y);
    const sx = piso.x, sy = piso.y;
    const alpha = Math.min(1, p.life / 10);
    ctx.globalAlpha = alpha;
    if (p.type === 'flame') {
      ctx.fillStyle = '#ff9800';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 4, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ffeb3b';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 2, 0, Math.PI * 2); ctx.fill();
    } else if (p.type === 'heal') {
      const tu = p.targetUnit;
      const tiso = toBattleIso(tu && tu.hp > 0 ? tu.vx : p.tx, tu && tu.hp > 0 ? tu.vy : p.ty);
      ctx.strokeStyle = '#66bb6a'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(sx, sy - 8); ctx.lineTo(tiso.x, tiso.y - 8); ctx.stroke();
      ctx.fillStyle = '#a5d6a7';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 2 + Math.random(), 0, Math.PI * 2); ctx.fill();
    } else if (p.type === 'rocket') {
      ctx.fillStyle = '#ff6600';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ffcc00';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 1.5, 0, Math.PI * 2); ctx.fill();
    } else if (p.type === 'shell') {
      ctx.fillStyle = '#555';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 3.5, 0, Math.PI * 2); ctx.fill();
    } else if (p.type === 'bomb') {
      const progress = 1 - (p.life / 60);
      const arcHeight = Math.sin(progress * Math.PI) * 30;
      ctx.fillStyle = '#333';
      ctx.beginPath(); ctx.arc(sx, sy - 8 - arcHeight, 4, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ff4444';
      ctx.beginPath(); ctx.arc(sx, sy - 8 - arcHeight, 1.5, 0, Math.PI * 2); ctx.fill();
    } else if (p.type === 'mg_burst') {
      ctx.fillStyle = '#ffee88';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 1.5, 0, Math.PI * 2); ctx.fill();
    } else if (p.type === 'laser') {
      // Purple beam
      ctx.strokeStyle = '#ce93d8'; ctx.lineWidth = 2;
      const tdx = p.tx - p.x, tdy = p.ty - p.y;
      const tlen = Math.sqrt(tdx*tdx + tdy*tdy) || 1;
      ctx.beginPath(); ctx.moveTo(sx, sy - 8);
      ctx.lineTo(sx - (tdx/tlen)*6, sy - 8 - (tdy/tlen)*6); ctx.stroke();
      ctx.fillStyle = '#e1bee7';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 2, 0, Math.PI * 2); ctx.fill();
    } else if (p.type === 'fist') {
      // Green melee swipe
      ctx.fillStyle = '#76ff03';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#33691e';
      ctx.beginPath(); ctx.arc(sx, sy - 8, 1.5, 0, Math.PI * 2); ctx.fill();
    } else {
      // Default bullet line
      const dx = p.tx - p.x, dy = p.ty - p.y;
      const len = Math.sqrt(dx * dx + dy * dy) || 1;
      ctx.strokeStyle = p.color || '#ffee88'; ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(sx, sy - 8);
      ctx.lineTo(sx - (dx / len) * 4, sy - 8 - (dy / len) * 4);
      ctx.stroke();
    }
  }
  ctx.globalAlpha = 1;

  // Draw all units y-sorted
  for (const entry of allUnits) {
    const u = entry.unit;
    const iso = toBattleIso(u.vx, u.vy);
    drawBattleUnit(u, iso.x, iso.y, entry.isPlayer, false);
  }

  // Battle particles
  for (const p of battleParticles) {
    const alpha = p.life / (p.maxLife || 20);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(p.x, p.y, (p.size || 2) * alpha, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Battle floating texts
  for (const ft of battleFloatingTexts) {
    const alpha = Math.min(1, ft.life / 20);
    ctx.globalAlpha = alpha;
    ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillText(ft.text, ft.x + 1, ft.y + 1);
    ctx.fillStyle = ft.color; ctx.fillText(ft.text, ft.x, ft.y);
  }
  ctx.globalAlpha = 1;

  // ── TOP UI BAR ──
  ctx.fillStyle = 'rgba(10,14,20,0.85)';
  ctx.fillRect(0, 0, W, 50);
  ctx.fillStyle = '#3a4a6a'; ctx.fillRect(0, 50, W, 1);

  ctx.font = 'bold 16px "Segoe UI", sans-serif'; ctx.textAlign = 'center';
  if (gameMode === 'deploy') {
    ctx.fillStyle = '#4fc3f7';
    ctx.fillText('DEPLOY YOUR TROOPS', W / 2, 25);
    ctx.font = '11px sans-serif'; ctx.fillStyle = '#8899aa';
    ctx.fillText('Click troop in panel below, then click deployment zone (blue). Press ESC to cancel.', W / 2, 42);
  } else if (gameMode === 'battle') {
    const pauseText = battle.simPaused ? ' [PAUSED]' : '';
    const pAlive = battle.playerUnits.filter(u => u.hp > 0).length;
    const eAlive = battle.enemyUnits.filter(u => u.hp > 0).length;
    ctx.fillStyle = '#4fc3f7';
    ctx.fillText('BATTLE \u2014 ' + pAlive + ' vs ' + eAlive + pauseText, W / 2, 25);
    ctx.font = '11px sans-serif'; ctx.fillStyle = '#8899aa';
    ctx.fillText('Space = Pause/Resume    1/2/3 = Speed', W / 2, 42);
  } else if (gameMode === 'battle_result') {
    ctx.fillStyle = battle.resultMsg.startsWith('VICTORY') ? '#4caf50' : '#ff5252';
    ctx.fillText(battle.resultMsg.split('\n')[0], W / 2, 25);
    ctx.font = '11px sans-serif'; ctx.fillStyle = '#aabbcc';
    ctx.fillText('Click anywhere to continue', W / 2, 42);
  }

  // Start Battle button
  if (gameMode === 'deploy' && battle.playerUnits.length > 0) {
    const bx = W - 160, bw = 150, bh = 30, by2 = 12;
    ctx.fillStyle = '#2e7d32';
    ctx.fillRect(bx, by2, bw, bh);
    ctx.strokeStyle = '#4caf50'; ctx.lineWidth = 1; ctx.strokeRect(bx, by2, bw, bh);
    ctx.fillStyle = '#fff'; ctx.font = 'bold 13px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('START BATTLE (' + battle.playerUnits.length + ')', bx + bw / 2, by2 + 20);
  }
  if (gameMode === 'battle') {
    // Pause/Play button
    const pbx = W - 155, pbw = 50, pbh = 28, pby = 10;
    ctx.fillStyle = battle.simPaused ? '#e65100' : '#1565c0';
    ctx.fillRect(pbx, pby, pbw, pbh);
    ctx.strokeStyle = battle.simPaused ? '#ff9800' : '#42a5f5'; ctx.lineWidth = 1;
    ctx.strokeRect(pbx, pby, pbw, pbh);
    ctx.fillStyle = '#fff'; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText(battle.simPaused ? '\u25B6' : '\u275A\u275A', pbx + pbw / 2, pby + 19);
    // Speed buttons: 1x, 2x, 4x
    const speeds = [1, 2, 4];
    const labels = ['1x', '2x', '4x'];
    for (let si = 0; si < 3; si++) {
      const sbx = W - 95 + si * 30, sbw = 25;
      const active = battle.simSpeed === speeds[si];
      ctx.fillStyle = active ? '#2e7d32' : '#263238';
      ctx.fillRect(sbx, pby, sbw, pbh);
      ctx.strokeStyle = active ? '#4caf50' : '#455a64'; ctx.lineWidth = 1;
      ctx.strokeRect(sbx, pby, sbw, pbh);
      ctx.fillStyle = active ? '#fff' : '#8899aa'; ctx.font = 'bold 10px sans-serif';
      ctx.fillText(labels[si], sbx + sbw / 2, pby + 19);
    }
  }

  // ── BOTTOM PANEL ──
  if (gameMode === 'deploy') {
    drawDeployPanel();
  } else if (gameMode === 'battle') {
    drawBattleInfoPanel();
  } else if (gameMode === 'battle_result') {
    drawBattleResultPanel();
  }

  ctx.restore();
}

function drawBattleUnit(unit, sx, sy, isPlayer, selected) {
  const bob = Math.sin(animFrame * 0.1 + unit.x * 3) * 1;
  const cy = sy - 10 + bob;

  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.ellipse(sx + 2, sy + 4, 8, 3, 0.1, 0, Math.PI * 2); ctx.fill();

  // Team base circle
  const baseColor = isPlayer ? 'rgba(30,120,200,0.5)' : 'rgba(200,50,50,0.5)';
  ctx.fillStyle = baseColor;
  ctx.beginPath(); ctx.ellipse(sx, sy + 2, 10, 5, 0, 0, Math.PI * 2); ctx.fill();

  // Selected highlight
  if (selected) {
    const selPulse = 0.4 + Math.sin(animFrame * 0.12) * 0.2;
    ctx.strokeStyle = 'rgba(79,195,247,' + selPulse + ')';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.ellipse(sx, sy + 2, 12, 6, 0, 0, Math.PI * 2); ctx.stroke();
  }

  // Unit attacking glow (fires when attackCD is low)
  if (battle && unit.attackCD !== undefined && unit.attackCD <= 5) {
    const glowPulse = 0.4 + Math.sin(animFrame * 0.2) * 0.3;
    const glowColor = isPlayer ? 'rgba(79,195,247,' : 'rgba(255,80,80,';
    ctx.strokeStyle = glowColor + glowPulse + ')';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.ellipse(sx, sy + 2, 13, 6, 0, 0, Math.PI * 2); ctx.stroke();
  }

  // Draw unit body (simplified sprites based on type)
  const def = isPlayer ? BATTLE_STATS[unit.type] : ENEMY_BATTLE_STATS[unit.type];
  const enemyDef = !isPlayer ? ENEMY_TYPES[unit.type] : null;
  const color = isPlayer ? '#4caf50' : (enemyDef ? enemyDef.color : '#e53935');
  const dark = isPlayer ? '#2e7d32' : (enemyDef ? enemyDef.dark : '#b71c1c');

  if (unit.type === 'mutant') {
    // Large green muscular creature
    ctx.fillStyle = dark; ctx.fillRect(sx - 5, cy + 2, 4, 6); ctx.fillRect(sx + 1, cy + 2, 4, 6);
    ctx.fillStyle = color; ctx.fillRect(sx - 7, cy - 6, 14, 10);
    ctx.fillStyle = dark; ctx.fillRect(sx - 10, cy - 4, 5, 8); ctx.fillRect(sx + 5, cy - 4, 5, 8);
    ctx.fillStyle = '#689f38'; ctx.beginPath(); ctx.arc(sx, cy - 9, 3.5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#ffff00';
    ctx.beginPath(); ctx.arc(sx - 1.5, cy - 9, 1, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(sx + 1.5, cy - 9, 1, 0, Math.PI * 2); ctx.fill();
    const gp = 0.2 + Math.sin(animFrame * 0.15) * 0.15;
    ctx.fillStyle = 'rgba(255,255,0,' + gp + ')';
    ctx.beginPath(); ctx.arc(sx, cy - 9, 5, 0, Math.PI * 2); ctx.fill();
  } else if (unit.type === 'mad_scientist') {
    // Lab coat scientist
    ctx.fillStyle = '#333'; ctx.fillRect(sx - 3, cy + 3, 2.5, 5); ctx.fillRect(sx + 0.5, cy + 3, 2.5, 5);
    ctx.fillStyle = '#e8e8e8'; ctx.fillRect(sx - 5, cy - 4, 10, 9);
    ctx.fillStyle = '#e0e0e0'; ctx.fillRect(sx - 8, cy - 2, 4, 7); ctx.fillRect(sx + 4, cy - 2, 4, 7);
    ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(sx, cy - 7, 3.5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#6a1b9a';
    ctx.beginPath(); ctx.arc(sx - 2, cy - 11, 2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(sx + 2, cy - 11, 2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(sx, cy - 12, 1.5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#76ff03';
    ctx.beginPath(); ctx.arc(sx - 1.5, cy - 7.5, 1.3, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(sx + 1.5, cy - 7.5, 1.3, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#4caf50'; ctx.beginPath(); ctx.moveTo(sx + 6, cy + 2); ctx.lineTo(sx + 5, cy - 1);
    ctx.lineTo(sx + 9, cy - 1); ctx.closePath(); ctx.fill();
  } else if (unit.type === 'apc') {
    // Vehicle body
    ctx.fillStyle = dark; ctx.fillRect(sx - 12, cy - 2, 24, 10);
    ctx.fillStyle = color; ctx.fillRect(sx - 11, cy - 1, 22, 8);
    ctx.fillStyle = '#333'; ctx.fillRect(sx - 2, cy - 6, 4, 5); // turret
    ctx.fillStyle = '#444'; ctx.fillRect(sx + 2, cy - 5, 8, 1.5); // barrel
    // Wheels
    ctx.fillStyle = '#222';
    ctx.beginPath(); ctx.arc(sx - 7, cy + 7, 2.5, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(sx + 7, cy + 7, 2.5, 0, Math.PI * 2); ctx.fill();
  } else if (unit.type === 'helicopter') {
    // Heli body
    ctx.fillStyle = dark;
    ctx.beginPath(); ctx.moveTo(sx - 10, cy); ctx.lineTo(sx - 5, cy - 6);
    ctx.lineTo(sx + 6, cy - 6); ctx.lineTo(sx + 8, cy);
    ctx.lineTo(sx + 6, cy + 4); ctx.lineTo(sx - 8, cy + 4); ctx.closePath(); ctx.fill();
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.moveTo(sx - 8, cy + 1); ctx.lineTo(sx - 3, cy - 4);
    ctx.lineTo(sx + 4, cy - 4); ctx.lineTo(sx + 6, cy + 1);
    ctx.lineTo(sx + 4, cy + 3); ctx.lineTo(sx - 6, cy + 3); ctx.closePath(); ctx.fill();
    // Rotor
    const rSpin = animFrame * 0.3;
    ctx.strokeStyle = 'rgba(150,150,150,0.6)'; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(sx + Math.cos(rSpin) * 12, cy - 7 + Math.sin(rSpin) * 2);
    ctx.lineTo(sx - Math.cos(rSpin) * 12, cy - 7 - Math.sin(rSpin) * 2); ctx.stroke();
  } else if (unit.type === 'tanks') {
    // Tank body
    ctx.fillStyle = dark; ctx.fillRect(sx - 10, cy, 20, 8);
    ctx.fillStyle = color; ctx.fillRect(sx - 9, cy + 1, 18, 6);
    ctx.fillStyle = dark; ctx.fillRect(sx - 4, cy - 5, 8, 6); // turret
    ctx.fillStyle = '#444'; ctx.fillRect(sx + 4, cy - 4, 10, 2); // barrel
    // Treads
    ctx.fillStyle = '#222'; ctx.fillRect(sx - 10, cy + 7, 20, 2);
  } else if (unit.type === 'bombers') {
    // Aircraft shape
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.moveTo(sx - 8, cy); ctx.lineTo(sx, cy - 8);
    ctx.lineTo(sx + 8, cy); ctx.lineTo(sx, cy + 3); ctx.closePath(); ctx.fill();
    // Wings
    ctx.fillStyle = dark;
    ctx.beginPath(); ctx.moveTo(sx - 3, cy - 2); ctx.lineTo(sx - 14, cy + 2);
    ctx.lineTo(sx - 3, cy + 1); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(sx + 3, cy - 2); ctx.lineTo(sx + 14, cy + 2);
    ctx.lineTo(sx + 3, cy + 1); ctx.closePath(); ctx.fill();
  } else {
    // Humanoid soldier (riflemen, snipers, machinegun, gunners, rpg, militant, commando, sniper_e)
    // Legs
    ctx.fillStyle = dark;
    ctx.fillRect(sx - 3, cy + 2, 2.5, 6); ctx.fillRect(sx + 0.5, cy + 2, 2.5, 6);
    // Body
    ctx.fillStyle = color; ctx.fillRect(sx - 5, cy - 4, 10, 8);
    // Head
    ctx.fillStyle = '#dbb896'; ctx.beginPath(); ctx.arc(sx, cy - 8, 4, 0, Math.PI * 2); ctx.fill();
    // Helmet/headwear
    ctx.fillStyle = dark;
    ctx.beginPath(); ctx.arc(sx, cy - 10, 4, Math.PI, 0); ctx.fill();
    ctx.fillRect(sx - 4, cy - 11, 8, 3);
    // Weapon
    ctx.fillStyle = '#333';
    if (unit.type === 'medic') {
      // White cross on body instead of weapon
      ctx.fillStyle = '#fff'; ctx.fillRect(sx - 1, cy - 4, 2, 6); ctx.fillRect(sx - 3, cy - 2, 6, 2);
      // Small sidearm
      ctx.fillStyle = '#555'; ctx.fillRect(sx + 4, cy - 1, 4, 1.5);
    } else if (unit.type === 'flamethrower') {
      // Fuel tank on back + nozzle with flame
      ctx.fillStyle = '#4e342e'; ctx.fillRect(sx - 8, cy - 3, 4, 7);
      ctx.fillStyle = '#333'; ctx.fillRect(sx + 4, cy - 3, 8, 2);
      ctx.fillStyle = '#ff9800'; ctx.beginPath(); ctx.arc(sx + 13, cy - 2, 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ffeb3b'; ctx.beginPath(); ctx.arc(sx + 13, cy - 2, 1.5, 0, Math.PI * 2); ctx.fill();
    } else if (unit.type === 'operative') {
      // Suppressed weapon
      ctx.fillRect(sx + 4, cy - 3, 7, 1.5);
      ctx.fillStyle = '#555'; ctx.fillRect(sx + 10, cy - 3.5, 4, 2); // suppressor
    } else if (unit.type === 'snipers' || unit.type === 'sniper_e') {
      ctx.fillRect(sx + 4, cy - 4, 12, 1.5);
    } else if (unit.type === 'rpg') {
      ctx.fillRect(sx + 4, cy - 3, 10, 2);
      ctx.fillStyle = '#666'; ctx.fillRect(sx + 12, cy - 4, 3, 3);
    } else if (unit.type === 'machinegun') {
      ctx.fillRect(sx + 4, cy - 3, 10, 2);
      ctx.fillStyle = '#444'; ctx.fillRect(sx + 2, cy + 1, 3, 4); // ammo box
    } else {
      ctx.fillRect(sx + 4, cy - 3, 8, 1.5); // rifle
    }
    // Eyes
    ctx.fillStyle = '#111';
    ctx.fillRect(sx - 2, cy - 9, 1.5, 1.5); ctx.fillRect(sx + 1, cy - 9, 1.5, 1.5);
  }

  ctx.globalAlpha = 1;

  // Burning effect
  if (unit.burning && unit.burning > 0) {
    for (let fi = 0; fi < 2; fi++) {
      const fx = sx + (Math.random() - 0.5) * 12;
      const fy = cy - 2 + (Math.random() - 0.5) * 10;
      const fs = 2 + Math.random() * 2;
      ctx.fillStyle = Math.random() > 0.5 ? '#ff9800' : '#ffeb3b';
      ctx.globalAlpha = 0.5 + Math.random() * 0.4;
      ctx.beginPath(); ctx.arc(fx, fy, fs, 0, Math.PI * 2); ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // Health bar
  const hpFrac = unit.hp / unit.maxHp;
  const barW = 16, barH = 3;
  const barX = sx - barW / 2, barY = cy - 16;
  ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(barX - 1, barY - 1, barW + 2, barH + 2);
  ctx.fillStyle = hpFrac > 0.5 ? '#4caf50' : (hpFrac > 0.25 ? '#ff9800' : '#f44336');
  ctx.fillRect(barX, barY, barW * hpFrac, barH);
  ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 0.5;
  ctx.strokeRect(barX, barY, barW, barH);

  // Type label
  const typeName = (isPlayer ? BATTLE_STATS[unit.type]?.name : ENEMY_TYPES[unit.type]?.name) || unit.type;
  ctx.font = '7px sans-serif'; ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.fillText(typeName, sx, cy + 16);
}

function drawDeployPanel() {
  const panelY = H - PANEL_H;
  const panelGrad = ctx.createLinearGradient(0, panelY, 0, panelY + PANEL_H);
  panelGrad.addColorStop(0, '#161e30'); panelGrad.addColorStop(1, '#0a1018');
  ctx.fillStyle = panelGrad;
  ctx.fillRect(0, panelY, W, PANEL_H);
  ctx.fillStyle = '#3a4a6a'; ctx.fillRect(0, panelY, W, 1);

  const slotW = W / TROOP_ORDER.length;
  for (let i = 0; i < TROOP_ORDER.length; i++) {
    const type = TROOP_ORDER[i];
    const td = TROOP_TYPES[type];
    const count = Array.isArray(battle.deployArmy[type]) ? battle.deployArmy[type].length : 0;
    const cx = slotW * i + slotW / 2;
    const cy = panelY + PANEL_H / 2;

    // Selected highlight
    if (deploySelectedType === type) {
      ctx.fillStyle = 'rgba(79,195,247,0.15)';
      ctx.fillRect(slotW * i, panelY + 2, slotW, PANEL_H - 2);
      ctx.strokeStyle = '#4fc3f7'; ctx.lineWidth = 1;
      ctx.strokeRect(slotW * i + 1, panelY + 3, slotW - 2, PANEL_H - 4);
    }

    // Draw mini troop
    drawMiniTroop(slotW * i + 18, cy - 6, type, td);

    // Count
    ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center';
    ctx.fillStyle = count > 0 ? td.color : '#555';
    ctx.fillText(count, cx + 15, cy - 4);

    // Name
    ctx.font = '8px sans-serif'; ctx.fillStyle = '#8899aa';
    ctx.fillText(td.name, cx, cy + 16);

    // Divider
    if (i < TROOP_ORDER.length - 1) {
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      ctx.fillRect(slotW * (i + 1), panelY + 6, 1, PANEL_H - 12);
    }
  }
}

function drawBattleInfoPanel() {
  const panelY = H - PANEL_H;
  const panelGrad = ctx.createLinearGradient(0, panelY, 0, panelY + PANEL_H);
  panelGrad.addColorStop(0, '#161e30'); panelGrad.addColorStop(1, '#0a1018');
  ctx.fillStyle = panelGrad;
  ctx.fillRect(0, panelY, W, PANEL_H);
  ctx.fillStyle = '#3a4a6a'; ctx.fillRect(0, panelY, W, 1);

  ctx.textAlign = 'left';
  // Show alive unit counts
  const pAlive = battle.playerUnits.filter(u => u.hp > 0).length;
  const eAlive = battle.enemyUnits.filter(u => u.hp > 0).length;
  ctx.font = '11px sans-serif'; ctx.fillStyle = '#4fc3f7';
  ctx.fillText('Allies: ' + pAlive + '/' + battle.playerUnits.length, 15, panelY + 18);
  ctx.fillStyle = '#ff5252';
  ctx.fillText('Enemies: ' + eAlive + '/' + battle.enemyUnits.length, 15, panelY + 35);

  // Total HP bars
  const pHP = battle.playerUnits.reduce((s, u) => s + Math.max(0, u.hp), 0);
  const pMaxHP = battle.playerUnits.reduce((s, u) => s + u.maxHp, 0);
  const eHP = battle.enemyUnits.reduce((s, u) => s + Math.max(0, u.hp), 0);
  const eMaxHP = battle.enemyUnits.reduce((s, u) => s + u.maxHp, 0);
  // Player HP bar
  const barX = 130, barW = 120, barH = 6;
  ctx.fillStyle = '#1a1a2e'; ctx.fillRect(barX, panelY + 12, barW, barH);
  ctx.fillStyle = '#4fc3f7'; ctx.fillRect(barX, panelY + 12, barW * (pMaxHP > 0 ? pHP / pMaxHP : 0), barH);
  ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 0.5; ctx.strokeRect(barX, panelY + 12, barW, barH);
  // Enemy HP bar
  ctx.fillStyle = '#1a1a2e'; ctx.fillRect(barX, panelY + 29, barW, barH);
  ctx.fillStyle = '#ff5252'; ctx.fillRect(barX, panelY + 29, barW * (eMaxHP > 0 ? eHP / eMaxHP : 0), barH);
  ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.strokeRect(barX, panelY + 29, barW, barH);

  // Morale on center-right
  ctx.textAlign = 'center'; ctx.font = '10px sans-serif';
  const moralePct = Math.round(morale * 8);
  const moraleColor = morale > 0 ? '#4caf50' : (morale < 0 ? '#f44336' : '#888');
  ctx.fillStyle = moraleColor;
  ctx.fillText('Morale: ' + (morale > 0 ? '+' : '') + morale +
    (morale !== 0 ? ' (' + (moralePct > 0 ? '+' : '') + moralePct + '% DMG)' : ''), W / 2 + 100, panelY + 25);

  // Speed info on right (no turns)
  ctx.textAlign = 'right'; ctx.font = '11px sans-serif'; ctx.fillStyle = '#8899aa';
  ctx.fillText('Speed: ' + battle.simSpeed + 'x' +
    (battle.simPaused ? '  PAUSED' : ''), W - 15, panelY + 25);
  ctx.textAlign = 'left';
}

function drawBattleResultPanel() {
  const panelY = H - PANEL_H;
  ctx.fillStyle = '#0a1018';
  ctx.fillRect(0, panelY, W, PANEL_H);
  ctx.fillStyle = '#3a4a6a'; ctx.fillRect(0, panelY, W, 1);

  // Result text
  const lines = battle.resultMsg.split('\n');
  ctx.textAlign = 'center';
  for (let i = 0; i < lines.length; i++) {
    ctx.font = i === 0 ? 'bold 14px sans-serif' : '11px sans-serif';
    ctx.fillStyle = i === 0 ? (battle.resultMsg.startsWith('VICTORY') ? '#4caf50' : '#ff5252') : '#aabbcc';
    ctx.fillText(lines[i], W / 2, panelY + 15 + i * 14);
  }
}

// ═══════════════════════════════════════════
//  SETTLERS MODE - COMPLETE IMPLEMENTATION
// ═══════════════════════════════════════════

// --- SETTLERS CONSTANTS ---
const SETT_RESOURCES = ['wood', 'stone', 'iron', 'gold', 'meat', 'crops'];
const SETT_RESOURCE_DEFS = {
  wood:  { name: 'Wood',  color: '#8d6e63', icon: 'W' },
  stone: { name: 'Stone', color: '#90a4ae', icon: 'S' },
  iron:  { name: 'Iron',  color: '#78909c', icon: 'I' },
  gold:  { name: 'Gold',  color: '#ffd54f', icon: 'G' },
  meat:  { name: 'Meat',  color: '#ef5350', icon: 'M' },
  crops: { name: 'Crops', color: '#66bb6a', icon: 'C' },
};

const SETT_CHUNK_SIZE = 16;
const SETT_MAX_CHUNKS = 16;

// Building definitions with 3 upgrade levels
const SETT_BUILDING_DEFS = {
  house: {
    name: 'House', category: 'infrastructure', workers: 0, requiresAdj: null,
    levels: [
      { cost: { wood: 10, stone: 5 }, buildTime: 3, popCap: 4 },
      { cost: { wood: 15, stone: 10 }, buildTime: 5, popCap: 6 },
      { cost: { wood: 25, stone: 15, iron: 5 }, buildTime: 7, popCap: 8 },
    ]
  },
  farm: {
    name: 'Farm', category: 'production', workers: 2, requiresAdj: null,
    levels: [
      { cost: { wood: 8, stone: 2 }, buildTime: 4, production: { crops: 3 } },
      { cost: { wood: 12, stone: 5 }, buildTime: 6, production: { crops: 5 } },
      { cost: { wood: 20, stone: 8, iron: 3 }, buildTime: 8, production: { crops: 8 } },
    ]
  },
  lumbermill: {
    name: 'Lumbermill', category: 'production', workers: 2, requiresAdj: 'tree',
    levels: [
      { cost: { wood: 5, stone: 8 }, buildTime: 5, production: { wood: 3 } },
      { cost: { wood: 10, stone: 12 }, buildTime: 7, production: { wood: 5 } },
      { cost: { wood: 15, stone: 18, iron: 5 }, buildTime: 9, production: { wood: 8 } },
    ]
  },
  quarry: {
    name: 'Quarry', category: 'production', workers: 3, requiresAdj: 'wall',
    levels: [
      { cost: { wood: 10, iron: 2 }, buildTime: 6, production: { stone: 3 } },
      { cost: { wood: 15, iron: 5 }, buildTime: 8, production: { stone: 5 } },
      { cost: { wood: 25, iron: 10 }, buildTime: 10, production: { stone: 8 } },
    ]
  },
  mine: {
    name: 'Mine', category: 'production', workers: 3, requiresAdj: 'wall',
    levels: [
      { cost: { wood: 12, stone: 10 }, buildTime: 8, production: { iron: 2 } },
      { cost: { wood: 20, stone: 15 }, buildTime: 10, production: { iron: 4 } },
      { cost: { wood: 30, stone: 20, gold: 5 }, buildTime: 12, production: { iron: 6 } },
    ]
  },
  huntingLodge: {
    name: 'Hunting Lodge', category: 'production', workers: 2, requiresAdj: 'tree',
    levels: [
      { cost: { wood: 12, stone: 3 }, buildTime: 4, production: { meat: 2 } },
      { cost: { wood: 18, stone: 6 }, buildTime: 6, production: { meat: 4 } },
      { cost: { wood: 25, stone: 10, iron: 3 }, buildTime: 8, production: { meat: 6 } },
    ]
  },
  barracks: {
    name: 'Barracks', category: 'military', workers: 1, requiresAdj: null,
    levels: [
      { cost: { wood: 20, stone: 15, iron: 5 }, buildTime: 8, trainSpeed: 1 },
      { cost: { wood: 30, stone: 20, iron: 10 }, buildTime: 10, trainSpeed: 1.5 },
      { cost: { wood: 45, stone: 30, iron: 20 }, buildTime: 12, trainSpeed: 2 },
    ]
  },
  wall_seg: {
    name: 'Wall', category: 'defense', workers: 0, requiresAdj: null,
    levels: [
      { cost: { stone: 5 }, buildTime: 2, hp: 10, defense: 2 },
      { cost: { stone: 10, iron: 3 }, buildTime: 3, hp: 20, defense: 5 },
      { cost: { stone: 15, iron: 8 }, buildTime: 4, hp: 35, defense: 10 },
    ]
  },
  watchtower: {
    name: 'Watchtower', category: 'defense', workers: 1, requiresAdj: null,
    levels: [
      { cost: { wood: 15, stone: 10 }, buildTime: 5, visionRange: 4 },
      { cost: { wood: 20, stone: 15, iron: 5 }, buildTime: 7, visionRange: 6 },
      { cost: { wood: 30, stone: 20, iron: 10 }, buildTime: 9, visionRange: 8 },
    ]
  },
  market: {
    name: 'Market', category: 'economy', workers: 2, requiresAdj: null,
    levels: [
      { cost: { wood: 15, stone: 10, gold: 10 }, buildTime: 6, production: { gold: 2 }, tradeRatio: 4 },
      { cost: { wood: 25, stone: 15, gold: 20 }, buildTime: 8, production: { gold: 4 }, tradeRatio: 3 },
      { cost: { wood: 40, stone: 25, gold: 35 }, buildTime: 10, production: { gold: 6 }, tradeRatio: 2 },
    ]
  },
  blacksmith: {
    name: 'Blacksmith', category: 'military', workers: 2, requiresAdj: null,
    levels: [
      { cost: { wood: 10, stone: 12, iron: 8 }, buildTime: 7, atkBonus: 1, armorBonus: 0 },
      { cost: { wood: 20, stone: 20, iron: 15 }, buildTime: 9, atkBonus: 2, armorBonus: 1 },
      { cost: { wood: 35, stone: 30, iron: 25 }, buildTime: 11, atkBonus: 3, armorBonus: 2 },
    ]
  },
  warehouse: {
    name: 'Warehouse', category: 'infrastructure', workers: 0, requiresAdj: null,
    levels: [
      { cost: { wood: 20, stone: 15 }, buildTime: 5, storageCap: 50 },
      { cost: { wood: 30, stone: 20, iron: 5 }, buildTime: 7, storageCap: 100 },
      { cost: { wood: 45, stone: 30, iron: 10 }, buildTime: 9, storageCap: 200 },
    ]
  },
  hospital: {
    name: 'Hospital', category: 'infrastructure', workers: 2, requiresAdj: null,
    levels: [
      { cost: { wood: 15, stone: 10, crops: 5 }, buildTime: 6, healRate: 2 },
      { cost: { wood: 25, stone: 15, crops: 10 }, buildTime: 8, healRate: 4 },
      { cost: { wood: 40, stone: 25, crops: 15, iron: 5 }, buildTime: 10, healRate: 8 },
    ]
  },
  academy: {
    name: 'Academy', category: 'infrastructure', workers: 3, requiresAdj: null,
    levels: [
      { cost: { wood: 20, stone: 20, gold: 15 }, buildTime: 10, researchSpeed: 1 },
      { cost: { wood: 35, stone: 30, gold: 25 }, buildTime: 12, researchSpeed: 1.5 },
      { cost: { wood: 50, stone: 40, gold: 40, iron: 10 }, buildTime: 14, researchSpeed: 2 },
    ]
  },
  temple: {
    name: 'Temple', category: 'infrastructure', workers: 1, requiresAdj: null,
    levels: [
      { cost: { stone: 25, gold: 10 }, buildTime: 8, moraleBonus: 1 },
      { cost: { stone: 35, gold: 20 }, buildTime: 10, moraleBonus: 2 },
      { cost: { stone: 50, gold: 35, iron: 5 }, buildTime: 12, moraleBonus: 3 },
    ]
  },
  port: {
    name: 'Port', category: 'production', workers: 2, requiresAdj: 'water',
    levels: [
      { cost: { wood: 20, stone: 8 }, buildTime: 6, production: { meat: 3 } },
      { cost: { wood: 30, stone: 15, iron: 5 }, buildTime: 8, production: { meat: 5 } },
      { cost: { wood: 45, stone: 25, iron: 10 }, buildTime: 10, production: { meat: 8 } },
    ]
  },
};

// Tech tree
const SETT_TECH_TREE = {
  improvedTools:   { name: 'Improved Tools',   cost: { gold: 20, iron: 10 },  time: 15, effect: 'production_boost', value: 0.25, requires: [] },
  stoneMasonry:    { name: 'Stone Masonry',     cost: { gold: 15, stone: 15 }, time: 12, effect: 'wall_hp_boost', value: 2, requires: [] },
  ironWorking:     { name: 'Iron Working',      cost: { gold: 25, iron: 15 },  time: 20, effect: 'unlock_blacksmith', requires: [] },
  advancedFarming: { name: 'Advanced Farming',  cost: { gold: 20, crops: 10 }, time: 15, effect: 'farm_boost', value: 2, requires: ['improvedTools'] },
  militaryTactics: { name: 'Military Tactics',  cost: { gold: 30, iron: 10 },  time: 25, effect: 'unit_atk_boost', value: 1, requires: ['ironWorking'] },
  fortification:   { name: 'Fortification',     cost: { gold: 25, stone: 20 }, time: 20, effect: 'wall_def_boost', value: 3, requires: ['stoneMasonry'] },
  economics:       { name: 'Economics',         cost: { gold: 35 },            time: 20, effect: 'market_boost', value: 1, requires: [] },
  medicine:        { name: 'Medicine',          cost: { gold: 30, crops: 15 }, time: 18, effect: 'heal_boost', value: 2, requires: ['advancedFarming'] },
};

// Military units
const SETT_UNIT_TYPES = {
  militia:  { name: 'Militia',  cost: { gold: 5, wood: 5 },           trainTime: 3, str: 3,  hp: 8,  color: '#8d6e63', requires: null },
  spearman: { name: 'Spearman', cost: { gold: 8, iron: 3 },           trainTime: 4, str: 5,  hp: 12, color: '#5c6bc0', requires: null },
  archer:   { name: 'Archer',   cost: { gold: 10, wood: 5 },          trainTime: 5, str: 4,  hp: 6,  color: '#26a69a', requires: null },
  knight:   { name: 'Knight',   cost: { gold: 20, iron: 10 },         trainTime: 8, str: 10, hp: 20, color: '#546e7a', requires: 'militaryTactics' },
  catapult: { name: 'Catapult',  cost: { gold: 25, wood: 15, iron: 5 },trainTime: 10,str: 15, hp: 8,  color: '#ef6c00', requires: 'fortification' },
};

// Settlers raid enemy types (medieval themed)
const SETT_ENEMY_TYPES = {
  raider:   { name: 'Raider',   strMul: 0.8, color: '#b71c1c', yields: 'militia' },
  bandit:   { name: 'Bandit',   strMul: 1.2, color: '#4e342e', yields: 'spearman' },
  warlord:  { name: 'Warlord',  strMul: 2.0, color: '#311b92', yields: 'knight' },
};

// --- SETTLERS NOISE FUNCTION ---
function settNoise(x, y) {
  let n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
  return n - Math.floor(n);
}

// --- SETTLERS CHUNK SYSTEM ---
function settGetChunkKey(cx, cy) { return cx + ',' + cy; }

function settEnsureChunk(cx, cy) {
  const ckey = settGetChunkKey(cx, cy);
  if (sett.chunks[ckey]) return;
  const baseX = cx * SETT_CHUNK_SIZE;
  const baseY = cy * SETT_CHUNK_SIZE;
  for (let y = baseY; y < baseY + SETT_CHUNK_SIZE; y++) {
    if (!grassMap[y]) grassMap[y] = [];
    if (!treeMap[y]) treeMap[y] = [];
    if (!waterMap[y]) waterMap[y] = [];
    if (!pathMap[y]) pathMap[y] = [];
    if (!fogMap[y]) fogMap[y] = [];
    if (!territoryMap[y]) territoryMap[y] = [];
    for (let x = baseX; x < baseX + SETT_CHUNK_SIZE; x++) {
      const seed = settNoise(x, y);
      grassMap[y][x] = seed;
      treeMap[y][x] = seed > 0.55 && seed < 0.8;
      waterMap[y][x] = seed > 0.93;
      fogMap[y][x] = 0;
      pathMap[y][x] = false;
      territoryMap[y][x] = null;
      // Walls (rocks) for quarry/mine adjacency
      if (seed > 0.88 && seed <= 0.93) walls.add(k(baseX + (x - baseX), y));
    }
  }
  // Place enemies in outer chunks (farther from center = more)
  const distFromCenter = Math.abs(cx - Math.floor(sett.mapCenterX / SETT_CHUNK_SIZE)) + Math.abs(cy - Math.floor(sett.mapCenterY / SETT_CHUNK_SIZE));
  if (distFromCenter >= 2) {
    const numEnemies = randInt(0, Math.min(3, distFromCenter - 1));
    for (let i = 0; i < numEnemies; i++) {
      const ex = baseX + randInt(2, SETT_CHUNK_SIZE - 3);
      const ey = baseY + randInt(2, SETT_CHUNK_SIZE - 3);
      if (!walls.has(k(ex, ey)) && !(waterMap[ey] && waterMap[ey][ex])) {
        const str = 5 + distFromCenter * 4 + randInt(0, distFromCenter * 3);
        const types = Object.keys(SETT_ENEMY_TYPES);
        const etype = distFromCenter >= 4 ? types[randInt(0, 2)] : types[randInt(0, 1)];
        enemies.push({ x: ex, y: ey, str, type: etype, vx: ex, vy: ey, arrowCooldown: 0, patrol: 0, charged: false });
      }
    }
  }
  sett.chunks[ckey] = { generated: true, cx, cy };
}

function settExpandMapIfNeeded(px, py) {
  const cx = Math.floor(px / SETT_CHUNK_SIZE);
  const cy = Math.floor(py / SETT_CHUNK_SIZE);
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      const ncx = cx + dx, ncy = cy + dy;
      if (ncx >= 0 && ncy >= 0 && ncx < SETT_MAX_CHUNKS && ncy < SETT_MAX_CHUNKS) {
        settEnsureChunk(ncx, ncy);
      }
    }
  }
}

// --- SETTLERS INIT ---
function startSettlersMode() {
  document.getElementById('overlay').classList.remove('show');
  showOverlay('SETTLERS', 'Name your settlement, commander.', 'Begin', () => {
    appMode = 'settlers';
    sett = {
      resources: { wood: 30, stone: 20, iron: 0, gold: 10, meat: 5, crops: 10 },
      storageCap: { wood: 100, stone: 100, iron: 50, gold: 200, meat: 50, crops: 80 },
      population: 5,
      popCap: 10,
      idleWorkers: 3,
      buildings: [],
      nextBuildingId: 1,
      units: [],
      nextUnitId: 1,
      researched: {},
      currentResearch: null,
      chunks: {},
      mapCenterX: 50, mapCenterY: 50,
      raidTimer: 0,
      raidDifficulty: 1,
      turnCount: 0,
      settlementName: playerName || 'New Settlement',
      morale: 5,
      notifications: [],
      buildMode: false,
      buildSelected: null,
      buildGhost: null,
      camX: 50, camY: 50,
      training: [], // [{unitType, barracksId, progress, target}]
    };
    // Init map arrays fresh
    grassMap = []; treeMap = []; waterMap = []; pathMap = []; fogMap = []; territoryMap = [];
    walls = new Set();
    enemies = [];
    forts = [];
    allies = [];
    chests = [];
    mercCamps = [];
    overworldEngineers = [];
    playerForts = [];
    // Generate initial 3x3 chunks
    const ccx = Math.floor(sett.mapCenterX / SETT_CHUNK_SIZE);
    const ccy = Math.floor(sett.mapCenterY / SETT_CHUNK_SIZE);
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        settEnsureChunk(ccx + dx, ccy + dy);
      }
    }
    // Clear area around settlement center
    const cx = sett.mapCenterX, cy = sett.mapCenterY;
    for (let dy2 = -4; dy2 <= 4; dy2++) {
      for (let dx2 = -4; dx2 <= 4; dx2++) {
        const nx = cx + dx2, ny = cy + dy2;
        if (grassMap[ny]) {
          treeMap[ny][nx] = false;
          waterMap[ny][nx] = false;
          walls.delete(k(nx, ny));
        }
      }
    }
    // Place starting buildings (already built)
    const startHouse = settCreateBuilding('house', cx, cy - 1);
    startHouse.built = true; startHouse.buildProgress = startHouse.buildTarget; startHouse.hp = 10; startHouse.level = 1;
    const startFarm = settCreateBuilding('farm', cx + 2, cy);
    startFarm.built = true; startFarm.buildProgress = startFarm.buildTarget; startFarm.hp = 10; startFarm.level = 1;
    startFarm.workers = 2;
    sett.idleWorkers = 3; // 5 pop - 2 workers
    // Init player
    player = { x: cx, y: cy, army: newArmy(), lastDx: 1, lastDy: 0 };
    playerVisual = { x: cx, y: cy };
    sett.camX = cx; sett.camY = cy;
    camX = cx; camY = cy;
    // Reveal fog
    settRevealAround(cx, cy, 6);
    // Particles and state reset
    particles = []; floatingTexts = []; ambientParticles = [];
    moveQueue = []; isAnimating = false;
    followerTrail = []; followerVisuals = [];
    settRecalcTerritory();
    gameMode = 'overworld';
    settUpdateHUD();
    settUpdateControls();
    minimapDirty = true;
    msg('Welcome to ' + sett.settlementName + '! Press B to build.');
  }, true);
}

// --- SETTLERS BUILDING CORE ---
function settCreateBuilding(type, gx, gy) {
  const def = SETT_BUILDING_DEFS[type];
  const lv = def.levels[0];
  const b = {
    id: sett.nextBuildingId++,
    type, gx, gy,
    level: 0, // 0 = building level 1 when built
    workers: 0,
    built: false,
    buildProgress: 0,
    buildTarget: lv.buildTime,
    upgrading: false,
    hp: 0,
    maxHp: type === 'wall_seg' ? (lv.hp || 10) : 10,
  };
  sett.buildings.push(b);
  return b;
}

function settCanBuild(type, gx, gy) {
  const def = SETT_BUILDING_DEFS[type];
  if (!def) return false;
  const lv = def.levels[0];
  for (const [res, amt] of Object.entries(lv.cost)) {
    if ((sett.resources[res] || 0) < amt) return false;
  }
  if (walls.has(k(gx, gy))) return false;
  if (waterMap[gy] && waterMap[gy][gx]) return false;
  if (sett.buildings.some(b => b.gx === gx && b.gy === gy)) return false;
  if (def.requiresAdj) {
    const hasAdj = [[-1,0],[1,0],[0,-1],[0,1]].some(([ddx,ddy]) => {
      const nx = gx+ddx, ny = gy+ddy;
      if (def.requiresAdj === 'tree') return treeMap[ny] && treeMap[ny][nx];
      if (def.requiresAdj === 'water') return waterMap[ny] && waterMap[ny][nx];
      if (def.requiresAdj === 'wall') return walls.has(k(nx, ny));
      return false;
    });
    if (!hasAdj) return false;
  }
  return true;
}

function settPlaceBuilding(type, gx, gy) {
  const def = SETT_BUILDING_DEFS[type];
  const lv = def.levels[0];
  for (const [res, amt] of Object.entries(lv.cost)) sett.resources[res] -= amt;
  const b = settCreateBuilding(type, gx, gy);
  spawnFloatingText(gx, gy, 'Building ' + def.name, '#ffd54f');
  return b;
}

function settCanUpgrade(buildingId) {
  const b = sett.buildings.find(b2 => b2.id === buildingId);
  if (!b || !b.built || b.upgrading) return false;
  const def = SETT_BUILDING_DEFS[b.type];
  if (b.level >= def.levels.length - 1) return false;
  const nextLv = def.levels[b.level + 1];
  for (const [res, amt] of Object.entries(nextLv.cost)) {
    if ((sett.resources[res] || 0) < amt) return false;
  }
  return true;
}

function settUpgradeBuilding(buildingId) {
  const b = sett.buildings.find(b2 => b2.id === buildingId);
  if (!settCanUpgrade(buildingId)) return;
  const def = SETT_BUILDING_DEFS[b.type];
  const nextLv = def.levels[b.level + 1];
  for (const [res, amt] of Object.entries(nextLv.cost)) sett.resources[res] -= amt;
  b.upgrading = true;
  b.buildProgress = 0;
  b.buildTarget = nextLv.buildTime;
  spawnFloatingText(b.gx, b.gy, 'Upgrading to Lv' + (b.level + 2), '#ffa726');
}

function settAdvanceConstruction() {
  for (const b of sett.buildings) {
    if (b.built && !b.upgrading) continue;
    b.buildProgress++;
    if (b.buildProgress >= b.buildTarget) {
      if (b.upgrading) {
        b.level++;
        b.upgrading = false;
        const def = SETT_BUILDING_DEFS[b.type];
        const lv = def.levels[b.level];
        if (lv.hp) b.maxHp = lv.hp;
        b.hp = b.maxHp;
        settApplyBuildingEffects();
        spawnFloatingText(b.gx, b.gy, def.name + ' Lv' + (b.level + 1) + '!', '#4caf50');
      } else {
        b.built = true;
        b.level = 0;
        b.hp = b.maxHp;
        const def = SETT_BUILDING_DEFS[b.type];
        settApplyBuildingEffects();
        spawnFloatingText(b.gx, b.gy, def.name + ' Complete!', '#4caf50');
        settNotify(def.name + ' completed!', '#4caf50');
      }
      settRecalcTerritory();
    }
  }
}

function settApplyBuildingEffects() {
  // Recalc pop cap, storage cap, morale from all buildings
  let totalPopCap = 0;
  let extraStorage = 0;
  let totalMorale = 5; // base morale
  for (const b of sett.buildings) {
    if (!b.built) continue;
    const def = SETT_BUILDING_DEFS[b.type];
    const lv = def.levels[b.level];
    if (lv.popCap) totalPopCap += lv.popCap;
    if (lv.storageCap) extraStorage += lv.storageCap;
    if (lv.moraleBonus) totalMorale += lv.moraleBonus;
  }
  sett.popCap = totalPopCap;
  for (const res of SETT_RESOURCES) {
    const base = res === 'gold' ? 200 : (res === 'iron' ? 50 : (res === 'meat' || res === 'crops' ? 80 : 100));
    sett.storageCap[res] = base + extraStorage;
  }
  sett.morale = Math.min(10, totalMorale);
}

function settDemolish(buildingId) {
  const idx = sett.buildings.findIndex(b => b.id === buildingId);
  if (idx === -1) return;
  const b = sett.buildings[idx];
  // Refund 50% of level 1 cost
  const def = SETT_BUILDING_DEFS[b.type];
  const lv = def.levels[0];
  for (const [res, amt] of Object.entries(lv.cost)) {
    sett.resources[res] = Math.min(sett.storageCap[res], sett.resources[res] + Math.floor(amt / 2));
  }
  // Unassign workers
  sett.idleWorkers += b.workers;
  sett.buildings.splice(idx, 1);
  settApplyBuildingEffects();
  settRecalcTerritory();
  document.getElementById('overlay').classList.remove('show');
  spawnFloatingText(b.gx, b.gy, 'Demolished', '#f44336');
}

// --- SETTLERS RESOURCE SYSTEM ---
function settResourceTick() {
  const techBoost = sett.researched.improvedTools ? 1.25 : 1;
  for (const b of sett.buildings) {
    if (!b.built || b.upgrading) continue;
    const def = SETT_BUILDING_DEFS[b.type];
    const lv = def.levels[b.level];
    if (!lv.production || b.workers === 0) continue;
    const efficiency = Math.min(1, b.workers / def.workers);
    for (const [res, rate] of Object.entries(lv.production)) {
      let produced = Math.floor(rate * efficiency * techBoost);
      if (res === 'crops' && sett.researched.advancedFarming) produced += 2;
      if (res === 'gold' && sett.researched.economics) produced += 1;
      sett.resources[res] = Math.min(sett.storageCap[res], sett.resources[res] + produced);
    }
  }
  // Food consumption
  const foodNeeded = Math.ceil(sett.population / 2);
  let consumed = 0;
  const cropsUsed = Math.min(sett.resources.crops, foodNeeded);
  sett.resources.crops -= cropsUsed;
  consumed += cropsUsed;
  if (consumed < foodNeeded) {
    const meatUsed = Math.min(sett.resources.meat, foodNeeded - consumed);
    sett.resources.meat -= meatUsed;
    consumed += meatUsed;
  }
  if (consumed < foodNeeded) {
    sett.morale = Math.max(0, sett.morale - 1);
    if (sett.morale === 0 && Math.random() < 0.3) {
      sett.population = Math.max(1, sett.population - 1);
      settRecalcWorkers();
      settNotify('A villager has starved!', '#f44336');
    }
  }
}

// --- SETTLERS POPULATION ---
function settPopulationGrowth() {
  if (sett.turnCount % 10 !== 0) return;
  const foodProduced = settCalcFoodProduction();
  const foodNeeded = Math.ceil(sett.population / 2);
  if (foodProduced > foodNeeded && sett.population < sett.popCap && sett.morale >= 3) {
    sett.population++;
    sett.idleWorkers++;
    settNotify('Population grew to ' + sett.population + '!', '#4caf50');
  }
}

function settCalcFoodProduction() {
  let total = 0;
  const techBoost = sett.researched.improvedTools ? 1.25 : 1;
  for (const b of sett.buildings) {
    if (!b.built || b.upgrading || b.workers === 0) continue;
    const def = SETT_BUILDING_DEFS[b.type];
    const lv = def.levels[b.level];
    if (!lv.production) continue;
    const eff = Math.min(1, b.workers / def.workers);
    if (lv.production.crops) total += Math.floor(lv.production.crops * eff * techBoost);
    if (lv.production.meat) total += Math.floor(lv.production.meat * eff * techBoost);
  }
  return total;
}

function settAssignWorker(buildingId) {
  const b = sett.buildings.find(b2 => b2.id === buildingId);
  if (!b || !b.built) return;
  const def = SETT_BUILDING_DEFS[b.type];
  if (b.workers >= def.workers || sett.idleWorkers <= 0) return;
  b.workers++;
  sett.idleWorkers--;
}

function settUnassignWorker(buildingId) {
  const b = sett.buildings.find(b2 => b2.id === buildingId);
  if (!b || b.workers <= 0) return;
  b.workers--;
  sett.idleWorkers++;
}

function settRecalcWorkers() {
  let totalAssigned = 0;
  for (const b of sett.buildings) totalAssigned += b.workers;
  while (totalAssigned > sett.population) {
    const lb = [...sett.buildings].reverse().find(b => b.workers > 0);
    if (!lb) break;
    lb.workers--;
    totalAssigned--;
  }
  sett.idleWorkers = Math.max(0, sett.population - totalAssigned);
}

// --- SETTLERS RESEARCH ---
function settAdvanceResearch() {
  if (!sett.currentResearch) return;
  const academy = sett.buildings.find(b => b.type === 'academy' && b.built && !b.upgrading && b.workers > 0);
  if (!academy) return;
  const def = SETT_BUILDING_DEFS.academy;
  const lv = def.levels[academy.level];
  sett.currentResearch.progress += lv.researchSpeed;
  if (sett.currentResearch.progress >= sett.currentResearch.target) {
    sett.researched[sett.currentResearch.key] = true;
    const tech = SETT_TECH_TREE[sett.currentResearch.key];
    settNotify('Research complete: ' + tech.name + '!', '#64b5f6');
    spawnFloatingText(academy.gx, academy.gy, tech.name + '!', '#64b5f6');
    sett.currentResearch = null;
  }
}

function settStartResearch(techKey) {
  const tech = SETT_TECH_TREE[techKey];
  if (!tech || sett.researched[techKey] || sett.currentResearch) return;
  if (tech.requires.some(r => !sett.researched[r])) return;
  for (const [res, amt] of Object.entries(tech.cost)) {
    if ((sett.resources[res] || 0) < amt) return;
  }
  for (const [res, amt] of Object.entries(tech.cost)) sett.resources[res] -= amt;
  sett.currentResearch = { key: techKey, progress: 0, target: tech.time };
  settNotify('Researching: ' + tech.name, '#64b5f6');
  document.getElementById('overlay').classList.remove('show');
}

// --- SETTLERS MILITARY ---
function settTrainUnit(unitType, barracksId) {
  const udef = SETT_UNIT_TYPES[unitType];
  if (!udef) return;
  if (udef.requires && !sett.researched[udef.requires]) return;
  for (const [res, amt] of Object.entries(udef.cost)) {
    if ((sett.resources[res] || 0) < amt) return;
  }
  for (const [res, amt] of Object.entries(udef.cost)) sett.resources[res] -= amt;
  const barracks = sett.buildings.find(b => b.id === barracksId);
  const trainSpeed = barracks ? SETT_BUILDING_DEFS.barracks.levels[barracks.level].trainSpeed : 1;
  sett.training.push({ unitType, barracksId, progress: 0, target: Math.ceil(udef.trainTime / trainSpeed) });
  settNotify('Training ' + udef.name + '...', '#ffa726');
  document.getElementById('overlay').classList.remove('show');
}

function settAdvanceTraining() {
  for (let i = sett.training.length - 1; i >= 0; i--) {
    sett.training[i].progress++;
    if (sett.training[i].progress >= sett.training[i].target) {
      const t = sett.training[i];
      const udef = SETT_UNIT_TYPES[t.unitType];
      const barracks = sett.buildings.find(b => b.id === t.barracksId);
      const pos = barracks ? { x: barracks.gx, y: barracks.gy + 1 } : { x: player.x, y: player.y };
      sett.units.push({
        id: sett.nextUnitId++,
        type: t.unitType,
        gx: pos.x, gy: pos.y,
        hp: udef.hp, maxHp: udef.hp,
      });
      sett.training.splice(i, 1);
      settNotify(udef.name + ' ready!', '#4caf50');
      if (barracks) spawnFloatingText(barracks.gx, barracks.gy, udef.name + '!', '#4caf50');
    }
  }
}

function settGetMilitaryPower() {
  let total = 0;
  const bsmith = sett.buildings.find(b => b.type === 'blacksmith' && b.built);
  const atkBonus = bsmith ? SETT_BUILDING_DEFS.blacksmith.levels[bsmith.level].atkBonus : 0;
  for (const u of sett.units) {
    total += SETT_UNIT_TYPES[u.type].str + atkBonus;
  }
  return total;
}

// --- SETTLERS COMBAT ---
function settShouldAutoResolve(playerStr, enemyStr) {
  if (playerStr >= enemyStr * 2) return true;
  if (enemyStr < 15) return true;
  return false;
}

function settAutoResolveBattle(enemyStr) {
  const pStr = settGetMilitaryPower();
  if (pStr >= enemyStr) {
    const lossRatio = Math.min(0.5, enemyStr / pStr * 0.4);
    const unitsToLose = Math.max(0, Math.floor(sett.units.length * lossRatio));
    for (let i = 0; i < unitsToLose && sett.units.length > 0; i++) {
      const weakest = sett.units.reduce((a, b) => (a.hp < b.hp ? a : b));
      sett.units = sett.units.filter(u => u.id !== weakest.id);
    }
    return { won: true };
  } else {
    const unitsToLose = Math.max(1, Math.floor(sett.units.length * 0.5));
    for (let i = 0; i < unitsToLose && sett.units.length > 0; i++) {
      sett.units.pop();
    }
    return { won: false };
  }
}

// --- SETTLERS RAIDS ---
function settCheckRaid() {
  sett.raidTimer++;
  const builtCount = sett.buildings.filter(b => b.built).length;
  const interval = Math.max(15, 30 - Math.floor(builtCount / 2));
  if (sett.raidTimer < interval) return;
  sett.raidTimer = 0;
  sett.raidDifficulty = 1 + Math.floor(builtCount / 5) + Math.floor(sett.turnCount / 100);
  const raidStr = 8 + sett.raidDifficulty * 5 + randInt(0, sett.raidDifficulty * 3);
  settSpawnRaid(raidStr);
}

function settSpawnRaid(strength) {
  const hasWatchtower = sett.buildings.some(b => b.type === 'watchtower' && b.built);
  if (hasWatchtower) {
    settNotify('Watchtower spots incoming raid!', '#ff9800');
  }
  // Spawn at edge of explored area
  const cx = sett.mapCenterX, cy = sett.mapCenterY;
  const angle = Math.random() * Math.PI * 2;
  const dist2 = 15 + randInt(0, 10);
  const ex = Math.round(cx + Math.cos(angle) * dist2);
  const ey = Math.round(cy + Math.sin(angle) * dist2);
  // Resolve the raid
  const pStr = settGetMilitaryPower();
  // Wall defense bonus
  let wallBonus = 0;
  for (const b of sett.buildings) {
    if (b.type === 'wall_seg' && b.built) wallBonus += SETT_BUILDING_DEFS.wall_seg.levels[b.level].defense;
  }
  const effectivePStr = pStr + wallBonus;
  if (settShouldAutoResolve(effectivePStr, strength)) {
    const result = settAutoResolveBattle(strength);
    if (result.won) {
      settNotify('Raid repelled! (str ' + strength + ')', '#4caf50');
      const goldReward = Math.floor(strength * 0.5);
      sett.resources.gold = Math.min(sett.storageCap.gold, sett.resources.gold + goldReward);
      spawnFloatingText(player.x, player.y, '+' + goldReward + 'g', '#ffd54f');
    } else {
      settNotify('Raid overwhelmed defenses! (str ' + strength + ')', '#f44336');
      // Damage a random building
      const targets = sett.buildings.filter(b => b.built);
      if (targets.length > 0) {
        const target = targets[randInt(0, targets.length - 1)];
        target.hp -= Math.floor(strength * 0.3);
        if (target.hp <= 0) {
          settNotify(SETT_BUILDING_DEFS[target.type].name + ' destroyed by raid!', '#f44336');
          settDemolish(target.id);
        }
      }
    }
  } else {
    // Major battle - use existing tactical battle system
    // Build an army for the player from settlers units
    const pArmy = newArmy();
    // Map settlers units to conquerers troop types for battle
    for (const u of sett.units) {
      const mapping = { militia: 'riflemen', spearman: 'gunners', archer: 'snipers', knight: 'tanks', catapult: 'bombers' };
      const troopType = mapping[u.type] || 'riflemen';
      addTroops(pArmy, troopType, 1);
    }
    if (armyTotal(pArmy) === 0) addTroops(pArmy, 'riflemen', 2); // min defense
    player.army = pArmy;
    // Create fake enemy for battle
    const raidEnemy = { x: ex, y: ey, str: strength, type: 'militant', vx: ex, vy: ey, arrowCooldown: 0, patrol: 0, charged: false };
    enemies.push(raidEnemy);
    const ei = enemies.length - 1;
    enterBattle(enemies, ei, false);
    settNotify('Major raid incoming! Prepare for battle!', '#f44336');
  }
}

// --- SETTLERS TERRITORY ---
function settRecalcTerritory() {
  const maxY = grassMap.length;
  for (let y = 0; y < maxY; y++) {
    if (!territoryMap[y]) territoryMap[y] = [];
    const maxX = grassMap[y] ? grassMap[y].length : 0;
    for (let x = 0; x < maxX; x++) territoryMap[y][x] = null;
  }
  for (const b of sett.buildings) {
    if (!b.built) continue;
    const maxR = b.type === 'watchtower' ? (SETT_BUILDING_DEFS.watchtower.levels[b.level].visionRange || 4) :
                  b.type === 'house' ? 3 : 2;
    const queue = [{x: b.gx, y: b.gy, d: 0}];
    const visited = new Set();
    visited.add(k(b.gx, b.gy));
    if (territoryMap[b.gy]) territoryMap[b.gy][b.gx] = 'player';
    while (queue.length) {
      const c = queue.shift();
      if (c.d >= maxR) continue;
      for (const [ddx, ddy] of [[0,1],[0,-1],[1,0],[-1,0]]) {
        const nx = c.x + ddx, ny = c.y + ddy;
        if (ny < 0 || nx < 0 || !grassMap[ny] || grassMap[ny][nx] === undefined) continue;
        if (visited.has(k(nx, ny))) continue;
        if (waterMap[ny] && waterMap[ny][nx]) continue;
        visited.add(k(nx, ny));
        if (!territoryMap[ny]) territoryMap[ny] = [];
        territoryMap[ny][nx] = 'player';
        queue.push({x: nx, y: ny, d: c.d + 1});
      }
    }
  }
  minimapDirty = true;
}

// --- SETTLERS FOG ---
function settRevealAround(cx2, cy2, r) {
  for (let dy2 = -r; dy2 <= r; dy2++) {
    for (let dx2 = -r; dx2 <= r; dx2++) {
      if (dx2 * dx2 + dy2 * dy2 > r * r) continue;
      const nx = cx2 + dx2, ny = cy2 + dy2;
      if (ny >= 0 && nx >= 0 && fogMap[ny] && fogMap[ny][nx] !== undefined) {
        fogMap[ny][nx] = 2;
      }
    }
  }
  minimapDirty = true;
}

function settDimFog() {
  const maxY = grassMap.length;
  for (let y = 0; y < maxY; y++) {
    if (!fogMap[y]) continue;
    for (let x = 0; x < fogMap[y].length; x++) {
      if (fogMap[y][x] === 2) fogMap[y][x] = 1;
    }
  }
  settRevealAround(player.x, player.y, 5);
  for (const b of sett.buildings) {
    if (!b.built || b.type !== 'watchtower') continue;
    const vr = SETT_BUILDING_DEFS.watchtower.levels[b.level].visionRange || 4;
    settRevealAround(b.gx, b.gy, vr);
  }
}

// --- SETTLERS NOTIFICATIONS ---
function settNotify(text, color) {
  sett.notifications.push({ text, color, turn: sett.turnCount });
  if (sett.notifications.length > 20) sett.notifications.shift();
}

// --- SETTLERS MOVEMENT ---
function settTryMove(dx, dy) {
  if (isAnimating) {
    if (moveQueue.length < 2) moveQueue.push({ dx, dy });
    return;
  }
  const nx = player.x + dx, ny = player.y + dy;
  if (ny < 0 || nx < 0) return;
  if (!grassMap[ny] || grassMap[ny][nx] === undefined) return;
  if (walls.has(k(nx, ny))) return;
  if (waterMap[ny] && waterMap[ny][nx]) return;
  // Check if building is there (can walk on own buildings)
  isAnimating = true;
  player.lastDx = dx; player.lastDy = dy;
  player.x = nx; player.y = ny;
  sett.turnCount++;
  // Expand map
  settExpandMapIfNeeded(nx, ny);
  // Check enemy encounter
  const ei = enemies.findIndex(e => e.x === nx && e.y === ny);
  if (ei !== -1) {
    const e = enemies[ei];
    const pStr = settGetMilitaryPower();
    if (settShouldAutoResolve(pStr, e.str)) {
      const result = settAutoResolveBattle(e.str);
      if (result.won) {
        spawnFloatingText(nx, ny, 'Victory!', '#4caf50');
        const goldReward = Math.floor(e.str * 0.5);
        sett.resources.gold = Math.min(sett.storageCap.gold, sett.resources.gold + goldReward);
        spawnFloatingText(nx, ny, '+' + goldReward + 'g', '#ffd54f');
        enemies.splice(ei, 1);
      } else {
        spawnFloatingText(nx, ny, 'Defeat!', '#f44336');
        player.x -= dx; player.y -= dy;
      }
    } else {
      // Major battle via tactical system
      const pArmy = newArmy();
      for (const u of sett.units) {
        const mapping = { militia: 'riflemen', spearman: 'gunners', archer: 'snipers', knight: 'tanks', catapult: 'bombers' };
        addTroops(pArmy, mapping[u.type] || 'riflemen', 1);
      }
      if (armyTotal(pArmy) === 0) addTroops(pArmy, 'riflemen', 2);
      player.army = pArmy;
      enterBattle(enemies, ei, false);
      return;
    }
  }
  // Per-turn ticks
  settResourceTick();
  settAdvanceConstruction();
  settAdvanceResearch();
  settAdvanceTraining();
  settPopulationGrowth();
  settCheckRaid();
  settHealUnits();
  settDimFog();
  settUpdateHUD();
  minimapDirty = true;
  // Auto-save every 50 turns
  if (sett.turnCount % 50 === 0 && sett.turnCount > 0) settSaveGame(0);
}

function settHealUnits() {
  const hospital = sett.buildings.find(b => b.type === 'hospital' && b.built && !b.upgrading && b.workers > 0);
  if (!hospital) return;
  const healRate = SETT_BUILDING_DEFS.hospital.levels[hospital.level].healRate;
  const healBoost = sett.researched.medicine ? 2 : 0;
  for (const u of sett.units) {
    if (u.hp < u.maxHp) {
      u.hp = Math.min(u.maxHp, u.hp + healRate + healBoost);
    }
  }
}

// --- SETTLERS UI ---
function settUpdateHUD() {
  document.getElementById('hud').style.display = 'none';
  document.getElementById('shop').style.display = 'none';
  document.getElementById('engineer-shop').style.display = 'none';
  const settHud = document.getElementById('sett-hud');
  settHud.style.display = 'flex';
  let html = '';
  for (const res of SETT_RESOURCES) {
    const def = SETT_RESOURCE_DEFS[res];
    const val = sett.resources[res];
    const cap = sett.storageCap[res];
    html += '<span style="background:linear-gradient(180deg,#1a2744 0%,#0f1b30 100%);padding:3px 8px;border-radius:5px;border:1px solid #2a3a5a;">';
    html += '<span style="color:#778;font-size:0.75rem">' + def.icon + '</span> ';
    html += '<span style="font-weight:bold;color:' + def.color + '">' + val + '</span>';
    html += '<span style="color:#556;font-size:0.7rem">/' + cap + '</span></span>';
  }
  html += '<span style="background:linear-gradient(180deg,#2a1a44 0%,#1a0f30 100%);padding:3px 8px;border-radius:5px;border:1px solid #3a2a5a;">';
  html += '<span style="color:#778;font-size:0.75rem">Pop</span> ';
  html += '<span style="font-weight:bold;color:#ce93d8">' + sett.population + '/' + sett.popCap + '</span>';
  html += ' <span style="color:#888;font-size:0.7rem">(' + sett.idleWorkers + ' idle)</span></span>';
  html += '<span style="background:linear-gradient(180deg,#1a2744 0%,#0f1b30 100%);padding:3px 8px;border-radius:5px;border:1px solid #2a3a5a;">';
  html += '<span style="color:#778;font-size:0.75rem">Morale</span> ';
  html += '<span style="font-weight:bold;color:' + (sett.morale >= 5 ? '#4caf50' : '#f44336') + '">' + sett.morale + '</span></span>';
  html += '<span style="background:linear-gradient(180deg,#1a2744 0%,#0f1b30 100%);padding:3px 8px;border-radius:5px;border:1px solid #2a3a5a;">';
  html += '<span style="color:#778;font-size:0.75rem">Army</span> ';
  html += '<span style="font-weight:bold;color:#ff8a65">' + sett.units.length + '</span></span>';
  if (sett.currentResearch) {
    const pct = Math.floor((sett.currentResearch.progress / sett.currentResearch.target) * 100);
    html += '<span style="background:linear-gradient(180deg,#1a2744 0%,#0f1b30 100%);padding:3px 8px;border-radius:5px;border:1px solid #2a3a5a;">';
    html += '<span style="color:#64b5f6;font-size:0.75rem">Research ' + pct + '%</span></span>';
  }
  settHud.innerHTML = html;
}

function settUpdateControls() {
  const controls = document.getElementById('controls');
  controls.innerHTML = '';
  const btn = (text, onclick) => { const b = document.createElement('button'); b.textContent = text; b.onclick = onclick; controls.appendChild(b); };
  btn('Build (B)', () => settToggleBuildMenu());
  btn('Settlement', () => settShowSettlementInfo());
  btn('Research', () => settShowResearchMenu());
  btn('Save/Load', () => settShowSaveLoadUI());
  btn('Back to Menu', () => settBackToMenu());
}

function settBackToMenu() {
  appMode = 'conquerers';
  sett = null;
  document.getElementById('sett-hud').style.display = 'none';
  document.getElementById('hud').style.display = 'flex';
  document.getElementById('shop').style.display = 'flex';
  document.getElementById('engineer-shop').style.display = 'flex';
  // Restore controls
  document.getElementById('controls').innerHTML =
    '<button onclick="newGame()">Restart Game</button>' +
    '<button onclick="showSaveLoadUI()">Save/Load</button>' +
    '<button onclick="tryBuildFort()" id="buildFortBtn">Build Fort</button>';
  // Show start screen
  const _existingSaves2 = getSaves();
  const _hasSaves2 = Object.keys(_existingSaves2).length > 0;
  if (_hasSaves2) {
    let html = '<div style="text-align:center;font-family:sans-serif;">';
    html += '<p style="color:#aaa;margin:4px 0">Welcome back!</p>';
    html += '<button onclick="showSaveLoadUI()" style="padding:6px 16px;margin:4px;font-size:13px">Load Game</button>';
    html += '<button onclick="document.getElementById(\'overlay\').classList.remove(\'show\');showOverlay(\'CONQUERERS\',\'Enter your name, commander.\',\'Start Game\',()=>newGame(),true)" style="padding:6px 16px;margin:4px;font-size:13px">New Conquest</button>';
    html += '<button onclick="startSettlersMode()" style="padding:6px 16px;margin:4px;font-size:13px;background:linear-gradient(180deg,#1a3a1a 0%,#0e1a0e 100%);color:#81c784;border:1px solid #2e5a32">Settlers Mode</button>';
    html += '</div>';
    document.getElementById('overlayTitle').textContent = 'CONQUERERS';
    document.getElementById('overlayTitle').style.color = '#f0c040';
    document.getElementById('overlayMsg').innerHTML = html;
    document.getElementById('overlayBtn').style.display = 'none';
    document.getElementById('overlayInput').style.display = 'none';
    document.getElementById('overlay').classList.add('show');
  } else {
    showOverlay('CONQUERERS', 'Enter your name, commander.', 'Start Game', () => newGame(), true);
  }
}

// --- BUILD MENU ---
function settToggleBuildMenu() {
  if (sett.buildMode) { sett.buildMode = false; sett.buildSelected = null; msg(''); return; }
  let html = '<div style="text-align:center;font-family:sans-serif;max-width:520px">';
  html += '<h3 style="color:#ffd54f;margin:0 0 8px">BUILD</h3>';
  const categories = ['production', 'infrastructure', 'military', 'defense', 'economy'];
  for (const cat of categories) {
    html += '<div style="margin:6px 0"><span style="color:#aaa;font-size:11px;text-transform:uppercase">' + cat + '</span></div>';
    html += '<div style="display:flex;flex-wrap:wrap;gap:4px;justify-content:center">';
    for (const [bkey, def] of Object.entries(SETT_BUILDING_DEFS)) {
      if (def.category !== cat) continue;
      const lv = def.levels[0];
      const canAfford = Object.entries(lv.cost).every(([r, a]) => (sett.resources[r] || 0) >= a);
      const costStr = Object.entries(lv.cost).map(([r, a]) => a + SETT_RESOURCE_DEFS[r].icon).join(' ');
      html += '<button onclick="settSelectBuild(\'' + bkey + '\')" style="font-size:10px;padding:3px 8px;' + (canAfford ? '' : 'opacity:0.4;') + '">' + def.name + '<br><span style="font-size:9px;color:#aaa">' + costStr + '</span></button>';
    }
    html += '</div>';
  }
  html += '<div style="margin-top:8px"><button onclick="document.getElementById(\'overlay\').classList.remove(\'show\')" style="padding:4px 16px">Close</button></div></div>';
  document.getElementById('overlayTitle').textContent = '';
  document.getElementById('overlayMsg').innerHTML = html;
  document.getElementById('overlayBtn').style.display = 'none';
  document.getElementById('overlayInput').style.display = 'none';
  document.getElementById('overlay').classList.add('show');
}

function settSelectBuild(type) {
  document.getElementById('overlay').classList.remove('show');
  sett.buildMode = true;
  sett.buildSelected = type;
  msg('Click a tile to place ' + SETT_BUILDING_DEFS[type].name + ' (ESC to cancel)');
}

// --- BUILDING INFO PANEL ---
function settShowBuildingInfo(buildingId) {
  const b = sett.buildings.find(b2 => b2.id === buildingId);
  if (!b) return;
  const def = SETT_BUILDING_DEFS[b.type];
  const lv = def.levels[b.level];
  let html = '<div style="text-align:center;font-family:sans-serif;max-width:400px">';
  html += '<h3 style="color:#64b5f6;margin:0 0 6px">' + def.name + ' (Lv' + (b.level + 1) + ')</h3>';
  if (!b.built || b.upgrading) {
    const label = b.upgrading ? 'Upgrading' : 'Building';
    html += '<p style="color:#ffa726;font-size:12px">' + label + ': ' + b.buildProgress + '/' + b.buildTarget + ' turns</p>';
  } else {
    if (def.workers > 0) {
      html += '<div style="margin:6px 0;color:#aaa;font-size:12px">Workers: ' + b.workers + '/' + def.workers + '</div>';
      html += '<button onclick="settAssignWorker(' + b.id + ');settShowBuildingInfo(' + b.id + ')" style="font-size:10px;padding:2px 8px;margin:2px">+ Worker</button>';
      html += '<button onclick="settUnassignWorker(' + b.id + ');settShowBuildingInfo(' + b.id + ')" style="font-size:10px;padding:2px 8px;margin:2px">- Worker</button>';
    }
    if (lv.production) {
      const eff = def.workers > 0 ? Math.min(1, b.workers / def.workers) : 1;
      html += '<div style="color:#aaa;font-size:11px;margin-top:4px">Output: ';
      for (const [res, rate] of Object.entries(lv.production)) {
        html += Math.floor(rate * eff) + ' ' + SETT_RESOURCE_DEFS[res].name + '/turn ';
      }
      html += '</div>';
    }
    // Barracks: train units
    if (b.type === 'barracks') {
      html += '<div style="margin-top:6px"><span style="color:#aaa;font-size:11px">Train Units:</span><br>';
      for (const [uKey, uDef] of Object.entries(SETT_UNIT_TYPES)) {
        if (uDef.requires && !sett.researched[uDef.requires]) continue;
        const costStr = Object.entries(uDef.cost).map(([r, a]) => a + SETT_RESOURCE_DEFS[r].icon).join(' ');
        const canAfford = Object.entries(uDef.cost).every(([r, a]) => (sett.resources[r] || 0) >= a);
        html += '<button onclick="settTrainUnit(\'' + uKey + '\',' + b.id + ')" style="font-size:10px;padding:2px 8px;margin:2px;' + (canAfford ? '' : 'opacity:0.4') + '">' + uDef.name + ' (' + costStr + ')</button>';
      }
      html += '</div>';
    }
    // Market: trade
    if (b.type === 'market') {
      const ratio = lv.tradeRatio || 4;
      html += '<div style="margin-top:6px"><span style="color:#aaa;font-size:11px">Trade (' + ratio + ':1 ratio):</span><br>';
      for (const res of SETT_RESOURCES) {
        if (res === 'gold') continue;
        html += '<button onclick="settTrade(\'' + res + '\',' + ratio + ')" style="font-size:10px;padding:2px 6px;margin:1px">' + ratio + ' ' + SETT_RESOURCE_DEFS[res].icon + ' → 1G</button>';
      }
      html += '</div>';
    }
    // Upgrade button
    if (b.level < def.levels.length - 1) {
      const nextLv = def.levels[b.level + 1];
      const costStr = Object.entries(nextLv.cost).map(([r, a]) => a + SETT_RESOURCE_DEFS[r].icon).join(' ');
      const canUp = settCanUpgrade(b.id);
      html += '<div style="margin-top:8px"><button onclick="settUpgradeBuilding(' + b.id + ');document.getElementById(\'overlay\').classList.remove(\'show\')" style="font-size:11px;padding:3px 10px;background:linear-gradient(180deg,#2a2a1a 0%,#1a1a0e 100%);color:#ffd54f;border:1px solid #5a5a2e;' + (canUp ? '' : 'opacity:0.4') + '">Upgrade to Lv' + (b.level + 2) + ' (' + costStr + ')</button></div>';
    }
  }
  html += '<div style="margin-top:8px"><button onclick="settDemolish(' + b.id + ')" style="font-size:10px;padding:2px 8px;color:#f44336">Demolish</button>';
  html += ' <button onclick="document.getElementById(\'overlay\').classList.remove(\'show\')" style="font-size:11px;padding:3px 12px">Close</button></div></div>';
  document.getElementById('overlayTitle').textContent = '';
  document.getElementById('overlayMsg').innerHTML = html;
  document.getElementById('overlayBtn').style.display = 'none';
  document.getElementById('overlayInput').style.display = 'none';
  document.getElementById('overlay').classList.add('show');
}

function settTrade(res, ratio) {
  if ((sett.resources[res] || 0) < ratio) return;
  sett.resources[res] -= ratio;
  sett.resources.gold = Math.min(sett.storageCap.gold, sett.resources.gold + 1);
  settUpdateHUD();
}

// --- RESEARCH MENU ---
function settShowResearchMenu() {
  let html = '<div style="text-align:center;font-family:sans-serif;max-width:450px">';
  html += '<h3 style="color:#64b5f6;margin:0 0 8px">RESEARCH</h3>';
  if (sett.currentResearch) {
    const tech = SETT_TECH_TREE[sett.currentResearch.key];
    const pct = Math.floor((sett.currentResearch.progress / sett.currentResearch.target) * 100);
    html += '<p style="color:#ffa726;font-size:12px">Researching: ' + tech.name + ' (' + pct + '%)</p>';
  }
  const hasAcademy = sett.buildings.some(b => b.type === 'academy' && b.built && b.workers > 0);
  if (!hasAcademy) html += '<p style="color:#f44336;font-size:11px">Need a staffed Academy to research!</p>';
  for (const [tkey, tech] of Object.entries(SETT_TECH_TREE)) {
    if (sett.researched[tkey]) {
      html += '<div style="margin:3px;padding:4px 10px;font-size:11px;color:#4caf50;border:1px solid #2e5a32;border-radius:4px;display:inline-block">' + tech.name + ' ✓</div>';
      continue;
    }
    const prereqsMet = tech.requires.every(r => sett.researched[r]);
    const canAfford = Object.entries(tech.cost).every(([r, a]) => (sett.resources[r] || 0) >= a);
    const available = prereqsMet && canAfford && hasAcademy && !sett.currentResearch;
    const costStr = Object.entries(tech.cost).map(([r, a]) => a + SETT_RESOURCE_DEFS[r].icon).join(' ');
    html += '<div style="margin:3px;display:inline-block"><button onclick="settStartResearch(\'' + tkey + '\')" style="font-size:10px;padding:3px 8px;' + (available ? '' : 'opacity:0.4') + '">' + tech.name + '<br><span style="font-size:9px;color:#aaa">' + costStr + '</span></button></div>';
  }
  html += '<div style="margin-top:8px"><button onclick="document.getElementById(\'overlay\').classList.remove(\'show\')" style="padding:4px 16px">Close</button></div></div>';
  document.getElementById('overlayTitle').textContent = '';
  document.getElementById('overlayMsg').innerHTML = html;
  document.getElementById('overlayBtn').style.display = 'none';
  document.getElementById('overlayInput').style.display = 'none';
  document.getElementById('overlay').classList.add('show');
}

// --- SETTLEMENT INFO ---
function settShowSettlementInfo() {
  let html = '<div style="text-align:center;font-family:sans-serif;max-width:400px">';
  html += '<h3 style="color:#f0c040;margin:0 0 8px">' + sett.settlementName + '</h3>';
  html += '<p style="color:#aaa;font-size:12px">Turn ' + sett.turnCount + ' | Pop ' + sett.population + '/' + sett.popCap + ' | Morale ' + sett.morale + '/10</p>';
  html += '<p style="color:#aaa;font-size:11px">Buildings: ' + sett.buildings.filter(b => b.built).length + ' | Army: ' + sett.units.length + ' units (Power: ' + settGetMilitaryPower() + ')</p>';
  html += '<p style="color:#aaa;font-size:11px">Food production: ' + settCalcFoodProduction() + '/turn | Need: ' + Math.ceil(sett.population / 2) + '/turn</p>';
  if (sett.training.length > 0) {
    html += '<p style="color:#ffa726;font-size:11px">Training: ' + sett.training.map(t => SETT_UNIT_TYPES[t.unitType].name + ' (' + t.progress + '/' + t.target + ')').join(', ') + '</p>';
  }
  html += '<div style="margin-top:6px"><span style="color:#aaa;font-size:11px">Researched:</span><br>';
  const researched = Object.keys(sett.researched);
  if (researched.length === 0) html += '<span style="color:#556;font-size:10px">None yet</span>';
  else html += researched.map(r => '<span style="color:#64b5f6;font-size:10px">' + SETT_TECH_TREE[r].name + '</span>').join(', ');
  html += '</div>';
  html += '<div style="margin-top:8px"><button onclick="document.getElementById(\'overlay\').classList.remove(\'show\')" style="padding:4px 16px">Close</button></div></div>';
  document.getElementById('overlayTitle').textContent = '';
  document.getElementById('overlayMsg').innerHTML = html;
  document.getElementById('overlayBtn').style.display = 'none';
  document.getElementById('overlayInput').style.display = 'none';
  document.getElementById('overlay').classList.add('show');
}

// --- SETTLERS SAVE/LOAD ---
const SETT_SAVE_KEY = 'conquerers_settlers_saves';
function settGetSaves() { try { return JSON.parse(localStorage.getItem(SETT_SAVE_KEY)) || {}; } catch { return {}; } }

function settSaveGame(slot) {
  if (!sett) return;
  const saves = settGetSaves();
  saves['slot' + slot] = {
    playerName, playerX: player.x, playerY: player.y,
    sett: JSON.parse(JSON.stringify(sett)),
    enemies: enemies.map(e => ({ x: e.x, y: e.y, str: e.str, type: e.type })),
    walls: [...walls],
    grassMap: grassMap.map(row => row ? row.slice() : null),
    treeMap: treeMap.map(row => row ? row.slice() : null),
    waterMap: waterMap.map(row => row ? row.slice() : null),
    pathMap: pathMap.map(row => row ? row.slice() : null),
    fogMap: fogMap.map(row => row ? row.slice() : null),
    timestamp: Date.now(),
  };
  try { localStorage.setItem(SETT_SAVE_KEY, JSON.stringify(saves)); settNotify('Game saved to slot ' + slot, '#4caf50'); }
  catch(e) { settNotify('Save failed! Storage full?', '#f44336'); }
}

function settLoadGame(slot) {
  const saves = settGetSaves();
  const data = saves['slot' + slot];
  if (!data) return false;
  appMode = 'settlers';
  playerName = data.playerName;
  sett = data.sett;
  sett.notifications = sett.notifications || [];
  sett.training = sett.training || [];
  sett.buildMode = false; sett.buildSelected = null; sett.buildGhost = null;
  grassMap = data.grassMap || [];
  treeMap = data.treeMap || [];
  waterMap = data.waterMap || [];
  pathMap = data.pathMap || [];
  fogMap = data.fogMap || [];
  walls = new Set(data.walls || []);
  enemies = (data.enemies || []).map(e => ({ ...e, vx: e.x, vy: e.y, arrowCooldown: 0, patrol: 0, charged: false }));
  forts = []; allies = []; chests = []; mercCamps = []; overworldEngineers = []; playerForts = [];
  territoryMap = [];
  player = { x: data.playerX, y: data.playerY, army: newArmy(), lastDx: 1, lastDy: 0 };
  playerVisual = { x: player.x, y: player.y };
  camX = sett.camX; camY = sett.camY;
  particles = []; floatingTexts = []; ambientParticles = [];
  moveQueue = []; isAnimating = false;
  followerTrail = []; followerVisuals = [];
  settRecalcTerritory();
  gameMode = 'overworld';
  settUpdateHUD();
  settUpdateControls();
  minimapDirty = true;
  return true;
}

function settShowSaveLoadUI() {
  const saves = settGetSaves();
  let html = '<div style="text-align:center;font-family:sans-serif;max-width:400px">';
  html += '<h3 style="color:#f0c040;margin:0 0 8px">SETTLERS - SAVE / LOAD</h3>';
  for (let i = 0; i <= 4; i++) {
    const sd = saves['slot' + i];
    const label = i === 0 ? 'Auto' : 'Slot ' + i;
    if (sd) {
      const d = new Date(sd.timestamp);
      const info = (sd.sett.settlementName || 'Settlement') + ' | Turn ' + (sd.sett.turnCount || 0) + ' | ' + d.toLocaleDateString();
      html += '<div style="margin:4px 0">';
      html += '<button onclick="settLoadGame(' + i + ');document.getElementById(\'overlay\').classList.remove(\'show\')" style="font-size:11px;padding:3px 10px;margin:2px">Load ' + label + '</button>';
      if (i > 0) html += '<button onclick="settSaveGame(' + i + ');settShowSaveLoadUI()" style="font-size:11px;padding:3px 10px;margin:2px">Save ' + label + '</button>';
      html += '<span style="color:#aaa;font-size:10px;margin-left:6px">' + info + '</span>';
      html += '</div>';
    } else if (i > 0) {
      html += '<div style="margin:4px 0"><button onclick="settSaveGame(' + i + ');settShowSaveLoadUI()" style="font-size:11px;padding:3px 10px;margin:2px">Save ' + label + '</button><span style="color:#556;font-size:10px;margin-left:6px">Empty</span></div>';
    }
  }
  html += '<div style="margin-top:8px"><button onclick="document.getElementById(\'overlay\').classList.remove(\'show\')" style="padding:4px 16px">Close</button></div></div>';
  document.getElementById('overlayTitle').textContent = '';
  document.getElementById('overlayMsg').innerHTML = html;
  document.getElementById('overlayBtn').style.display = 'none';
  document.getElementById('overlayInput').style.display = 'none';
  document.getElementById('overlay').classList.add('show');
}

// --- SETTLERS RENDERING ---
function settUpdateSmooth() {
  camX += (player.x - camX) * CAM_SPEED;
  camY += (player.y - camY) * CAM_SPEED;
  const spd = MOVE_SPEED;
  playerVisual.x += (player.x - playerVisual.x) * spd;
  playerVisual.y += (player.y - playerVisual.y) * spd;
  if (Math.abs(player.x - playerVisual.x) < 0.01) playerVisual.x = player.x;
  if (Math.abs(player.y - playerVisual.y) < 0.01) playerVisual.y = player.y;
  if (shake > 0) shake *= 0.88;
  if (shake < 0.3) shake = 0;
  const animDone = Math.abs(player.x - playerVisual.x) < 0.15 && Math.abs(player.y - playerVisual.y) < 0.15;
  if (isAnimating && animDone) {
    isAnimating = false;
    if (moveQueue.length > 0) {
      const next = moveQueue.shift();
      settTryMove(next.dx, next.dy);
    }
  }
}

function settGetVisibleRange() {
  const margin = 3;
  const halfW = Math.ceil(W / TILE_W) + margin;
  const halfH = Math.ceil((H - PANEL_H) / TILE_H) + margin;
  return {
    minX: Math.max(0, Math.floor(camX - halfW)),
    maxX: Math.ceil(camX + halfW),
    minY: Math.max(0, Math.floor(camY - halfH)),
    maxY: Math.ceil(camY + halfH),
  };
}

function settDraw() {
  const sx = shake > 0.1 ? (Math.random() - 0.5) * shake : 0;
  const sy = shake > 0.1 ? (Math.random() - 0.5) * shake : 0;
  ctx.save();
  ctx.translate(sx, sy);
  ctx.fillStyle = '#0d1117';
  ctx.fillRect(0, 0, W, H);
  const vr = settGetVisibleRange();
  // Build lookup maps
  const _buildMap = new Map();
  for (const b of sett.buildings) _buildMap.set(k(b.gx, b.gy), b);
  const _unitMap = new Map();
  for (const u of sett.units) _unitMap.set(k(u.gx, u.gy), u);
  const _enemyMap2 = new Map();
  for (const e of enemies) _enemyMap2.set(k(e.x, e.y), e);
  // Z-sorted render
  const minSum = vr.minX + vr.minY;
  const maxSum = vr.maxX + vr.maxY;
  for (let sum2 = minSum; sum2 <= maxSum; sum2++) {
    for (let x = Math.max(vr.minX, sum2 - vr.maxY); x <= Math.min(vr.maxX, sum2 - vr.minY); x++) {
      const y = sum2 - x;
      if (y < 0 || x < 0) continue;
      if (!grassMap[y] || grassMap[y][x] === undefined) continue;
      const iso = toIso(x, y);
      if (iso.x < -TILE_W || iso.x > W + TILE_W || iso.y < -80 || iso.y > H) continue;
      const tKey = k(x, y);
      const fog = fogMap[y] ? fogMap[y][x] : 0;
      if (fog === 0) { drawFogTile(iso.x, iso.y, x, y); continue; }
      // Territory tint
      if (territoryMap[y] && territoryMap[y][x] === 'player') {
        ctx.fillStyle = 'rgba(76,175,80,0.06)';
        isoDiamondPath(iso.x, iso.y);
        ctx.fill();
      }
      // Terrain
      if (waterMap[y][x]) drawWater(iso.x, iso.y, x, y);
      else if (walls.has(tKey)) drawWall(iso.x, iso.y, x, y);
      else {
        drawGround(iso.x, iso.y, grassMap[y][x], x, y);
        if (treeMap[y][x]) drawTree(iso.x, iso.y, x, y);
      }
      if (fog === 1) {
        const bld = _buildMap.get(tKey);
        if (bld) settDrawBuilding(iso.x, iso.y, bld);
        ctx.fillStyle = 'rgba(8,12,18,0.45)';
        isoDiamondPath(iso.x, iso.y);
        ctx.fill();
        continue;
      }
      // fog=2
      const bld = _buildMap.get(tKey);
      if (bld) settDrawBuilding(iso.x, iso.y, bld);
      const unit = _unitMap.get(tKey);
      if (unit) settDrawUnit(iso.x, iso.y, unit);
      const en = _enemyMap2.get(tKey);
      if (en) {
        ctx.fillStyle = SETT_ENEMY_TYPES[en.type] ? SETT_ENEMY_TYPES[en.type].color : '#b71c1c';
        ctx.beginPath(); ctx.arc(iso.x, iso.y - 12, 6, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.font = '8px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText(en.str, iso.x, iso.y - 20);
      }
      // Build ghost
      if (sett.buildMode && sett.buildSelected) {
        // Track ghost position from mouse (calculated in click handler)
        if (sett.buildGhost && sett.buildGhost.gx === x && sett.buildGhost.gy === y) {
          ctx.globalAlpha = 0.5;
          settDrawBuildingByType(iso.x, iso.y, sett.buildSelected, 0);
          ctx.globalAlpha = 1;
        }
      }
      // Player
      if (player.x === x && player.y === y) {
        const piso = toIso(playerVisual.x, playerVisual.y);
        drawPlayer(piso.x, piso.y);
      }
    }
  }
  // Effects
  updateAmbientParticles();
  updateParticles();
  updateFloatingTexts();
  // Minimap
  settDrawMinimap();
  // Vignette
  const mapCX = W / 2, mapCY = (H - PANEL_H) / 2;
  const vigGrad = ctx.createRadialGradient(mapCX, mapCY, W * 0.22, mapCX, mapCY, W * 0.65);
  vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
  vigGrad.addColorStop(0.7, 'rgba(0,0,0,0.15)');
  vigGrad.addColorStop(1, 'rgba(0,0,0,0.45)');
  ctx.fillStyle = vigGrad;
  ctx.fillRect(0, 0, W, H - PANEL_H);
  // Bottom panel
  settDrawBottomPanel();
  ctx.restore();
}

// --- BUILDING DRAWING ---
function settDrawBuilding(sx, sy, bld) {
  const def = SETT_BUILDING_DEFS[bld.type];
  if (!bld.built && !bld.upgrading) {
    // Under construction scaffolding
    const pct = bld.buildProgress / bld.buildTarget;
    ctx.globalAlpha = 0.4 + pct * 0.6;
    settDrawBuildingByType(sx, sy, bld.type, 0);
    ctx.globalAlpha = 1;
    // Progress bar
    const bw = 24;
    ctx.fillStyle = '#333'; ctx.fillRect(sx - bw/2, sy - 28, bw, 3);
    ctx.fillStyle = '#ffa726'; ctx.fillRect(sx - bw/2, sy - 28, bw * pct, 3);
    return;
  }
  if (bld.upgrading) {
    settDrawBuildingByType(sx, sy, bld.type, bld.level);
    const pct = bld.buildProgress / bld.buildTarget;
    const bw = 24;
    ctx.fillStyle = '#333'; ctx.fillRect(sx - bw/2, sy - 28, bw, 3);
    ctx.fillStyle = '#64b5f6'; ctx.fillRect(sx - bw/2, sy - 28, bw * pct, 3);
    return;
  }
  settDrawBuildingByType(sx, sy, bld.type, bld.level);
  // Level star indicator
  if (bld.level > 0) {
    ctx.fillStyle = '#ffd54f';
    ctx.font = '8px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('★'.repeat(bld.level + 1), sx, sy - 22);
  }
  // Worker dots
  if (def.workers > 0 && bld.workers > 0) {
    for (let i = 0; i < bld.workers; i++) {
      ctx.fillStyle = '#4caf50';
      ctx.beginPath(); ctx.arc(sx - 8 + i * 5, sy + 12, 2, 0, Math.PI * 2); ctx.fill();
    }
  }
}

function settDrawBuildingByType(sx, sy, type, level) {
  switch (type) {
    case 'house': settDrawHouse(sx, sy, level); break;
    case 'farm': settDrawFarm(sx, sy, level); break;
    case 'lumbermill': settDrawLumbermill(sx, sy, level); break;
    case 'quarry': settDrawQuarry(sx, sy, level); break;
    case 'mine': settDrawMine(sx, sy, level); break;
    case 'huntingLodge': settDrawHuntingLodge(sx, sy, level); break;
    case 'barracks': settDrawBarracks(sx, sy, level); break;
    case 'wall_seg': settDrawWallSeg(sx, sy, level); break;
    case 'watchtower': settDrawWatchtower(sx, sy, level); break;
    case 'market': settDrawMarket(sx, sy, level); break;
    case 'blacksmith': settDrawBlacksmith(sx, sy, level); break;
    case 'warehouse': settDrawWarehouse(sx, sy, level); break;
    case 'hospital': settDrawHospital(sx, sy, level); break;
    case 'academy': settDrawAcademy(sx, sy, level); break;
    case 'temple': settDrawTemple(sx, sy, level); break;
    case 'port': settDrawPort(sx, sy, level); break;
    default: drawIsoBox(sx, sy, 14, '#888', '#666', '#555'); break;
  }
}

function settDrawHouse(sx, sy, lv) {
  const h = 16 + lv * 4;
  const colors = [['#8d6e63','#6d4c41','#5d4037'], ['#a1887f','#795548','#6d4c41'], ['#bcaaa4','#8d6e63','#795548']][lv];
  drawIsoBox(sx, sy, h, colors[0], colors[1], colors[2]);
  // Roof
  const roofCol = ['#c62828','#b71c1c','#d32f2f'][lv];
  ctx.fillStyle = roofCol;
  ctx.beginPath();
  ctx.moveTo(sx, sy - h - 8 - lv * 2);
  ctx.lineTo(sx + 18, sy - h + 2);
  ctx.lineTo(sx, sy - h + 8);
  ctx.lineTo(sx - 18, sy - h + 2);
  ctx.closePath(); ctx.fill();
  ctx.fillStyle = '#ffeb3b'; ctx.fillRect(sx + 2, sy - h + 5, 2 + lv, 2 + lv);
  ctx.fillStyle = '#3e2723'; ctx.fillRect(sx - 2, sy - 5, 3, 6);
}

function settDrawFarm(sx, sy, lv) {
  ctx.fillStyle = '#4e342e';
  isoDiamondPath(sx, sy); ctx.fill();
  ctx.fillStyle = '#66bb6a';
  const rows = 5 + lv * 2;
  for (let i = -rows; i < rows; i += 3) {
    const wave = Math.sin(animFrame * 0.03 + i) * 0.5;
    ctx.fillRect(sx + i, sy - 2 + wave, 1.5, 4 + lv);
  }
  if (lv >= 1) { drawIsoBox(sx + 12, sy - 3, 8, '#795548', '#5d4037', '#4e342e'); }
  if (lv >= 2) { ctx.fillStyle = '#ffd54f'; ctx.beginPath(); ctx.arc(sx + 12, sy - 14, 2, 0, Math.PI * 2); ctx.fill(); }
}

function settDrawLumbermill(sx, sy, lv) {
  const h = 14 + lv * 3;
  drawIsoBox(sx, sy, h, '#795548', '#5d4037', '#4e342e');
  // Saw blade
  ctx.strokeStyle = '#90a4ae'; ctx.lineWidth = 1.5;
  const angle = animFrame * 0.05;
  ctx.beginPath(); ctx.arc(sx + 8, sy - h - 2, 4 + lv, angle, angle + Math.PI); ctx.stroke();
  // Wood pile
  if (lv >= 1) { ctx.fillStyle = '#8d6e63'; ctx.fillRect(sx - 12, sy - 3, 6, 3); ctx.fillRect(sx - 12, sy - 6, 6, 3); }
  if (lv >= 2) { ctx.fillStyle = '#a1887f'; ctx.fillRect(sx - 12, sy - 9, 6, 3); }
}

function settDrawQuarry(sx, sy, lv) {
  ctx.fillStyle = '#455a64';
  isoDiamondPath(sx, sy); ctx.fill();
  const blocks = 3 + lv * 2;
  for (let i = 0; i < blocks; i++) {
    const bx = sx - 10 + (i % 3) * 8, by = sy - 4 - Math.floor(i / 3) * 6;
    ctx.fillStyle = i % 2 ? '#78909c' : '#607d8b';
    ctx.fillRect(bx, by, 6, 5);
  }
  if (lv >= 2) { ctx.fillStyle = '#b0bec5'; ctx.beginPath(); ctx.arc(sx, sy - 16, 3, 0, Math.PI * 2); ctx.fill(); }
}

function settDrawMine(sx, sy, lv) {
  drawIsoBox(sx, sy, 10, '#455a64', '#37474f', '#263238');
  // Mine entrance
  ctx.fillStyle = '#1a1a2e';
  ctx.beginPath(); ctx.arc(sx, sy - 4, 5, Math.PI, 0); ctx.fill();
  ctx.fillRect(sx - 5, sy - 4, 10, 4);
  // Support beams
  ctx.strokeStyle = '#795548'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(sx - 5, sy); ctx.lineTo(sx - 5, sy - 10); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(sx + 5, sy); ctx.lineTo(sx + 5, sy - 10); ctx.stroke();
  if (lv >= 1) { ctx.strokeStyle = '#ffd54f'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(sx - 5, sy - 10); ctx.lineTo(sx + 5, sy - 10); ctx.stroke(); }
  if (lv >= 2) { ctx.fillStyle = '#ffd54f'; ctx.beginPath(); ctx.arc(sx, sy - 14, 2, 0, Math.PI * 2); ctx.fill(); }
}

function settDrawHuntingLodge(sx, sy, lv) {
  const h = 12 + lv * 2;
  drawIsoBox(sx, sy, h, '#6d4c41', '#5d4037', '#4e342e');
  // Antler decoration
  ctx.strokeStyle = '#bcaaa4'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(sx - 3, sy - h - 2); ctx.lineTo(sx - 6, sy - h - 8); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(sx + 3, sy - h - 2); ctx.lineTo(sx + 6, sy - h - 8); ctx.stroke();
  if (lv >= 1) { ctx.fillStyle = '#ef5350'; ctx.beginPath(); ctx.arc(sx + 10, sy - 2, 2, 0, Math.PI * 2); ctx.fill(); }
  if (lv >= 2) { ctx.fillStyle = '#ef5350'; ctx.beginPath(); ctx.arc(sx + 10, sy - 5, 2, 0, Math.PI * 2); ctx.fill(); }
}

function settDrawBarracks(sx, sy, lv) {
  const h = 18 + lv * 4;
  const colors = [['#37474f','#263238','#1a1a2e'], ['#455a64','#37474f','#263238'], ['#546e7a','#455a64','#37474f']][lv];
  drawIsoBox(sx, sy, h, colors[0], colors[1], colors[2]);
  // Flag
  ctx.fillStyle = '#f44336';
  ctx.fillRect(sx + 12, sy - h - 10, 8, 5);
  ctx.strokeStyle = '#795548'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(sx + 12, sy - h - 12); ctx.lineTo(sx + 12, sy - h + 2); ctx.stroke();
  if (lv >= 1) { ctx.fillStyle = '#ffd54f'; ctx.fillRect(sx + 14, sy - h - 9, 2, 3); }
  if (lv >= 2) { ctx.fillStyle = '#ffd54f'; ctx.beginPath(); ctx.arc(sx + 16, sy - h - 7, 2, 0, Math.PI * 2); ctx.fill(); }
}

function settDrawWallSeg(sx, sy, lv) {
  const h = 8 + lv * 5;
  const colors = [['#795548','#5d4037','#4e342e'], ['#90a4ae','#78909c','#607d8b'], ['#607d8b','#546e7a','#455a64']][lv];
  drawIsoBox(sx, sy, h, colors[0], colors[1], colors[2]);
  if (lv >= 2) {
    // Battlements
    for (let i = -1; i <= 1; i++) {
      ctx.fillStyle = colors[0];
      ctx.fillRect(sx + i * 8, sy - h - 3, 4, 3);
    }
  }
}

function settDrawWatchtower(sx, sy, lv) {
  const h = 24 + lv * 6;
  drawIsoBox(sx, sy, h, '#5d4037', '#4e342e', '#3e2723');
  // Platform
  ctx.fillStyle = '#795548';
  ctx.fillRect(sx - 10, sy - h - 2, 20, 3);
  // Railing
  ctx.strokeStyle = '#8d6e63'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(sx - 10, sy - h - 6); ctx.lineTo(sx - 10, sy - h - 2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(sx + 10, sy - h - 6); ctx.lineTo(sx + 10, sy - h - 2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(sx - 10, sy - h - 6); ctx.lineTo(sx + 10, sy - h - 6); ctx.stroke();
  if (lv >= 1) {
    // Torch
    ctx.fillStyle = '#ff9800';
    ctx.beginPath(); ctx.arc(sx, sy - h - 8, 2, 0, Math.PI * 2); ctx.fill();
  }
  if (lv >= 2) {
    // Arrow slit
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(sx - 1, sy - h + 8, 2, 6);
  }
}

function settDrawMarket(sx, sy, lv) {
  // Stall
  drawIsoBox(sx, sy, 10, '#795548', '#5d4037', '#4e342e');
  // Canopy
  const colors = ['#e53935', '#ff8f00', '#43a047'][lv];
  ctx.fillStyle = colors;
  ctx.beginPath();
  ctx.moveTo(sx - 18, sy - 10);
  ctx.lineTo(sx + 18, sy - 10);
  ctx.lineTo(sx + 14, sy - 18);
  ctx.lineTo(sx - 14, sy - 18);
  ctx.closePath(); ctx.fill();
  // Goods
  if (lv >= 1) {
    ctx.fillStyle = '#ffd54f'; ctx.beginPath(); ctx.arc(sx - 5, sy - 3, 2, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#8d6e63'; ctx.fillRect(sx + 2, sy - 5, 3, 3);
  }
  if (lv >= 2) {
    ctx.fillStyle = '#66bb6a'; ctx.beginPath(); ctx.arc(sx + 8, sy - 3, 2, 0, Math.PI * 2); ctx.fill();
  }
}

function settDrawBlacksmith(sx, sy, lv) {
  const h = 16 + lv * 3;
  drawIsoBox(sx, sy, h, '#424242', '#333', '#212121');
  // Chimney smoke
  ctx.fillStyle = 'rgba(150,150,150,0.3)';
  const smokeY = sy - h - 6 - Math.sin(animFrame * 0.05) * 3;
  ctx.beginPath(); ctx.arc(sx + 8, smokeY, 3 + lv, 0, Math.PI * 2); ctx.fill();
  // Anvil
  ctx.fillStyle = '#616161';
  ctx.fillRect(sx - 3, sy - 5, 6, 3);
  ctx.fillRect(sx - 1, sy - 8, 2, 3);
  if (lv >= 1) { ctx.fillStyle = '#ff6f00'; ctx.beginPath(); ctx.arc(sx - 8, sy - 6, 2, 0, Math.PI * 2); ctx.fill(); }
}

function settDrawWarehouse(sx, sy, lv) {
  const h = 14 + lv * 4;
  drawIsoBox(sx, sy, h, '#6d4c41', '#5d4037', '#4e342e');
  // Door
  ctx.fillStyle = '#3e2723';
  ctx.fillRect(sx - 4, sy - 6, 8, 8);
  // Crates
  const crates = 1 + lv;
  for (let i = 0; i < crates; i++) {
    ctx.fillStyle = '#8d6e63';
    ctx.fillRect(sx + 10, sy - 3 - i * 5, 5, 4);
  }
}

function settDrawHospital(sx, sy, lv) {
  const h = 16 + lv * 3;
  drawIsoBox(sx, sy, h, '#e0e0e0', '#bdbdbd', '#9e9e9e');
  // Red cross
  ctx.fillStyle = '#f44336';
  ctx.fillRect(sx - 1, sy - h + 3, 3, 7);
  ctx.fillRect(sx - 3, sy - h + 5, 7, 3);
  if (lv >= 1) {
    // Window
    ctx.fillStyle = '#81d4fa';
    ctx.fillRect(sx - 6, sy - h + 5, 2, 3);
    ctx.fillRect(sx + 5, sy - h + 5, 2, 3);
  }
}

function settDrawAcademy(sx, sy, lv) {
  const h = 20 + lv * 4;
  drawIsoBox(sx, sy, h, '#5c6bc0', '#3f51b5', '#303f9f');
  // Columns
  ctx.fillStyle = '#9fa8da';
  ctx.fillRect(sx - 10, sy - 6, 2, 8);
  ctx.fillRect(sx + 8, sy - 6, 2, 8);
  // Book symbol
  ctx.fillStyle = '#ffd54f'; ctx.font = (8 + lv * 2) + 'px serif';
  ctx.textAlign = 'center';
  ctx.fillText('📖', sx, sy - h + 8);
}

function settDrawTemple(sx, sy, lv) {
  const h = 22 + lv * 5;
  drawIsoBox(sx, sy, h, '#f5f5dc', '#e8e0c0', '#d4c99a');
  // Spire
  ctx.fillStyle = '#ffd54f';
  ctx.beginPath();
  ctx.moveTo(sx, sy - h - 10 - lv * 3);
  ctx.lineTo(sx + 5, sy - h);
  ctx.lineTo(sx - 5, sy - h);
  ctx.closePath(); ctx.fill();
  if (lv >= 1) {
    ctx.fillStyle = '#ff9800';
    ctx.beginPath(); ctx.arc(sx, sy - h - 4, 2, 0, Math.PI * 2); ctx.fill();
  }
}

function settDrawPort(sx, sy, lv) {
  drawIsoBox(sx, sy, 10, '#795548', '#5d4037', '#4e342e');
  // Dock extending toward water
  ctx.fillStyle = '#8d6e63';
  ctx.fillRect(sx + 10, sy - 2, 12, 3);
  // Boat
  if (lv >= 1) {
    ctx.fillStyle = '#5d4037';
    ctx.beginPath();
    ctx.moveTo(sx + 16, sy - 6);
    ctx.lineTo(sx + 24, sy - 4);
    ctx.lineTo(sx + 16, sy - 2);
    ctx.closePath(); ctx.fill();
    // Sail
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.moveTo(sx + 18, sy - 6); ctx.lineTo(sx + 18, sy - 12); ctx.lineTo(sx + 22, sy - 6); ctx.closePath(); ctx.fill();
  }
  if (lv >= 2) {
    ctx.fillStyle = '#ffd54f'; ctx.beginPath(); ctx.arc(sx + 18, sy - 14, 2, 0, Math.PI * 2); ctx.fill();
  }
}

// --- UNIT DRAWING ---
function settDrawUnit(sx, sy, unit) {
  const udef = SETT_UNIT_TYPES[unit.type];
  if (!udef) return;
  ctx.fillStyle = udef.color;
  // Body
  ctx.beginPath(); ctx.arc(sx, sy - 8, 5, 0, Math.PI * 2); ctx.fill();
  // Head
  ctx.fillStyle = '#ffe0b2';
  ctx.beginPath(); ctx.arc(sx, sy - 15, 3, 0, Math.PI * 2); ctx.fill();
  // HP bar
  const hpPct = unit.hp / unit.maxHp;
  ctx.fillStyle = '#333'; ctx.fillRect(sx - 8, sy - 21, 16, 2);
  ctx.fillStyle = hpPct > 0.5 ? '#4caf50' : (hpPct > 0.25 ? '#ff9800' : '#f44336');
  ctx.fillRect(sx - 8, sy - 21, 16 * hpPct, 2);
}

// --- MINIMAP ---
function settDrawMinimap() {
  if (minimapDirty) {
    mmCtx.fillStyle = '#080c12';
    mmCtx.fillRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);
    // Determine bounds
    const chunks = Object.values(sett.chunks);
    if (chunks.length === 0) return;
    let minCX = Infinity, maxCX = -Infinity, minCY = Infinity, maxCY = -Infinity;
    for (const c of chunks) { minCX = Math.min(minCX, c.cx); maxCX = Math.max(maxCX, c.cx); minCY = Math.min(minCY, c.cy); maxCY = Math.max(maxCY, c.cy); }
    const tilesW = (maxCX - minCX + 1) * SETT_CHUNK_SIZE;
    const tilesH = (maxCY - minCY + 1) * SETT_CHUNK_SIZE;
    const scale = Math.min(MINIMAP_SIZE / tilesW, MINIMAP_SIZE / tilesH);
    const offX = minCX * SETT_CHUNK_SIZE;
    const offY = minCY * SETT_CHUNK_SIZE;
    for (let y = offY; y < offY + tilesH; y++) {
      if (!fogMap[y]) continue;
      for (let x = offX; x < offX + tilesW; x++) {
        if (fogMap[y][x] === 0) continue;
        const px = (x - offX) * scale;
        const py = (y - offY) * scale;
        if (waterMap[y] && waterMap[y][x]) mmCtx.fillStyle = '#1565c0';
        else if (walls.has(k(x, y))) mmCtx.fillStyle = '#546e7a';
        else if (territoryMap[y] && territoryMap[y][x] === 'player') mmCtx.fillStyle = '#2e7d32';
        else mmCtx.fillStyle = '#1b5e20';
        mmCtx.fillRect(px, py, Math.max(1, scale), Math.max(1, scale));
      }
    }
    // Buildings
    for (const b of sett.buildings) {
      mmCtx.fillStyle = b.built ? '#ffd54f' : '#ff9800';
      const px = (b.gx - offX) * scale;
      const py = (b.gy - offY) * scale;
      mmCtx.fillRect(px - 1, py - 1, 3, 3);
    }
    // Enemies
    for (const e of enemies) {
      if (fogMap[e.y] && fogMap[e.y][e.x] >= 1) {
        mmCtx.fillStyle = '#f44336';
        mmCtx.fillRect((e.x - offX) * scale - 1, (e.y - offY) * scale - 1, 2, 2);
      }
    }
    // Player
    mmCtx.fillStyle = '#fff';
    mmCtx.fillRect((player.x - offX) * scale - 2, (player.y - offY) * scale - 2, 4, 4);
    minimapDirty = false;
  }
  // Draw minimap to main canvas
  const mmX = W - MINIMAP_SIZE - 8;
  const mmY = 8;
  ctx.globalAlpha = 0.85;
  ctx.fillStyle = '#0a0e14';
  ctx.fillRect(mmX - 2, mmY - 2, MINIMAP_SIZE + 4, MINIMAP_SIZE + 4);
  ctx.drawImage(minimapCanvas, mmX, mmY);
  ctx.globalAlpha = 1;
  ctx.strokeStyle = '#3a4a6a';
  ctx.strokeRect(mmX - 2, mmY - 2, MINIMAP_SIZE + 4, MINIMAP_SIZE + 4);
}

// --- BOTTOM PANEL ---
function settDrawBottomPanel() {
  const panelY = H - PANEL_H;
  const panelGrad = ctx.createLinearGradient(0, panelY, 0, panelY + PANEL_H);
  panelGrad.addColorStop(0, '#1a2218');
  panelGrad.addColorStop(1, '#0a1208');
  ctx.fillStyle = panelGrad;
  ctx.fillRect(0, panelY, W, PANEL_H);
  ctx.fillStyle = '#2a5a2e'; ctx.fillRect(0, panelY, W, 1);
  // Notifications
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'left';
  const recent = sett.notifications.slice(-3);
  for (let i = 0; i < recent.length; i++) {
    ctx.fillStyle = recent[i].color;
    ctx.fillText(recent[i].text, 10, panelY + 15 + i * 14);
  }
  // Build mode
  if (sett.buildMode && sett.buildSelected) {
    ctx.textAlign = 'right';
    ctx.fillStyle = '#ffd54f'; ctx.font = '12px sans-serif';
    ctx.fillText('Placing: ' + SETT_BUILDING_DEFS[sett.buildSelected].name + '  (ESC to cancel)', W - 10, panelY + 20);
  }
  // Turn counter
  ctx.textAlign = 'right';
  ctx.fillStyle = '#556'; ctx.font = '10px sans-serif';
  ctx.fillText('Turn ' + sett.turnCount, W - 10, panelY + PANEL_H - 6);
}

// ═══════════════════════════════════════════
//  ANIMATION LOOP & INPUT
// ═══════════════════════════════════════════
function gameLoop() {
  animFrame++;

  // Engineer passive crafting timer (every 5 min per engineer → +1 ATK, cap 10) — conquerers only
  if (appMode === 'conquerers' && recruitedEngineers > 0 && engineerATKBonus < 10) {
    engineerTimer++;
    const interval = Math.floor(18000 / recruitedEngineers); // 5 min / num engineers
    if (engineerTimer >= interval) {
      engineerTimer = 0;
      engineerATKBonus = Math.min(10, engineerATKBonus + 1);
      if (gameMode === 'overworld') {
        spawnFloatingText(player.x, player.y, 'ENG +1 ATK', '#ff9800');
        msg('Engineers crafted a weapon upgrade! (ATK +' + engineerATKBonus + ')');
        updateHUD();
      }
    }
  }

  try {
    if (appMode === 'settlers' && sett) {
      if (gameMode === 'overworld') {
        settUpdateSmooth();
        settDraw();
      } else {
        updateBattleSmooth();
        drawBattle();
      }
    } else {
      if (gameMode === 'overworld') {
        updateSmooth();
        draw();
      } else {
        updateBattleSmooth();
        drawBattle();
      }
    }
  } catch (err) {
    console.error('Game loop error:', err);
  }
  requestAnimationFrame(gameLoop);
}

function updateSmooth() {
  // Update camera
  updateCamera();
  // Smooth player position
  const spd = MOVE_SPEED;
  playerVisual.x += (player.x - playerVisual.x) * spd;
  playerVisual.y += (player.y - playerVisual.y) * spd;
  // Snap when close enough
  if (Math.abs(player.x - playerVisual.x) < 0.01 && Math.abs(player.y - playerVisual.y) < 0.01) {
    playerVisual.x = player.x;
    playerVisual.y = player.y;
  }

  // Smooth enemy positions
  for (const e of enemies) {
    if (e.vx === undefined) { e.vx = e.x; e.vy = e.y; }
    e.vx += (e.x - e.vx) * spd;
    e.vy += (e.y - e.vy) * spd;
    if (Math.abs(e.x - e.vx) < 0.01 && Math.abs(e.y - e.vy) < 0.01) {
      e.vx = e.x; e.vy = e.y;
    }
  }

  // Smooth follower positions
  for (let i = 0; i < followerTrail.length; i++) {
    if (!followerVisuals[i]) followerVisuals[i] = { x: followerTrail[i].x, y: followerTrail[i].y };
    const fv = followerVisuals[i];
    const ft = followerTrail[i];
    fv.x += (ft.x - fv.x) * (spd * 0.7);
    fv.y += (ft.y - fv.y) * (spd * 0.7);
    if (Math.abs(ft.x - fv.x) < 0.01 && Math.abs(ft.y - fv.y) < 0.01) {
      fv.x = ft.x; fv.y = ft.y;
    }
  }

  // Fog handled in tryMove via dimFog()

  // Smooth shake decay
  if (shake > 0) shake *= 0.88;
  if (shake < 0.3) shake = 0;

  // Check if player animation is done, process next queued move
  const animDone = Math.abs(player.x - playerVisual.x) < 0.15 && Math.abs(player.y - playerVisual.y) < 0.15;
  if (isAnimating && animDone) {
    isAnimating = false;
    if (moveQueue.length > 0) {
      const next = moveQueue.shift();
      tryMove(next.dx, next.dy);
    }
  }
}

document.getElementById('overlayInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') { e.preventDefault(); overlayAction(); }
});

document.addEventListener('keydown', e => {
  if (document.getElementById('overlay').classList.contains('show')) return;
  if (appMode === 'settlers' && sett) {
    if (gameMode === 'overworld') {
      switch (e.key) {
        case 'ArrowUp': case 'w': case 'W': e.preventDefault(); settTryMove(0, -1); break;
        case 'ArrowDown': case 's': case 'S': e.preventDefault(); settTryMove(0, 1); break;
        case 'ArrowLeft': case 'a': case 'A': e.preventDefault(); settTryMove(-1, 0); break;
        case 'ArrowRight': case 'd': case 'D': e.preventDefault(); settTryMove(1, 0); break;
        case 'Escape': if (sett.buildMode) { sett.buildMode = false; sett.buildSelected = null; msg(''); } break;
        case 'b': case 'B': settToggleBuildMenu(); break;
      }
    } else if (gameMode === 'battle') {
      if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); battle.simPaused = !battle.simPaused; }
      if (e.key === '1') { battle.simSpeed = 1; battle.simPaused = false; }
      if (e.key === '2') { battle.simSpeed = 2; battle.simPaused = false; }
      if (e.key === '3') { battle.simSpeed = 4; battle.simPaused = false; }
    } else if (gameMode === 'deploy') {
      if (e.key === 'Escape') { e.preventDefault(); cancelDeploy(); }
    }
  } else {
    if (gameMode === 'overworld') {
      switch (e.key) {
        case 'ArrowUp': case 'w': case 'W': e.preventDefault(); tryMove(0, -1); break;
        case 'ArrowDown': case 's': case 'S': e.preventDefault(); tryMove(0, 1); break;
        case 'ArrowLeft': case 'a': case 'A': e.preventDefault(); tryMove(-1, 0); break;
        case 'ArrowRight': case 'd': case 'D': e.preventDefault(); tryMove(1, 0); break;
      }
    } else if (gameMode === 'battle') {
      if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); battle.simPaused = !battle.simPaused; }
      if (e.key === '1') { battle.simSpeed = 1; battle.simPaused = false; }
      if (e.key === '2') { battle.simSpeed = 2; battle.simPaused = false; }
      if (e.key === '3') { battle.simSpeed = 4; battle.simPaused = false; }
    } else if (gameMode === 'deploy') {
      if (e.key === 'Escape') { e.preventDefault(); cancelDeploy(); }
    }
  }
});

canvas.addEventListener('mousemove', e => {
  if (appMode !== 'settlers' || !sett || !sett.buildMode) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width, scaleY = H / rect.height;
  const mx2 = (e.clientX - rect.left) * scaleX;
  const my2 = (e.clientY - rect.top) * scaleY;
  const grid = fromIso(mx2, my2);
  sett.buildGhost = { gx: grid.x, gy: grid.y };
});

canvas.addEventListener('click', e => {
  if (document.getElementById('overlay').classList.contains('show')) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width, scaleY = H / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;

  if (appMode === 'settlers' && sett && gameMode === 'overworld') {
    if (my >= H - PANEL_H) return;
    const grid = fromIso(mx, my);
    if (grid.x < 0 || grid.y < 0) return;
    if (!grassMap[grid.y] || grassMap[grid.y][grid.x] === undefined) return;
    // Update build ghost for visual feedback
    if (sett.buildMode && sett.buildSelected) {
      if (settCanBuild(sett.buildSelected, grid.x, grid.y)) {
        settPlaceBuilding(sett.buildSelected, grid.x, grid.y);
        settUpdateHUD();
      } else {
        msg('Cannot build here!');
      }
      sett.buildMode = false;
      sett.buildSelected = null;
      return;
    }
    // Check if clicking on own building
    const clickedBld = sett.buildings.find(b => b.gx === grid.x && b.gy === grid.y && b.built);
    if (clickedBld) {
      settShowBuildingInfo(clickedBld.id);
      return;
    }
    const dx = Math.sign(grid.x - player.x), dy = Math.sign(grid.y - player.y);
    if (dx === 0 && dy === 0) return;
    if (Math.abs(grid.x - player.x) >= Math.abs(grid.y - player.y)) settTryMove(dx, 0);
    else settTryMove(0, dy);
  } else if (gameMode === 'overworld') {
    if (my >= H - PANEL_H) return;
    const grid = fromIso(mx, my);
    if (grid.x < 0 || grid.x >= COLS || grid.y < 0 || grid.y >= ROWS) return;
    const dx = Math.sign(grid.x - player.x), dy = Math.sign(grid.y - player.y);
    if (dx === 0 && dy === 0) return;
    if (Math.abs(grid.x - player.x) >= Math.abs(grid.y - player.y)) tryMove(dx, 0);
    else tryMove(0, dy);
  } else if (gameMode === 'deploy') {
    handleDeployClick(mx, my);
  } else if (gameMode === 'battle') {
    handleBattleClick(mx, my);
  } else if (gameMode === 'battle_result') {
    handleResultClick();
  }
});

// Check for existing saves on load
const _existingSaves = getSaves();
const _hasAutoSave = !!_existingSaves.slot0;
const _hasSaves = Object.keys(_existingSaves).length > 0;
const _settSaves = settGetSaves();
const _hasSettSaves = Object.keys(_settSaves).length > 0;
if (_hasSaves || _hasSettSaves) {
  let html = '<div style="text-align:center;font-family:sans-serif;">';
  html += '<p style="color:#aaa;margin:4px 0">Welcome, Commander!</p>';
  if (_hasSaves) html += '<button onclick="showSaveLoadUI()" style="padding:6px 16px;margin:4px;font-size:13px">Load Conquest</button>';
  html += '<button onclick="document.getElementById(\'overlay\').classList.remove(\'show\');showOverlay(\'CONQUERERS\',\'Enter your name, commander.\',\'Start Game\',()=>newGame(),true)" style="padding:6px 16px;margin:4px;font-size:13px">New Conquest</button>';
  if (_hasSettSaves) html += '<button onclick="settShowSaveLoadUI()" style="padding:6px 16px;margin:4px;font-size:13px;background:linear-gradient(180deg,#1a3a1a 0%,#0e1a0e 100%);color:#81c784;border:1px solid #2e5a32">Load Settlement</button>';
  html += '<button onclick="startSettlersMode()" style="padding:6px 16px;margin:4px;font-size:13px;background:linear-gradient(180deg,#1a3a1a 0%,#0e1a0e 100%);color:#81c784;border:1px solid #2e5a32">New Settlement</button>';
  html += '</div>';
  document.getElementById('overlayTitle').textContent = 'CONQUERERS';
  document.getElementById('overlayTitle').style.color = '#f0c040';
  document.getElementById('overlayMsg').innerHTML = html;
  document.getElementById('overlayBtn').style.display = 'none';
  document.getElementById('overlayInput').style.display = 'none';
  document.getElementById('overlay').classList.add('show');
  overlayCallback = () => { document.getElementById('overlayBtn').style.display = ''; document.getElementById('overlayMsg').innerHTML = ''; };
} else {
  let html = '<div style="text-align:center;font-family:sans-serif;">';
  html += '<p style="color:#aaa;margin:4px 0">Choose your mode:</p>';
  html += '<button onclick="document.getElementById(\'overlay\').classList.remove(\'show\');showOverlay(\'CONQUERERS\',\'Enter your name, commander.\',\'Start Game\',()=>newGame(),true)" style="padding:6px 16px;margin:4px;font-size:13px">Conquest Mode</button>';
  html += '<button onclick="startSettlersMode()" style="padding:6px 16px;margin:4px;font-size:13px;background:linear-gradient(180deg,#1a3a1a 0%,#0e1a0e 100%);color:#81c784;border:1px solid #2e5a32">Settlers Mode</button>';
  html += '</div>';
  document.getElementById('overlayTitle').textContent = 'CONQUERERS';
  document.getElementById('overlayTitle').style.color = '#f0c040';
  document.getElementById('overlayMsg').innerHTML = html;
  document.getElementById('overlayBtn').style.display = 'none';
  document.getElementById('overlayInput').style.display = 'none';
  document.getElementById('overlay').classList.add('show');
  overlayCallback = () => {};
}
gameLoop();
</script>
</body>
</html>
